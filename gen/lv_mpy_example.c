
/*
 * Auto-Generated file, DO NOT EDIT!
 *
 * Command line:
 * gen_mpy.py -M lvgl -MP lv -I../../berkeley-db-1.xx/PORT/include -I../../lv_bindings -I. -I../.. -Ibuild -I../../mp-readline -I ../../lv_bindings/pycparser/utils/fake_libc_include ../../lv_bindings/lvgl/lvgl.h
 *
 * Preprocessing command:
 * gcc -E -std=c99 -DPYCPARSER  -I ../../berkeley-db-1.xx/PORT/include -I ../../lv_bindings -I . -I ../.. -I build -I ../../mp-readline -I ../../lv_bindings/pycparser/utils/fake_libc_include -include ../../lv_bindings/lvgl/lvgl.h ../../lv_bindings/lvgl/lvgl.h
 *
 * Generating Objects: obj(None), cont(obj), btn(obj), imgbtn(obj), label(obj), img(obj), line(obj), page(obj), list(obj), chart(obj), table(obj), checkbox(obj), cpicker(obj), bar(obj), slider(obj), led(obj), btnmatrix(obj), keyboard(obj), dropdown(obj), roller(obj), textarea(obj), canvas(obj), win(obj), tabview(obj), tileview(obj), msgbox(obj), objmask(obj), linemeter(obj), gauge(obj), switch(obj), arc(obj), spinner(obj), calendar(obj), spinbox(obj)
 */

/*
 * Mpy includes
 */

#include <stdlib.h>
#include <string.h>
#include "py/obj.h"
#include "py/objint.h"
#include "py/objstr.h"
#include "py/runtime.h"
#include "py/binary.h"
#include "py/objarray.h"

/*
 * lvgl includes
 */

#include "../../lv_bindings/lvgl/lvgl.h"


#define LV_OBJ_T lv_obj_t

STATIC const mp_obj_type_t mp_obj_type;

STATIC inline const mp_obj_type_t *get_BaseObj_type()
{
    return &mp_obj_type;
}
    

/*
 * Helper functions
 */

#ifndef GENMPY_UNUSED
#ifdef __GNUC__
#define GENMPY_UNUSED __attribute__ ((unused))
#else
#define GENMPY_UNUSED
#endif // __GNUC__
#endif // GENMPY_UNUSED

// Custom function mp object

typedef mp_obj_t (*mp_fun_ptr_var_t)(size_t n, const mp_obj_t *, void *ptr);

typedef struct mp_lv_obj_fun_builtin_var_t {
    mp_obj_base_t base;
    mp_uint_t n_args;
    mp_fun_ptr_var_t mp_fun;
    void *lv_fun;
} mp_lv_obj_fun_builtin_var_t;

STATIC mp_obj_t lv_fun_builtin_var_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args);
STATIC mp_int_t mp_func_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags);

GENMPY_UNUSED STATIC const mp_obj_type_t mp_lv_type_fun_builtin_var = {
    { &mp_type_type },
    .flags = MP_TYPE_FLAG_BINDS_SELF | MP_TYPE_FLAG_BUILTIN_FUN,
    .name = MP_QSTR_function,
    .call = lv_fun_builtin_var_call,
    .unary_op = mp_generic_unary_op,
    .buffer_p = { .get_buffer = mp_func_get_buffer }
};

GENMPY_UNUSED STATIC const mp_obj_type_t mp_lv_type_fun_builtin_static_var = {
    { &mp_type_type },
    .flags = MP_TYPE_FLAG_BUILTIN_FUN,
    .name = MP_QSTR_function,
    .call = lv_fun_builtin_var_call,
    .unary_op = mp_generic_unary_op,
    .buffer_p = { .get_buffer = mp_func_get_buffer }
};

STATIC mp_obj_t lv_fun_builtin_var_call(mp_obj_t self_in, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    assert(MP_OBJ_IS_TYPE(self_in, &mp_lv_type_fun_builtin_var) ||
           MP_OBJ_IS_TYPE(self_in, &mp_lv_type_fun_builtin_static_var));
    mp_lv_obj_fun_builtin_var_t *self = MP_OBJ_TO_PTR(self_in);
    mp_arg_check_num(n_args, n_kw, self->n_args, self->n_args, false);
    return self->mp_fun(n_args, args, self->lv_fun);
}

STATIC mp_int_t mp_func_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags) {
    (void)flags;
    assert(MP_OBJ_IS_TYPE(self_in, &mp_lv_type_fun_builtin_var) ||
           MP_OBJ_IS_TYPE(self_in, &mp_lv_type_fun_builtin_static_var));
    mp_lv_obj_fun_builtin_var_t *self = MP_OBJ_TO_PTR(self_in);

    bufinfo->buf = &self->lv_fun;
    bufinfo->len = sizeof(self->lv_fun);
    bufinfo->typecode = BYTEARRAY_TYPECODE;
    return 0;
}

#define MP_DEFINE_CONST_LV_FUN_OBJ_VAR(obj_name, n_args, mp_fun, lv_fun) \
    const mp_lv_obj_fun_builtin_var_t obj_name = \
        {{&mp_lv_type_fun_builtin_var}, n_args, mp_fun, lv_fun}

#define MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(obj_name, n_args, mp_fun, lv_fun) \
    const mp_lv_obj_fun_builtin_var_t obj_name = \
        {{&mp_lv_type_fun_builtin_static_var}, n_args, mp_fun, lv_fun}

// Casting

typedef struct mp_lv_struct_t
{
    mp_obj_base_t base;
    void *data;
} mp_lv_struct_t;

STATIC const mp_lv_struct_t mp_lv_null_obj;

#ifdef LV_OBJ_T
STATIC mp_int_t mp_lv_obj_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags);
#else
STATIC mp_int_t mp_lv_obj_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags){ return 0; }
#endif

STATIC mp_obj_t get_native_obj(mp_obj_t *mp_obj)
{
    if (!MP_OBJ_IS_OBJ(mp_obj)) return mp_obj;
    const mp_obj_type_t *native_type = ((mp_obj_base_t*)mp_obj)->type;
    if (native_type->parent == NULL || 
        (native_type->buffer_p.get_buffer == mp_lv_obj_get_buffer)) return mp_obj;
    while (native_type->parent) native_type = native_type->parent;
    return mp_obj_cast_to_native_base(mp_obj, MP_OBJ_FROM_PTR(native_type));
}

STATIC mp_obj_t dict_to_struct(mp_obj_t dict, const mp_obj_type_t *type);

STATIC mp_obj_t make_new_lv_struct(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args);

STATIC mp_obj_t *cast(mp_obj_t *mp_obj, const mp_obj_type_t *mp_type)
{
    mp_obj_t *res = NULL;
    if (mp_obj == mp_const_none && mp_type->make_new == &make_new_lv_struct) {
        res = MP_OBJ_FROM_PTR(&mp_lv_null_obj);
    } else if (MP_OBJ_IS_OBJ(mp_obj)) {
        res = get_native_obj(mp_obj);
        if (res){
            const mp_obj_type_t *res_type = ((mp_obj_base_t*)res)->type;
            if (res_type != mp_type){
                if (res_type == &mp_type_dict &&
                    mp_type->make_new == &make_new_lv_struct)
                        res = dict_to_struct(res, mp_type);
                else res = NULL;
            }
        }
    }
    if (res == NULL) nlr_raise(
        mp_obj_new_exception_msg_varg(
            &mp_type_SyntaxError, MP_ERROR_TEXT("Can't convert %s to %s!"), mp_obj_get_type_str(mp_obj), qstr_str(mp_type->name)));
    return res;
}

// object handling
// This section is enabled only when objects are supported 

#ifdef LV_OBJ_T

typedef LV_OBJ_T* (*lv_create)(LV_OBJ_T * par, const LV_OBJ_T * copy);

typedef struct mp_lv_obj_t {
    mp_obj_base_t base;
    LV_OBJ_T *lv_obj;
    LV_OBJ_T *callbacks;
} mp_lv_obj_t;

STATIC inline LV_OBJ_T *mp_to_lv(mp_obj_t *mp_obj)
{
    if (mp_obj == NULL || mp_obj == mp_const_none) return NULL;
    mp_lv_obj_t *mp_lv_obj = MP_OBJ_TO_PTR(get_native_obj(mp_obj));
    return mp_lv_obj->lv_obj;
}

STATIC inline LV_OBJ_T *mp_get_callbacks(mp_obj_t mp_obj)
{
    if (mp_obj == NULL || mp_obj == mp_const_none) return NULL;
    mp_lv_obj_t *mp_lv_obj = MP_OBJ_TO_PTR(get_native_obj(mp_obj));
    if (!mp_lv_obj->callbacks) mp_lv_obj->callbacks = mp_obj_new_dict(0);
    return mp_lv_obj->callbacks;
}

STATIC inline const mp_obj_type_t *get_BaseObj_type();

STATIC inline mp_obj_t *lv_to_mp(LV_OBJ_T *lv_obj)
{
    if (lv_obj == NULL) return mp_const_none;
    mp_lv_obj_t *self = (mp_lv_obj_t*)lv_obj->user_data;
    if (!self) 
    {
        self = m_new_obj(mp_lv_obj_t);
        *self = (mp_lv_obj_t){
            .base = {get_BaseObj_type()},
            .lv_obj = lv_obj,
            .callbacks = NULL,
        };
        lv_obj->user_data = self;
    }
    return MP_OBJ_FROM_PTR(self);
}

STATIC mp_obj_t make_new(
    lv_create create,
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    mp_arg_check_num(n_args, n_kw, 0, 2, false);
    mp_lv_obj_t *self = m_new_obj(mp_lv_obj_t);
    LV_OBJ_T *parent = n_args > 0? mp_to_lv(args[0]): NULL;
    LV_OBJ_T *copy = n_args > 1? mp_to_lv(args[1]): NULL;
    *self = (mp_lv_obj_t){
        .base = {type}, 
        .lv_obj = create(parent, copy),
        .callbacks = NULL,
    };
    if (!self->lv_obj) return mp_const_none;
    self->lv_obj->user_data = self;
    return MP_OBJ_FROM_PTR(self);
}

STATIC void* mp_to_ptr(mp_obj_t self_in);

STATIC mp_obj_t cast_obj(mp_obj_t type_obj, mp_obj_t obj)
{
    mp_lv_obj_t *self = m_new_obj(mp_lv_obj_t);
    *self = (mp_lv_obj_t){
        .base = {(const mp_obj_type_t*)type_obj},
        .lv_obj = mp_to_ptr(obj),
        .callbacks = NULL,
    };
    if (!self->lv_obj) return mp_const_none;
    return MP_OBJ_FROM_PTR(self);
}

STATIC MP_DEFINE_CONST_FUN_OBJ_2(cast_obj_obj, cast_obj);
STATIC MP_DEFINE_CONST_CLASSMETHOD_OBJ(cast_obj_class_method, MP_ROM_PTR(&cast_obj_obj));

STATIC mp_int_t mp_lv_obj_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags) {
    (void)flags;
    mp_lv_obj_t *self = MP_OBJ_TO_PTR(self_in);

    bufinfo->buf = &self->lv_obj;
    bufinfo->len = sizeof(self->lv_obj);
    bufinfo->typecode = BYTEARRAY_TYPECODE;
    return 0;
}

#endif

STATIC inline mp_obj_t convert_to_bool(bool b)
{
    return b? mp_const_true: mp_const_false;
}

STATIC inline mp_obj_t convert_to_str(const char *str)
{
    return str? mp_obj_new_str(str, strlen(str)): mp_const_none;
}

STATIC inline const char *convert_from_str(mp_obj_t str)
{
    return (str == NULL || str == mp_const_none)? NULL: mp_obj_str_get_str(str);
}

// struct handling

STATIC inline mp_lv_struct_t *mp_to_lv_struct(mp_obj_t mp_obj)
{
    if (mp_obj == NULL || mp_obj == mp_const_none) return NULL;
    if (!MP_OBJ_IS_OBJ(mp_obj)) nlr_raise(
            mp_obj_new_exception_msg(
                &mp_type_SyntaxError, MP_ERROR_TEXT("Struct argument is not an object!")));
    mp_lv_struct_t *mp_lv_struct = MP_OBJ_TO_PTR(get_native_obj(mp_obj));
    return mp_lv_struct;
}

STATIC inline size_t get_lv_struct_size(const mp_obj_type_t *type)
{
    mp_obj_t size_obj = mp_obj_dict_get(type->locals_dict, MP_OBJ_NEW_QSTR(MP_QSTR_SIZE));
    return (size_t)mp_obj_get_int(size_obj);
}

STATIC mp_obj_t make_new_lv_struct(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    if ((!MP_OBJ_IS_TYPE(type, &mp_type_type)) || type->make_new != &make_new_lv_struct)
        nlr_raise(
            mp_obj_new_exception_msg(
                &mp_type_SyntaxError, MP_ERROR_TEXT("Argument is not a struct type!")));
    size_t size = get_lv_struct_size(type);
    mp_arg_check_num(n_args, n_kw, 0, 1, false);
    mp_lv_struct_t *self = m_new_obj(mp_lv_struct_t);
    *self = (mp_lv_struct_t){
        .base = {type}, 
        .data = m_malloc(size)
    };
    mp_lv_struct_t *other = n_args > 0? mp_to_lv_struct(cast(args[0], type)): NULL;
    if (other) {
        memcpy(self->data, other->data, size);
    } else {
        memset(self->data, 0, size);
    }
    return MP_OBJ_FROM_PTR(self);
}

STATIC void *copy_buffer(const void *buffer, size_t size)
{
    void *new_buffer = m_malloc(size);
    memcpy(new_buffer, buffer, size);
    return new_buffer;
}

// Reference an existing lv struct (or part of it)

STATIC mp_obj_t lv_to_mp_struct(const mp_obj_type_t *type, void *lv_struct)
{
    if (lv_struct == NULL) return mp_const_none;
    mp_lv_struct_t *self = m_new_obj(mp_lv_struct_t);
    *self = (mp_lv_struct_t){
        .base = {type},
        .data = lv_struct
    };
    return MP_OBJ_FROM_PTR(self);
}

STATIC void call_parent_methods(mp_obj_t obj, qstr attr, mp_obj_t *dest)
{
    const mp_obj_type_t *type = mp_obj_get_type(obj);
    while (type->locals_dict != NULL) {
        // generic method lookup
        // this is a lookup in the object (ie not class or type)
        assert(type->locals_dict->base.type == &mp_type_dict); // MicroPython restriction, for now
        mp_map_t *locals_map = &type->locals_dict->map;
        mp_map_elem_t *elem = mp_map_lookup(locals_map, MP_OBJ_NEW_QSTR(attr), MP_MAP_LOOKUP);
        if (elem != NULL) {
            mp_convert_member_lookup(obj, type, elem->value, dest);
            break;
        }
        if (type->parent == NULL) {
            break;
        }
        // search parents
        type = type->parent;
    }
}

// Convert dict to struct

STATIC mp_obj_t dict_to_struct(mp_obj_t dict, const mp_obj_type_t *type)
{
    mp_obj_t mp_struct = make_new_lv_struct(type, 0, 0, NULL);
    mp_obj_t *native_dict = cast(dict, &mp_type_dict);
    mp_map_t *map = mp_obj_dict_get_map(native_dict);
    if (map == NULL) return mp_const_none;
    for (uint i = 0; i < map->alloc; i++) {
        mp_obj_t key = map->table[i].key;
        mp_obj_t value = map->table[i].value;
        if (key != MP_OBJ_NULL) {
            mp_obj_t dest[] = {MP_OBJ_SENTINEL, value};
            type->attr(mp_struct, mp_obj_str_get_qstr(key), dest);
            if (dest[0]) nlr_raise(
                mp_obj_new_exception_msg_varg(
                    &mp_type_SyntaxError, MP_ERROR_TEXT("Cannot set field %s on struct %s!"), qstr_str(mp_obj_str_get_qstr(key)), qstr_str(type->name)));
        }
    }
    return mp_struct;
}

// Convert mp object to ptr

STATIC void* mp_to_ptr(mp_obj_t self_in)
{
    mp_buffer_info_t buffer_info;
    if (self_in == mp_const_none)
        return NULL;

//    if (MP_OBJ_IS_INT(self_in))
//        return (void*)mp_obj_get_int(self_in);

    if (!mp_get_buffer(self_in, &buffer_info, MP_BUFFER_READ)) {
        // No buffer protocol - this is not a Struct or a Blob, it's some other mp object.
        // We only allow setting dict directly, since it's useful to setting user_data for passing data to C.
        // On other cases throw an exception, to avoid a crash later
        if (MP_OBJ_IS_TYPE(self_in, &mp_type_dict))
            return MP_OBJ_TO_PTR(self_in);
        else nlr_raise(
                mp_obj_new_exception_msg_varg(
                    &mp_type_SyntaxError, MP_ERROR_TEXT("Cannot convert '%s' to pointer!"), mp_obj_get_type_str(self_in)));
    }

    if (MP_OBJ_IS_STR_OR_BYTES(self_in) || 
        MP_OBJ_IS_TYPE(self_in, &mp_type_bytearray) ||
        MP_OBJ_IS_TYPE(self_in, &mp_type_memoryview))
            return buffer_info.buf;
    else
    {
        void *result;
        if (buffer_info.len != sizeof(result) || buffer_info.typecode != BYTEARRAY_TYPECODE){
            nlr_raise(
                mp_obj_new_exception_msg_varg(
                    &mp_type_SyntaxError, MP_ERROR_TEXT("Cannot convert %s to pointer! (buffer does not represent a pointer)"), mp_obj_get_type_str(self_in)));
        }
        memcpy(&result, buffer_info.buf, sizeof(result));
        return result;
    }
}

// Blob is a wrapper for void* 

STATIC void mp_blob_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "Blob");
}

STATIC mp_int_t mp_blob_get_buffer(mp_obj_t self_in, mp_buffer_info_t *bufinfo, mp_uint_t flags) {
    (void)flags;
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);

    bufinfo->buf = &self->data;
    bufinfo->len = sizeof(self->data);
    bufinfo->typecode = BYTEARRAY_TYPECODE;
    return 0;
}

STATIC const mp_obj_fun_builtin_var_t mp_lv_dereference_obj;

// Sometimes (but not always!) Blob represents a Micropython object.
// In such cases it's safe to cast the Blob back to the Micropython object
// cast argument is the underlying object type, and it's optional.

STATIC mp_obj_t mp_blob_cast(size_t argc, const mp_obj_t *argv)
{
    mp_obj_t self = argv[0];
    void *ptr = mp_to_ptr(self);
    if (argc == 1) return MP_OBJ_FROM_PTR(ptr);
    mp_obj_t type = argv[1];
    if (!MP_OBJ_IS_TYPE(type, &mp_type_type))
        nlr_raise(
            mp_obj_new_exception_msg(
                &mp_type_SyntaxError, MP_ERROR_TEXT("Cast argument must be a type!")));
    return cast(MP_OBJ_FROM_PTR(ptr), type);
}

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_blob_cast_obj, 1, 2, mp_blob_cast);

STATIC const mp_rom_map_elem_t mp_blob_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_blob_cast_obj) },
};

STATIC MP_DEFINE_CONST_DICT(mp_blob_locals_dict, mp_blob_locals_dict_table);

STATIC const mp_obj_type_t mp_blob_type = {
    { &mp_type_type },
    .name = MP_QSTR_Blob,
    .print = mp_blob_print,
    //.make_new = make_new_blob,
    .locals_dict = (mp_obj_dict_t*)&mp_blob_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC const mp_lv_struct_t mp_lv_null_obj = { {&mp_blob_type}, NULL };

STATIC inline mp_obj_t ptr_to_mp(void *data)
{
    return lv_to_mp_struct(&mp_blob_type, data);
}

// Cast pointer to struct

STATIC mp_obj_t mp_lv_cast(mp_obj_t type_obj, mp_obj_t ptr_obj)
{
    mp_lv_struct_t *self = m_new_obj(mp_lv_struct_t);
    *self = (mp_lv_struct_t){
        .base = {(const mp_obj_type_t*)type_obj}, 
        .data = mp_to_ptr(ptr_obj)
    };
    return MP_OBJ_FROM_PTR(self);
}

// Cast instance. Can be used in ISR when memory allocation is prohibited

STATIC inline mp_obj_t mp_lv_cast_instance(mp_obj_t self_in, mp_obj_t ptr_obj)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    self->data = mp_to_ptr(ptr_obj);
    return self_in;
}

STATIC MP_DEFINE_CONST_FUN_OBJ_2(mp_lv_cast_obj, mp_lv_cast);
STATIC MP_DEFINE_CONST_CLASSMETHOD_OBJ(mp_lv_cast_class_method, MP_ROM_PTR(&mp_lv_cast_obj));

STATIC MP_DEFINE_CONST_FUN_OBJ_2(mp_lv_cast_instance_obj, mp_lv_cast_instance);

// Dereference a struct/blob. This allows access to the raw data the struct holds

STATIC mp_obj_t mp_lv_dereference(size_t argc, const mp_obj_t *argv)
{
    mp_obj_t self_in = argv[0];
    mp_obj_t size_in = argc > 1? argv[1]: mp_const_none;
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    size_t size = 0;
    if (size_in == mp_const_none){
        const mp_obj_type_t *type = self->base.type;
        size = get_lv_struct_size(type);
    } else {
        size = (size_t)mp_obj_get_int(size_in);
    }
    mp_obj_array_t *view = MP_OBJ_TO_PTR(mp_obj_new_memoryview(BYTEARRAY_TYPECODE,
        size, self->data));
    view->typecode |= 0x80; // used to indicate writable buffer
    return MP_OBJ_FROM_PTR(view);
}

STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mp_lv_dereference_obj, 1, 2, mp_lv_dereference);

// Callback function handling
// Callback is either a callable object or a pointer. If it's a callable object, set user_data to the callback.
// Multiple callbacks are kept per object/struct using a dict that associate callback name with callback object
// In case of an lv_obj_t, user_data is mp_lv_obj_t which contains a member "callbacks" for that dict.
// In case of a struct, user_data is a pointer to that dict directly

STATIC mp_obj_t get_callback_dict_from_user_data(void *user_data)
{
    if (user_data){
        mp_obj_t obj = MP_OBJ_FROM_PTR(user_data);
#ifdef LV_OBJ_T
        return 
            MP_OBJ_IS_TYPE(obj, &mp_type_dict)? obj: // Handle the case of dict for a struct
            mp_get_callbacks(obj); // Handle the case of mp_lv_obj_t for an lv_obj_t
#else
        return obj;
#endif
    }
    return NULL;
}

STATIC void *mp_lv_callback(mp_obj_t mp_callback, void *lv_callback, qstr callback_name, void **user_data_ptr)
{
    if (lv_callback && mp_obj_is_callable(mp_callback)){
        if (user_data_ptr){
            // user_data is either a dict of callbacks in case of struct, or a pointer to mp_lv_obj_t in case of lv_obj_t
            if (! (*user_data_ptr) ) *user_data_ptr = MP_OBJ_TO_PTR(mp_obj_new_dict(0)); // if it's NULL - it's a dict for a struct
            mp_obj_t callbacks = get_callback_dict_from_user_data(*user_data_ptr);
            mp_obj_dict_store(callbacks, MP_OBJ_NEW_QSTR(callback_name), mp_callback);
        }
        return lv_callback;
    } else {
        return mp_to_ptr(mp_callback);
    }
}

// Function pointers wrapper

STATIC mp_obj_t mp_lv_funcptr(const mp_lv_obj_fun_builtin_var_t *mp_fun, void *lv_fun, void *lv_callback, qstr func_name, void *user_data)
{
    if (lv_fun == NULL)
        return mp_const_none;
    if (lv_fun == lv_callback) {
        mp_obj_t callbacks = get_callback_dict_from_user_data(user_data);
        if (callbacks)
            return mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(func_name));
    }
    mp_lv_obj_fun_builtin_var_t *funcptr = m_new_obj(mp_lv_obj_fun_builtin_var_t);
    *funcptr = *mp_fun;
    funcptr->lv_fun = lv_fun;
    return MP_OBJ_FROM_PTR(funcptr);
}

// Missing implementation for 64bit integer conversion

STATIC unsigned long long mp_obj_get_ull(mp_obj_t obj)
{
    if (mp_obj_is_small_int(obj))
        return MP_OBJ_SMALL_INT_VALUE(obj);

    unsigned long long val = 0;
    bool big_endian = !(__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__);
    mp_obj_int_to_bytes_impl(obj, big_endian, sizeof(val), (byte*)&val);
    return val;
}



/*
 * LVGL string constants
 */

MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_AUDIO, LV_SYMBOL_AUDIO);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_VIDEO, LV_SYMBOL_VIDEO);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_LIST, LV_SYMBOL_LIST);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_OK, LV_SYMBOL_OK);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_CLOSE, LV_SYMBOL_CLOSE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_POWER, LV_SYMBOL_POWER);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_SETTINGS, LV_SYMBOL_SETTINGS);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_HOME, LV_SYMBOL_HOME);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_DOWNLOAD, LV_SYMBOL_DOWNLOAD);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_DRIVE, LV_SYMBOL_DRIVE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_REFRESH, LV_SYMBOL_REFRESH);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_MUTE, LV_SYMBOL_MUTE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_VOLUME_MID, LV_SYMBOL_VOLUME_MID);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_VOLUME_MAX, LV_SYMBOL_VOLUME_MAX);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_IMAGE, LV_SYMBOL_IMAGE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_EDIT, LV_SYMBOL_EDIT);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_PREV, LV_SYMBOL_PREV);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_PLAY, LV_SYMBOL_PLAY);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_PAUSE, LV_SYMBOL_PAUSE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_STOP, LV_SYMBOL_STOP);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_NEXT, LV_SYMBOL_NEXT);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_EJECT, LV_SYMBOL_EJECT);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_LEFT, LV_SYMBOL_LEFT);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_RIGHT, LV_SYMBOL_RIGHT);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_PLUS, LV_SYMBOL_PLUS);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_MINUS, LV_SYMBOL_MINUS);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_EYE_OPEN, LV_SYMBOL_EYE_OPEN);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_EYE_CLOSE, LV_SYMBOL_EYE_CLOSE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_WARNING, LV_SYMBOL_WARNING);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_SHUFFLE, LV_SYMBOL_SHUFFLE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_UP, LV_SYMBOL_UP);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_DOWN, LV_SYMBOL_DOWN);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_LOOP, LV_SYMBOL_LOOP);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_DIRECTORY, LV_SYMBOL_DIRECTORY);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_UPLOAD, LV_SYMBOL_UPLOAD);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_CALL, LV_SYMBOL_CALL);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_CUT, LV_SYMBOL_CUT);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_COPY, LV_SYMBOL_COPY);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_SAVE, LV_SYMBOL_SAVE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_CHARGE, LV_SYMBOL_CHARGE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_PASTE, LV_SYMBOL_PASTE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BELL, LV_SYMBOL_BELL);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_KEYBOARD, LV_SYMBOL_KEYBOARD);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_GPS, LV_SYMBOL_GPS);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_FILE, LV_SYMBOL_FILE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_WIFI, LV_SYMBOL_WIFI);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BATTERY_FULL, LV_SYMBOL_BATTERY_FULL);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BATTERY_3, LV_SYMBOL_BATTERY_3);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BATTERY_2, LV_SYMBOL_BATTERY_2);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BATTERY_1, LV_SYMBOL_BATTERY_1);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BATTERY_EMPTY, LV_SYMBOL_BATTERY_EMPTY);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_USB, LV_SYMBOL_USB);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BLUETOOTH, LV_SYMBOL_BLUETOOTH);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_TRASH, LV_SYMBOL_TRASH);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_BACKSPACE, LV_SYMBOL_BACKSPACE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_SD_CARD, LV_SYMBOL_SD_CARD);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_NEW_LINE, LV_SYMBOL_NEW_LINE);
MP_DEFINE_STR_OBJ(mp_LV_SYMBOL_DUMMY, LV_SYMBOL_DUMMY);

/*
 * Helper Structs
 */
        

typedef union {
    void*           ptr_val;
    const char*     str_val;
    int             int_val;
    unsigned int    uint_val;
    short           short_val[sizeof(void*) / sizeof(short)];
    unsigned short  ushort_val[sizeof(void*) / sizeof(unsigned short)];
    char            char_val[sizeof(void*) / sizeof(char)];
    unsigned char   uchar_val[sizeof(void*) / sizeof(unsigned char)];
} C_Pointer;


/*
 * Array convertors for short [(sizeof(void *)) / (sizeof(short))]
 */

STATIC short *mp_arr_to_short_____sizeof__void_ptr______div____sizeof__short______(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    short *lv_arr = (short*)m_malloc(len * sizeof(short));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (short)mp_obj_get_int(item);
    }
    return (short *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_short_____sizeof__void_ptr______div____sizeof__short______(short *arr)
{
    mp_obj_t obj_arr[(sizeof(void *)) / (sizeof(short))];
    for (size_t i=0; i<(sizeof(void *)) / (sizeof(short)); i++){
        obj_arr[i] = mp_obj_new_int(arr[i]);
    }
    return mp_obj_new_list((sizeof(void *)) / (sizeof(short)), obj_arr); // TODO: return custom iterable object!
}
    

/*
 * Array convertors for unsigned short [(sizeof(void *)) / (sizeof(unsigned short))]
 */

STATIC unsigned short *mp_arr_to_unsigned_short_____sizeof__void_ptr______div____sizeof__unsigned_short______(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    unsigned short *lv_arr = (unsigned short*)m_malloc(len * sizeof(unsigned short));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (unsigned short)mp_obj_get_int(item);
    }
    return (unsigned short *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_unsigned_short_____sizeof__void_ptr______div____sizeof__unsigned_short______(unsigned short *arr)
{
    mp_obj_t obj_arr[(sizeof(void *)) / (sizeof(unsigned short))];
    for (size_t i=0; i<(sizeof(void *)) / (sizeof(unsigned short)); i++){
        obj_arr[i] = mp_obj_new_int_from_uint(arr[i]);
    }
    return mp_obj_new_list((sizeof(void *)) / (sizeof(unsigned short)), obj_arr); // TODO: return custom iterable object!
}
    

/*
 * Array convertors for char [(sizeof(void *)) / (sizeof(char))]
 */

STATIC char *mp_arr_to_char_____sizeof__void_ptr______div____sizeof__char______(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    char *lv_arr = (char*)m_malloc(len * sizeof(char));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (char)mp_obj_get_int(item);
    }
    return (char *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_char_____sizeof__void_ptr______div____sizeof__char______(char *arr)
{
    mp_obj_t obj_arr[(sizeof(void *)) / (sizeof(char))];
    for (size_t i=0; i<(sizeof(void *)) / (sizeof(char)); i++){
        obj_arr[i] = mp_obj_new_int(arr[i]);
    }
    return mp_obj_new_list((sizeof(void *)) / (sizeof(char)), obj_arr); // TODO: return custom iterable object!
}
    

/*
 * Array convertors for unsigned char [(sizeof(void *)) / (sizeof(unsigned char))]
 */

STATIC unsigned char *mp_arr_to_unsigned_char_____sizeof__void_ptr______div____sizeof__unsigned_char______(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    unsigned char *lv_arr = (unsigned char*)m_malloc(len * sizeof(unsigned char));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (unsigned char)mp_obj_get_int(item);
    }
    return (unsigned char *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_unsigned_char_____sizeof__void_ptr______div____sizeof__unsigned_char______(unsigned char *arr)
{
    mp_obj_t obj_arr[(sizeof(void *)) / (sizeof(unsigned char))];
    for (size_t i=0; i<(sizeof(void *)) / (sizeof(unsigned char)); i++){
        obj_arr[i] = mp_obj_new_int_from_uint(arr[i]);
    }
    return mp_obj_new_list((sizeof(void *)) / (sizeof(unsigned char)), obj_arr); // TODO: return custom iterable object!
}
    

/*
 * Struct C_Pointer
 */

STATIC inline const mp_obj_type_t *get_mp_C_Pointer_type();

STATIC inline C_Pointer* mp_write_ptr_C_Pointer(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_C_Pointer_type()));
    return (C_Pointer*)self->data;
}

#define mp_write_C_Pointer(struct_obj) *mp_write_ptr_C_Pointer(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_C_Pointer(C_Pointer *field)
{
    return lv_to_mp_struct(get_mp_C_Pointer_type(), (void*)field);
}

#define mp_read_C_Pointer(field) mp_read_ptr_C_Pointer(copy_buffer(&field, sizeof(C_Pointer)))
#define mp_read_byref_C_Pointer(field) mp_read_ptr_C_Pointer(&field)

STATIC void mp_C_Pointer_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    C_Pointer *data = (C_Pointer*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_ptr_val: dest[0] = ptr_to_mp((void*)data->ptr_val); break; // converting from void *;
            case MP_QSTR_str_val: dest[0] = convert_to_str((void*)data->str_val); break; // converting from char *;
            case MP_QSTR_int_val: dest[0] = mp_obj_new_int(data->int_val); break; // converting from int;
            case MP_QSTR_uint_val: dest[0] = mp_obj_new_int_from_uint(data->uint_val); break; // converting from unsigned int;
            case MP_QSTR_short_val: dest[0] = mp_arr_from_short_____sizeof__void_ptr______div____sizeof__short______(data->short_val); break; // converting from short [(sizeof(void *)) / (sizeof(short))];
            case MP_QSTR_ushort_val: dest[0] = mp_arr_from_unsigned_short_____sizeof__void_ptr______div____sizeof__unsigned_short______(data->ushort_val); break; // converting from unsigned short [(sizeof(void *)) / (sizeof(unsigned short))];
            case MP_QSTR_char_val: dest[0] = mp_arr_from_char_____sizeof__void_ptr______div____sizeof__char______(data->char_val); break; // converting from char [(sizeof(void *)) / (sizeof(char))];
            case MP_QSTR_uchar_val: dest[0] = mp_arr_from_unsigned_char_____sizeof__void_ptr______div____sizeof__unsigned_char______(data->uchar_val); break; // converting from unsigned char [(sizeof(void *)) / (sizeof(unsigned char))];
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_ptr_val: data->ptr_val = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_str_val: data->str_val = (void*)(char*)convert_from_str(dest[1]); break; // converting to char *;
                case MP_QSTR_int_val: data->int_val = (int)mp_obj_get_int(dest[1]); break; // converting to int;
                case MP_QSTR_uint_val: data->uint_val = (unsigned int)mp_obj_get_int(dest[1]); break; // converting to unsigned int;
                case MP_QSTR_short_val: memcpy((void*)&data->short_val, mp_arr_to_short_____sizeof__void_ptr______div____sizeof__short______(dest[1]), sizeof(short)*(sizeof(void *)) / (sizeof(short))); break; // converting to short [(sizeof(void *)) / (sizeof(short))];
                case MP_QSTR_ushort_val: memcpy((void*)&data->ushort_val, mp_arr_to_unsigned_short_____sizeof__void_ptr______div____sizeof__unsigned_short______(dest[1]), sizeof(unsigned short)*(sizeof(void *)) / (sizeof(unsigned short))); break; // converting to unsigned short [(sizeof(void *)) / (sizeof(unsigned short))];
                case MP_QSTR_char_val: memcpy((void*)&data->char_val, mp_arr_to_char_____sizeof__void_ptr______div____sizeof__char______(dest[1]), sizeof(char)*(sizeof(void *)) / (sizeof(char))); break; // converting to char [(sizeof(void *)) / (sizeof(char))];
                case MP_QSTR_uchar_val: memcpy((void*)&data->uchar_val, mp_arr_to_unsigned_char_____sizeof__void_ptr______div____sizeof__unsigned_char______(dest[1]), sizeof(unsigned char)*(sizeof(void *)) / (sizeof(unsigned char))); break; // converting to unsigned char [(sizeof(void *)) / (sizeof(unsigned char))];
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_C_Pointer_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct C_Pointer");
}

STATIC const mp_obj_dict_t mp_C_Pointer_locals_dict;

STATIC const mp_obj_type_t mp_C_Pointer_type = {
    { &mp_type_type },
    .name = MP_QSTR_C_Pointer,
    .print = mp_C_Pointer_print,
    .make_new = make_new_lv_struct,
    .attr = mp_C_Pointer_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_C_Pointer_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_C_Pointer_type()
{
    return &mp_C_Pointer_type;
}
    

/*
 * lvgl ENUM_LV_LOG_LEVEL object definitions
 */
    

STATIC const mp_rom_map_elem_t ENUM_LV_LOG_LEVEL_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_TRACE), MP_ROM_PTR(MP_ROM_INT(ENUM_LV_LOG_LEVEL_TRACE)) },
    { MP_ROM_QSTR(MP_QSTR_INFO), MP_ROM_PTR(MP_ROM_INT(ENUM_LV_LOG_LEVEL_INFO)) },
    { MP_ROM_QSTR(MP_QSTR_WARN), MP_ROM_PTR(MP_ROM_INT(ENUM_LV_LOG_LEVEL_WARN)) },
    { MP_ROM_QSTR(MP_QSTR_ERROR), MP_ROM_PTR(MP_ROM_INT(ENUM_LV_LOG_LEVEL_ERROR)) },
    { MP_ROM_QSTR(MP_QSTR_USER), MP_ROM_PTR(MP_ROM_INT(ENUM_LV_LOG_LEVEL_USER)) },
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(ENUM_LV_LOG_LEVEL_NONE)) }
};

STATIC MP_DEFINE_CONST_DICT(ENUM_LV_LOG_LEVEL_locals_dict, ENUM_LV_LOG_LEVEL_locals_dict_table);

STATIC void ENUM_LV_LOG_LEVEL_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl ENUM_LV_LOG_LEVEL");
}



STATIC const mp_obj_type_t mp_ENUM_LV_LOG_LEVEL_type = {
    { &mp_type_type },
    .name = MP_QSTR_ENUM_LV_LOG_LEVEL,
    .print = ENUM_LV_LOG_LEVEL_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&ENUM_LV_LOG_LEVEL_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_RES object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_RES_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_INV), MP_ROM_PTR(MP_ROM_INT(LV_RES_INV)) },
    { MP_ROM_QSTR(MP_QSTR_OK), MP_ROM_PTR(MP_ROM_INT(LV_RES_OK)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_RES_locals_dict, LV_RES_locals_dict_table);

STATIC void LV_RES_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_RES");
}



STATIC const mp_obj_type_t mp_LV_RES_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_RES,
    .print = LV_RES_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_RES_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_TASK_PRIO object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_TASK_PRIO_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_OFF), MP_ROM_PTR(MP_ROM_INT(LV_TASK_PRIO_OFF)) },
    { MP_ROM_QSTR(MP_QSTR_LOWEST), MP_ROM_PTR(MP_ROM_INT(LV_TASK_PRIO_LOWEST)) },
    { MP_ROM_QSTR(MP_QSTR_LOW), MP_ROM_PTR(MP_ROM_INT(LV_TASK_PRIO_LOW)) },
    { MP_ROM_QSTR(MP_QSTR_MID), MP_ROM_PTR(MP_ROM_INT(LV_TASK_PRIO_MID)) },
    { MP_ROM_QSTR(MP_QSTR_HIGH), MP_ROM_PTR(MP_ROM_INT(LV_TASK_PRIO_HIGH)) },
    { MP_ROM_QSTR(MP_QSTR_HIGHEST), MP_ROM_PTR(MP_ROM_INT(LV_TASK_PRIO_HIGHEST)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_TASK_PRIO_locals_dict, LV_TASK_PRIO_locals_dict_table);

STATIC void LV_TASK_PRIO_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_TASK_PRIO");
}



STATIC const mp_obj_type_t mp_LV_TASK_PRIO_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_TASK_PRIO,
    .print = LV_TASK_PRIO_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_TASK_PRIO_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_OPA object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_OPA_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_TRANSP), MP_ROM_PTR(MP_ROM_INT(LV_OPA_TRANSP)) },
    { MP_ROM_QSTR(MP_QSTR__0), MP_ROM_PTR(MP_ROM_INT(LV_OPA_0)) },
    { MP_ROM_QSTR(MP_QSTR__10), MP_ROM_PTR(MP_ROM_INT(LV_OPA_10)) },
    { MP_ROM_QSTR(MP_QSTR__20), MP_ROM_PTR(MP_ROM_INT(LV_OPA_20)) },
    { MP_ROM_QSTR(MP_QSTR__30), MP_ROM_PTR(MP_ROM_INT(LV_OPA_30)) },
    { MP_ROM_QSTR(MP_QSTR__40), MP_ROM_PTR(MP_ROM_INT(LV_OPA_40)) },
    { MP_ROM_QSTR(MP_QSTR__50), MP_ROM_PTR(MP_ROM_INT(LV_OPA_50)) },
    { MP_ROM_QSTR(MP_QSTR__60), MP_ROM_PTR(MP_ROM_INT(LV_OPA_60)) },
    { MP_ROM_QSTR(MP_QSTR__70), MP_ROM_PTR(MP_ROM_INT(LV_OPA_70)) },
    { MP_ROM_QSTR(MP_QSTR__80), MP_ROM_PTR(MP_ROM_INT(LV_OPA_80)) },
    { MP_ROM_QSTR(MP_QSTR__90), MP_ROM_PTR(MP_ROM_INT(LV_OPA_90)) },
    { MP_ROM_QSTR(MP_QSTR__100), MP_ROM_PTR(MP_ROM_INT(LV_OPA_100)) },
    { MP_ROM_QSTR(MP_QSTR_COVER), MP_ROM_PTR(MP_ROM_INT(LV_OPA_COVER)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_OPA_locals_dict, LV_OPA_locals_dict_table);

STATIC void LV_OPA_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_OPA");
}



STATIC const mp_obj_type_t mp_LV_OPA_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_OPA,
    .print = LV_OPA_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_OPA_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl ENUM_LV_COORD object definitions
 */
    

STATIC const mp_rom_map_elem_t ENUM_LV_COORD_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_MAX), MP_ROM_PTR(MP_ROM_INT(ENUM_LV_COORD_MAX)) },
    { MP_ROM_QSTR(MP_QSTR_MIN), MP_ROM_PTR(MP_ROM_INT(ENUM_LV_COORD_MIN)) }
};

STATIC MP_DEFINE_CONST_DICT(ENUM_LV_COORD_locals_dict, ENUM_LV_COORD_locals_dict_table);

STATIC void ENUM_LV_COORD_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl ENUM_LV_COORD");
}



STATIC const mp_obj_type_t mp_ENUM_LV_COORD_type = {
    { &mp_type_type },
    .name = MP_QSTR_ENUM_LV_COORD,
    .print = ENUM_LV_COORD_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&ENUM_LV_COORD_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_ALIGN object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_ALIGN_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_CENTER), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_CENTER)) },
    { MP_ROM_QSTR(MP_QSTR_IN_TOP_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_IN_TOP_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_IN_TOP_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_IN_TOP_MID)) },
    { MP_ROM_QSTR(MP_QSTR_IN_TOP_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_IN_TOP_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_IN_BOTTOM_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_IN_BOTTOM_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_IN_BOTTOM_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_IN_BOTTOM_MID)) },
    { MP_ROM_QSTR(MP_QSTR_IN_BOTTOM_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_IN_BOTTOM_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_IN_LEFT_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_IN_LEFT_MID)) },
    { MP_ROM_QSTR(MP_QSTR_IN_RIGHT_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_IN_RIGHT_MID)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_TOP_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_TOP_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_TOP_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_TOP_MID)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_TOP_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_TOP_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_BOTTOM_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_BOTTOM_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_BOTTOM_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_BOTTOM_MID)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_BOTTOM_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_BOTTOM_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_LEFT_TOP), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_LEFT_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_LEFT_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_LEFT_MID)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_LEFT_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_LEFT_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_RIGHT_TOP), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_RIGHT_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_RIGHT_MID), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_RIGHT_MID)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_RIGHT_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_ALIGN_OUT_RIGHT_BOTTOM)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_ALIGN_locals_dict, LV_ALIGN_locals_dict_table);

STATIC void LV_ALIGN_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_ALIGN");
}



STATIC const mp_obj_type_t mp_LV_ALIGN_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_ALIGN,
    .print = LV_ALIGN_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_ALIGN_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_INDEV_TYPE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_INDEV_TYPE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_TYPE_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_POINTER), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_TYPE_POINTER)) },
    { MP_ROM_QSTR(MP_QSTR_KEYPAD), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_TYPE_KEYPAD)) },
    { MP_ROM_QSTR(MP_QSTR_BUTTON), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_TYPE_BUTTON)) },
    { MP_ROM_QSTR(MP_QSTR_ENCODER), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_TYPE_ENCODER)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_INDEV_TYPE_locals_dict, LV_INDEV_TYPE_locals_dict_table);

STATIC void LV_INDEV_TYPE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_INDEV_TYPE");
}



STATIC const mp_obj_type_t mp_LV_INDEV_TYPE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_INDEV_TYPE,
    .print = LV_INDEV_TYPE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_INDEV_TYPE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_INDEV_STATE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_INDEV_STATE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_REL), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_STATE_REL)) },
    { MP_ROM_QSTR(MP_QSTR_PR), MP_ROM_PTR(MP_ROM_INT(LV_INDEV_STATE_PR)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_INDEV_STATE_locals_dict, LV_INDEV_STATE_locals_dict_table);

STATIC void LV_INDEV_STATE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_INDEV_STATE");
}



STATIC const mp_obj_type_t mp_LV_INDEV_STATE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_INDEV_STATE,
    .print = LV_INDEV_STATE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_INDEV_STATE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_DRAG_DIR object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DRAG_DIR_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_HOR), MP_ROM_PTR(MP_ROM_INT(LV_DRAG_DIR_HOR)) },
    { MP_ROM_QSTR(MP_QSTR_VER), MP_ROM_PTR(MP_ROM_INT(LV_DRAG_DIR_VER)) },
    { MP_ROM_QSTR(MP_QSTR_BOTH), MP_ROM_PTR(MP_ROM_INT(LV_DRAG_DIR_BOTH)) },
    { MP_ROM_QSTR(MP_QSTR_ONE), MP_ROM_PTR(MP_ROM_INT(LV_DRAG_DIR_ONE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DRAG_DIR_locals_dict, LV_DRAG_DIR_locals_dict_table);

STATIC void LV_DRAG_DIR_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DRAG_DIR");
}



STATIC const mp_obj_type_t mp_LV_DRAG_DIR_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_DRAG_DIR,
    .print = LV_DRAG_DIR_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_DRAG_DIR_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_GESTURE_DIR object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_GESTURE_DIR_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_TOP), MP_ROM_PTR(MP_ROM_INT(LV_GESTURE_DIR_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_GESTURE_DIR_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_GESTURE_DIR_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_GESTURE_DIR_RIGHT)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_GESTURE_DIR_locals_dict, LV_GESTURE_DIR_locals_dict_table);

STATIC void LV_GESTURE_DIR_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_GESTURE_DIR");
}



STATIC const mp_obj_type_t mp_LV_GESTURE_DIR_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_GESTURE_DIR,
    .print = LV_GESTURE_DIR_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_GESTURE_DIR_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_FONT_SUBPX object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_FONT_SUBPX_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_FONT_SUBPX_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_HOR), MP_ROM_PTR(MP_ROM_INT(LV_FONT_SUBPX_HOR)) },
    { MP_ROM_QSTR(MP_QSTR_VER), MP_ROM_PTR(MP_ROM_INT(LV_FONT_SUBPX_VER)) },
    { MP_ROM_QSTR(MP_QSTR_BOTH), MP_ROM_PTR(MP_ROM_INT(LV_FONT_SUBPX_BOTH)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_FONT_SUBPX_locals_dict, LV_FONT_SUBPX_locals_dict_table);

STATIC void LV_FONT_SUBPX_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_FONT_SUBPX");
}



STATIC const mp_obj_type_t mp_LV_FONT_SUBPX_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_FONT_SUBPX,
    .print = LV_FONT_SUBPX_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_FONT_SUBPX_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_ANIM object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_ANIM_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_OFF), MP_ROM_PTR(MP_ROM_INT(LV_ANIM_OFF)) },
    { MP_ROM_QSTR(MP_QSTR_ON), MP_ROM_PTR(MP_ROM_INT(LV_ANIM_ON)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_ANIM_locals_dict, LV_ANIM_locals_dict_table);

STATIC void LV_ANIM_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_ANIM");
}



STATIC const mp_obj_type_t mp_LV_ANIM_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_ANIM,
    .print = LV_ANIM_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_ANIM_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_DRAW_MASK_RES object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DRAW_MASK_RES_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_TRANSP), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_RES_TRANSP)) },
    { MP_ROM_QSTR(MP_QSTR_FULL_COVER), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_RES_FULL_COVER)) },
    { MP_ROM_QSTR(MP_QSTR_CHANGED), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_RES_CHANGED)) },
    { MP_ROM_QSTR(MP_QSTR_UNKNOWN), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_RES_UNKNOWN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DRAW_MASK_RES_locals_dict, LV_DRAW_MASK_RES_locals_dict_table);

STATIC void LV_DRAW_MASK_RES_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DRAW_MASK_RES");
}



STATIC const mp_obj_type_t mp_LV_DRAW_MASK_RES_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_DRAW_MASK_RES,
    .print = LV_DRAW_MASK_RES_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_DRAW_MASK_RES_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_DRAW_MASK_TYPE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DRAW_MASK_TYPE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_LINE), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_TYPE_LINE)) },
    { MP_ROM_QSTR(MP_QSTR_ANGLE), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_TYPE_ANGLE)) },
    { MP_ROM_QSTR(MP_QSTR_RADIUS), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_TYPE_RADIUS)) },
    { MP_ROM_QSTR(MP_QSTR_FADE), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_TYPE_FADE)) },
    { MP_ROM_QSTR(MP_QSTR_MAP), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_TYPE_MAP)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DRAW_MASK_TYPE_locals_dict, LV_DRAW_MASK_TYPE_locals_dict_table);

STATIC void LV_DRAW_MASK_TYPE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DRAW_MASK_TYPE");
}



STATIC const mp_obj_type_t mp_LV_DRAW_MASK_TYPE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_DRAW_MASK_TYPE,
    .print = LV_DRAW_MASK_TYPE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_DRAW_MASK_TYPE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_DRAW_MASK_LINE_SIDE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DRAW_MASK_LINE_SIDE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_LINE_SIDE_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_LINE_SIDE_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_TOP), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_LINE_SIDE_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_DRAW_MASK_LINE_SIDE_BOTTOM)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DRAW_MASK_LINE_SIDE_locals_dict, LV_DRAW_MASK_LINE_SIDE_locals_dict_table);

STATIC void LV_DRAW_MASK_LINE_SIDE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DRAW_MASK_LINE_SIDE");
}



STATIC const mp_obj_type_t mp_LV_DRAW_MASK_LINE_SIDE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_DRAW_MASK_LINE_SIDE,
    .print = LV_DRAW_MASK_LINE_SIDE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_DRAW_MASK_LINE_SIDE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_BLEND_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_BLEND_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NORMAL), MP_ROM_PTR(MP_ROM_INT(LV_BLEND_MODE_NORMAL)) },
    { MP_ROM_QSTR(MP_QSTR_ADDITIVE), MP_ROM_PTR(MP_ROM_INT(LV_BLEND_MODE_ADDITIVE)) },
    { MP_ROM_QSTR(MP_QSTR_SUBTRACTIVE), MP_ROM_PTR(MP_ROM_INT(LV_BLEND_MODE_SUBTRACTIVE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_BLEND_MODE_locals_dict, LV_BLEND_MODE_locals_dict_table);

STATIC void LV_BLEND_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_BLEND_MODE");
}



STATIC const mp_obj_type_t mp_LV_BLEND_MODE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_BLEND_MODE,
    .print = LV_BLEND_MODE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_BLEND_MODE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl ENUM_LV_RADIUS object definitions
 */
    

STATIC const mp_rom_map_elem_t ENUM_LV_RADIUS_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_CIRCLE), MP_ROM_PTR(MP_ROM_INT(ENUM_LV_RADIUS_CIRCLE)) }
};

STATIC MP_DEFINE_CONST_DICT(ENUM_LV_RADIUS_locals_dict, ENUM_LV_RADIUS_locals_dict_table);

STATIC void ENUM_LV_RADIUS_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl ENUM_LV_RADIUS");
}



STATIC const mp_obj_type_t mp_ENUM_LV_RADIUS_type = {
    { &mp_type_type },
    .name = MP_QSTR_ENUM_LV_RADIUS,
    .print = ENUM_LV_RADIUS_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&ENUM_LV_RADIUS_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_BORDER_SIDE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_BORDER_SIDE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_BORDER_SIDE_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_BORDER_SIDE_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_TOP), MP_ROM_PTR(MP_ROM_INT(LV_BORDER_SIDE_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_BORDER_SIDE_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_BORDER_SIDE_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_FULL), MP_ROM_PTR(MP_ROM_INT(LV_BORDER_SIDE_FULL)) },
    { MP_ROM_QSTR(MP_QSTR_INTERNAL), MP_ROM_PTR(MP_ROM_INT(LV_BORDER_SIDE_INTERNAL)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_BORDER_SIDE_locals_dict, LV_BORDER_SIDE_locals_dict_table);

STATIC void LV_BORDER_SIDE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_BORDER_SIDE");
}



STATIC const mp_obj_type_t mp_LV_BORDER_SIDE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_BORDER_SIDE,
    .print = LV_BORDER_SIDE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_BORDER_SIDE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_GRAD_DIR object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_GRAD_DIR_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_GRAD_DIR_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_VER), MP_ROM_PTR(MP_ROM_INT(LV_GRAD_DIR_VER)) },
    { MP_ROM_QSTR(MP_QSTR_HOR), MP_ROM_PTR(MP_ROM_INT(LV_GRAD_DIR_HOR)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_GRAD_DIR_locals_dict, LV_GRAD_DIR_locals_dict_table);

STATIC void LV_GRAD_DIR_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_GRAD_DIR");
}



STATIC const mp_obj_type_t mp_LV_GRAD_DIR_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_GRAD_DIR,
    .print = LV_GRAD_DIR_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_GRAD_DIR_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_TEXT_DECOR object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_TEXT_DECOR_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_DECOR_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_UNDERLINE), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_DECOR_UNDERLINE)) },
    { MP_ROM_QSTR(MP_QSTR_STRIKETHROUGH), MP_ROM_PTR(MP_ROM_INT(LV_TEXT_DECOR_STRIKETHROUGH)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_TEXT_DECOR_locals_dict, LV_TEXT_DECOR_locals_dict_table);

STATIC void LV_TEXT_DECOR_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_TEXT_DECOR");
}



STATIC const mp_obj_type_t mp_LV_TEXT_DECOR_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_TEXT_DECOR,
    .print = LV_TEXT_DECOR_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_TEXT_DECOR_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_STYLE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_STYLE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_RADIUS), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_RADIUS)) },
    { MP_ROM_QSTR(MP_QSTR_CLIP_CORNER), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_CLIP_CORNER)) },
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SIZE)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSFORM_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSFORM_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSFORM_HEIGHT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSFORM_HEIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSFORM_ANGLE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSFORM_ANGLE)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSFORM_ZOOM), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSFORM_ZOOM)) },
    { MP_ROM_QSTR(MP_QSTR_OPA_SCALE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_OPA_SCALE)) },
    { MP_ROM_QSTR(MP_QSTR_PAD_TOP), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PAD_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_PAD_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PAD_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_PAD_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PAD_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_PAD_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PAD_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_PAD_INNER), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PAD_INNER)) },
    { MP_ROM_QSTR(MP_QSTR_MARGIN_TOP), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_MARGIN_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_MARGIN_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_MARGIN_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_MARGIN_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_MARGIN_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_MARGIN_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_MARGIN_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_BG_BLEND_MODE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_BLEND_MODE)) },
    { MP_ROM_QSTR(MP_QSTR_BG_MAIN_STOP), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_MAIN_STOP)) },
    { MP_ROM_QSTR(MP_QSTR_BG_GRAD_STOP), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_GRAD_STOP)) },
    { MP_ROM_QSTR(MP_QSTR_BG_GRAD_DIR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_GRAD_DIR)) },
    { MP_ROM_QSTR(MP_QSTR_BG_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_BG_GRAD_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_GRAD_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_BG_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BG_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_BORDER_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BORDER_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_BORDER_SIDE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BORDER_SIDE)) },
    { MP_ROM_QSTR(MP_QSTR_BORDER_BLEND_MODE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BORDER_BLEND_MODE)) },
    { MP_ROM_QSTR(MP_QSTR_BORDER_POST), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BORDER_POST)) },
    { MP_ROM_QSTR(MP_QSTR_BORDER_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BORDER_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_BORDER_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_BORDER_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_OUTLINE_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_OUTLINE_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_OUTLINE_PAD), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_OUTLINE_PAD)) },
    { MP_ROM_QSTR(MP_QSTR_OUTLINE_BLEND_MODE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_OUTLINE_BLEND_MODE)) },
    { MP_ROM_QSTR(MP_QSTR_OUTLINE_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_OUTLINE_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_OUTLINE_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_OUTLINE_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_SHADOW_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SHADOW_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_SHADOW_OFS_X), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SHADOW_OFS_X)) },
    { MP_ROM_QSTR(MP_QSTR_SHADOW_OFS_Y), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SHADOW_OFS_Y)) },
    { MP_ROM_QSTR(MP_QSTR_SHADOW_SPREAD), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SHADOW_SPREAD)) },
    { MP_ROM_QSTR(MP_QSTR_SHADOW_BLEND_MODE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SHADOW_BLEND_MODE)) },
    { MP_ROM_QSTR(MP_QSTR_SHADOW_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SHADOW_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_SHADOW_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SHADOW_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_PATTERN_BLEND_MODE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PATTERN_BLEND_MODE)) },
    { MP_ROM_QSTR(MP_QSTR_PATTERN_REPEAT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PATTERN_REPEAT)) },
    { MP_ROM_QSTR(MP_QSTR_PATTERN_RECOLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PATTERN_RECOLOR)) },
    { MP_ROM_QSTR(MP_QSTR_PATTERN_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PATTERN_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_PATTERN_RECOLOR_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PATTERN_RECOLOR_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_PATTERN_IMAGE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_PATTERN_IMAGE)) },
    { MP_ROM_QSTR(MP_QSTR_VALUE_LETTER_SPACE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_VALUE_LETTER_SPACE)) },
    { MP_ROM_QSTR(MP_QSTR_VALUE_LINE_SPACE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_VALUE_LINE_SPACE)) },
    { MP_ROM_QSTR(MP_QSTR_VALUE_BLEND_MODE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_VALUE_BLEND_MODE)) },
    { MP_ROM_QSTR(MP_QSTR_VALUE_OFS_X), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_VALUE_OFS_X)) },
    { MP_ROM_QSTR(MP_QSTR_VALUE_OFS_Y), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_VALUE_OFS_Y)) },
    { MP_ROM_QSTR(MP_QSTR_VALUE_ALIGN), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_VALUE_ALIGN)) },
    { MP_ROM_QSTR(MP_QSTR_VALUE_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_VALUE_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_VALUE_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_VALUE_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_VALUE_FONT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_VALUE_FONT)) },
    { MP_ROM_QSTR(MP_QSTR_VALUE_STR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_VALUE_STR)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_LETTER_SPACE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TEXT_LETTER_SPACE)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_LINE_SPACE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TEXT_LINE_SPACE)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_DECOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TEXT_DECOR)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_BLEND_MODE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TEXT_BLEND_MODE)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TEXT_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_SEL_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TEXT_SEL_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_SEL_BG_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TEXT_SEL_BG_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TEXT_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_FONT), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TEXT_FONT)) },
    { MP_ROM_QSTR(MP_QSTR_LINE_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_LINE_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_LINE_BLEND_MODE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_LINE_BLEND_MODE)) },
    { MP_ROM_QSTR(MP_QSTR_LINE_DASH_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_LINE_DASH_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_LINE_DASH_GAP), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_LINE_DASH_GAP)) },
    { MP_ROM_QSTR(MP_QSTR_LINE_ROUNDED), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_LINE_ROUNDED)) },
    { MP_ROM_QSTR(MP_QSTR_LINE_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_LINE_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_LINE_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_LINE_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_IMAGE_BLEND_MODE), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_IMAGE_BLEND_MODE)) },
    { MP_ROM_QSTR(MP_QSTR_IMAGE_RECOLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_IMAGE_RECOLOR)) },
    { MP_ROM_QSTR(MP_QSTR_IMAGE_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_IMAGE_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_IMAGE_RECOLOR_OPA), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_IMAGE_RECOLOR_OPA)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSITION_TIME), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSITION_TIME)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSITION_DELAY), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSITION_DELAY)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSITION_PROP_1), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSITION_PROP_1)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSITION_PROP_2), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSITION_PROP_2)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSITION_PROP_3), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSITION_PROP_3)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSITION_PROP_4), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSITION_PROP_4)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSITION_PROP_5), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSITION_PROP_5)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSITION_PROP_6), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSITION_PROP_6)) },
    { MP_ROM_QSTR(MP_QSTR_TRANSITION_PATH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_TRANSITION_PATH)) },
    { MP_ROM_QSTR(MP_QSTR_SCALE_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SCALE_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_SCALE_BORDER_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SCALE_BORDER_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_SCALE_END_BORDER_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SCALE_END_BORDER_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_SCALE_END_LINE_WIDTH), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SCALE_END_LINE_WIDTH)) },
    { MP_ROM_QSTR(MP_QSTR_SCALE_GRAD_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SCALE_GRAD_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_SCALE_END_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_STYLE_SCALE_END_COLOR)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_STYLE_locals_dict, LV_STYLE_locals_dict_table);

STATIC void LV_STYLE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_STYLE");
}



STATIC const mp_obj_type_t mp_LV_STYLE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_STYLE,
    .print = LV_STYLE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_STYLE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_BIDI_DIR object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_BIDI_DIR_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_LTR), MP_ROM_PTR(MP_ROM_INT(LV_BIDI_DIR_LTR)) },
    { MP_ROM_QSTR(MP_QSTR_RTL), MP_ROM_PTR(MP_ROM_INT(LV_BIDI_DIR_RTL)) },
    { MP_ROM_QSTR(MP_QSTR_AUTO), MP_ROM_PTR(MP_ROM_INT(LV_BIDI_DIR_AUTO)) },
    { MP_ROM_QSTR(MP_QSTR_INHERIT), MP_ROM_PTR(MP_ROM_INT(LV_BIDI_DIR_INHERIT)) },
    { MP_ROM_QSTR(MP_QSTR_NEUTRAL), MP_ROM_PTR(MP_ROM_INT(LV_BIDI_DIR_NEUTRAL)) },
    { MP_ROM_QSTR(MP_QSTR_WEAK), MP_ROM_PTR(MP_ROM_INT(LV_BIDI_DIR_WEAK)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_BIDI_DIR_locals_dict, LV_BIDI_DIR_locals_dict_table);

STATIC void LV_BIDI_DIR_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_BIDI_DIR");
}



STATIC const mp_obj_type_t mp_LV_BIDI_DIR_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_BIDI_DIR,
    .print = LV_BIDI_DIR_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_BIDI_DIR_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_TXT_FLAG object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_TXT_FLAG_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_TXT_FLAG_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_RECOLOR), MP_ROM_PTR(MP_ROM_INT(LV_TXT_FLAG_RECOLOR)) },
    { MP_ROM_QSTR(MP_QSTR_EXPAND), MP_ROM_PTR(MP_ROM_INT(LV_TXT_FLAG_EXPAND)) },
    { MP_ROM_QSTR(MP_QSTR_CENTER), MP_ROM_PTR(MP_ROM_INT(LV_TXT_FLAG_CENTER)) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_TXT_FLAG_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_FIT), MP_ROM_PTR(MP_ROM_INT(LV_TXT_FLAG_FIT)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_TXT_FLAG_locals_dict, LV_TXT_FLAG_locals_dict_table);

STATIC void LV_TXT_FLAG_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_TXT_FLAG");
}



STATIC const mp_obj_type_t mp_LV_TXT_FLAG_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_TXT_FLAG,
    .print = LV_TXT_FLAG_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_TXT_FLAG_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_TXT_CMD_STATE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_TXT_CMD_STATE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_WAIT), MP_ROM_PTR(MP_ROM_INT(LV_TXT_CMD_STATE_WAIT)) },
    { MP_ROM_QSTR(MP_QSTR_PAR), MP_ROM_PTR(MP_ROM_INT(LV_TXT_CMD_STATE_PAR)) },
    { MP_ROM_QSTR(MP_QSTR_IN), MP_ROM_PTR(MP_ROM_INT(LV_TXT_CMD_STATE_IN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_TXT_CMD_STATE_locals_dict, LV_TXT_CMD_STATE_locals_dict_table);

STATIC void LV_TXT_CMD_STATE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_TXT_CMD_STATE");
}



STATIC const mp_obj_type_t mp_LV_TXT_CMD_STATE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_TXT_CMD_STATE,
    .print = LV_TXT_CMD_STATE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_TXT_CMD_STATE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_IMG_CF object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_IMG_CF_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_UNKNOWN), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_UNKNOWN)) },
    { MP_ROM_QSTR(MP_QSTR_RAW), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RAW)) },
    { MP_ROM_QSTR(MP_QSTR_RAW_ALPHA), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RAW_ALPHA)) },
    { MP_ROM_QSTR(MP_QSTR_RAW_CHROMA_KEYED), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RAW_CHROMA_KEYED)) },
    { MP_ROM_QSTR(MP_QSTR_TRUE_COLOR), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_TRUE_COLOR)) },
    { MP_ROM_QSTR(MP_QSTR_TRUE_COLOR_ALPHA), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_TRUE_COLOR_ALPHA)) },
    { MP_ROM_QSTR(MP_QSTR_TRUE_COLOR_CHROMA_KEYED), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED)) },
    { MP_ROM_QSTR(MP_QSTR_INDEXED_1BIT), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_INDEXED_1BIT)) },
    { MP_ROM_QSTR(MP_QSTR_INDEXED_2BIT), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_INDEXED_2BIT)) },
    { MP_ROM_QSTR(MP_QSTR_INDEXED_4BIT), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_INDEXED_4BIT)) },
    { MP_ROM_QSTR(MP_QSTR_INDEXED_8BIT), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_INDEXED_8BIT)) },
    { MP_ROM_QSTR(MP_QSTR_ALPHA_1BIT), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_ALPHA_1BIT)) },
    { MP_ROM_QSTR(MP_QSTR_ALPHA_2BIT), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_ALPHA_2BIT)) },
    { MP_ROM_QSTR(MP_QSTR_ALPHA_4BIT), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_ALPHA_4BIT)) },
    { MP_ROM_QSTR(MP_QSTR_ALPHA_8BIT), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_ALPHA_8BIT)) },
    { MP_ROM_QSTR(MP_QSTR_RESERVED_15), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RESERVED_15)) },
    { MP_ROM_QSTR(MP_QSTR_RESERVED_16), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RESERVED_16)) },
    { MP_ROM_QSTR(MP_QSTR_RESERVED_17), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RESERVED_17)) },
    { MP_ROM_QSTR(MP_QSTR_RESERVED_18), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RESERVED_18)) },
    { MP_ROM_QSTR(MP_QSTR_RESERVED_19), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RESERVED_19)) },
    { MP_ROM_QSTR(MP_QSTR_RESERVED_20), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RESERVED_20)) },
    { MP_ROM_QSTR(MP_QSTR_RESERVED_21), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RESERVED_21)) },
    { MP_ROM_QSTR(MP_QSTR_RESERVED_22), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RESERVED_22)) },
    { MP_ROM_QSTR(MP_QSTR_RESERVED_23), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_RESERVED_23)) },
    { MP_ROM_QSTR(MP_QSTR_USER_ENCODED_0), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_USER_ENCODED_0)) },
    { MP_ROM_QSTR(MP_QSTR_USER_ENCODED_1), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_USER_ENCODED_1)) },
    { MP_ROM_QSTR(MP_QSTR_USER_ENCODED_2), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_USER_ENCODED_2)) },
    { MP_ROM_QSTR(MP_QSTR_USER_ENCODED_3), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_USER_ENCODED_3)) },
    { MP_ROM_QSTR(MP_QSTR_USER_ENCODED_4), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_USER_ENCODED_4)) },
    { MP_ROM_QSTR(MP_QSTR_USER_ENCODED_5), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_USER_ENCODED_5)) },
    { MP_ROM_QSTR(MP_QSTR_USER_ENCODED_6), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_USER_ENCODED_6)) },
    { MP_ROM_QSTR(MP_QSTR_USER_ENCODED_7), MP_ROM_PTR(MP_ROM_INT(LV_IMG_CF_USER_ENCODED_7)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_IMG_CF_locals_dict, LV_IMG_CF_locals_dict_table);

STATIC void LV_IMG_CF_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_IMG_CF");
}



STATIC const mp_obj_type_t mp_LV_IMG_CF_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_IMG_CF,
    .print = LV_IMG_CF_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_IMG_CF_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_FS_RES object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_FS_RES_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_OK), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_OK)) },
    { MP_ROM_QSTR(MP_QSTR_HW_ERR), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_HW_ERR)) },
    { MP_ROM_QSTR(MP_QSTR_FS_ERR), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_FS_ERR)) },
    { MP_ROM_QSTR(MP_QSTR_NOT_EX), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_NOT_EX)) },
    { MP_ROM_QSTR(MP_QSTR_FULL), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_FULL)) },
    { MP_ROM_QSTR(MP_QSTR_LOCKED), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_LOCKED)) },
    { MP_ROM_QSTR(MP_QSTR_DENIED), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_DENIED)) },
    { MP_ROM_QSTR(MP_QSTR_BUSY), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_BUSY)) },
    { MP_ROM_QSTR(MP_QSTR_TOUT), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_TOUT)) },
    { MP_ROM_QSTR(MP_QSTR_NOT_IMP), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_NOT_IMP)) },
    { MP_ROM_QSTR(MP_QSTR_OUT_OF_MEM), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_OUT_OF_MEM)) },
    { MP_ROM_QSTR(MP_QSTR_INV_PARAM), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_INV_PARAM)) },
    { MP_ROM_QSTR(MP_QSTR_UNKNOWN), MP_ROM_PTR(MP_ROM_INT(LV_FS_RES_UNKNOWN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_FS_RES_locals_dict, LV_FS_RES_locals_dict_table);

STATIC void LV_FS_RES_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_FS_RES");
}



STATIC const mp_obj_type_t mp_LV_FS_RES_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_FS_RES,
    .print = LV_FS_RES_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_FS_RES_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_FS_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_FS_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_WR), MP_ROM_PTR(MP_ROM_INT(LV_FS_MODE_WR)) },
    { MP_ROM_QSTR(MP_QSTR_RD), MP_ROM_PTR(MP_ROM_INT(LV_FS_MODE_RD)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_FS_MODE_locals_dict, LV_FS_MODE_locals_dict_table);

STATIC void LV_FS_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_FS_MODE");
}



STATIC const mp_obj_type_t mp_LV_FS_MODE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_FS_MODE,
    .print = LV_FS_MODE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_FS_MODE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_IMG_SRC object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_IMG_SRC_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_VARIABLE), MP_ROM_PTR(MP_ROM_INT(LV_IMG_SRC_VARIABLE)) },
    { MP_ROM_QSTR(MP_QSTR_FILE), MP_ROM_PTR(MP_ROM_INT(LV_IMG_SRC_FILE)) },
    { MP_ROM_QSTR(MP_QSTR_SYMBOL), MP_ROM_PTR(MP_ROM_INT(LV_IMG_SRC_SYMBOL)) },
    { MP_ROM_QSTR(MP_QSTR_UNKNOWN), MP_ROM_PTR(MP_ROM_INT(LV_IMG_SRC_UNKNOWN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_IMG_SRC_locals_dict, LV_IMG_SRC_locals_dict_table);

STATIC void LV_IMG_SRC_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_IMG_SRC");
}



STATIC const mp_obj_type_t mp_LV_IMG_SRC_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_IMG_SRC,
    .print = LV_IMG_SRC_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_IMG_SRC_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_DESIGN object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DESIGN_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_DRAW_MAIN), MP_ROM_PTR(MP_ROM_INT(LV_DESIGN_DRAW_MAIN)) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_POST), MP_ROM_PTR(MP_ROM_INT(LV_DESIGN_DRAW_POST)) },
    { MP_ROM_QSTR(MP_QSTR_COVER_CHK), MP_ROM_PTR(MP_ROM_INT(LV_DESIGN_COVER_CHK)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DESIGN_locals_dict, LV_DESIGN_locals_dict_table);

STATIC void LV_DESIGN_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DESIGN");
}



STATIC const mp_obj_type_t mp_LV_DESIGN_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_DESIGN,
    .print = LV_DESIGN_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_DESIGN_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_DESIGN_RES object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DESIGN_RES_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_OK), MP_ROM_PTR(MP_ROM_INT(LV_DESIGN_RES_OK)) },
    { MP_ROM_QSTR(MP_QSTR_COVER), MP_ROM_PTR(MP_ROM_INT(LV_DESIGN_RES_COVER)) },
    { MP_ROM_QSTR(MP_QSTR_NOT_COVER), MP_ROM_PTR(MP_ROM_INT(LV_DESIGN_RES_NOT_COVER)) },
    { MP_ROM_QSTR(MP_QSTR_MASKED), MP_ROM_PTR(MP_ROM_INT(LV_DESIGN_RES_MASKED)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DESIGN_RES_locals_dict, LV_DESIGN_RES_locals_dict_table);

STATIC void LV_DESIGN_RES_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DESIGN_RES");
}



STATIC const mp_obj_type_t mp_LV_DESIGN_RES_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_DESIGN_RES,
    .print = LV_DESIGN_RES_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_DESIGN_RES_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_EVENT object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_EVENT_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_PRESSED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_PRESSED)) },
    { MP_ROM_QSTR(MP_QSTR_PRESSING), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_PRESSING)) },
    { MP_ROM_QSTR(MP_QSTR_PRESS_LOST), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_PRESS_LOST)) },
    { MP_ROM_QSTR(MP_QSTR_SHORT_CLICKED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_SHORT_CLICKED)) },
    { MP_ROM_QSTR(MP_QSTR_LONG_PRESSED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_LONG_PRESSED)) },
    { MP_ROM_QSTR(MP_QSTR_LONG_PRESSED_REPEAT), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_LONG_PRESSED_REPEAT)) },
    { MP_ROM_QSTR(MP_QSTR_CLICKED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_CLICKED)) },
    { MP_ROM_QSTR(MP_QSTR_RELEASED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_RELEASED)) },
    { MP_ROM_QSTR(MP_QSTR_DRAG_BEGIN), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DRAG_BEGIN)) },
    { MP_ROM_QSTR(MP_QSTR_DRAG_END), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DRAG_END)) },
    { MP_ROM_QSTR(MP_QSTR_DRAG_THROW_BEGIN), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DRAG_THROW_BEGIN)) },
    { MP_ROM_QSTR(MP_QSTR_GESTURE), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_GESTURE)) },
    { MP_ROM_QSTR(MP_QSTR_KEY), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_KEY)) },
    { MP_ROM_QSTR(MP_QSTR_FOCUSED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_FOCUSED)) },
    { MP_ROM_QSTR(MP_QSTR_DEFOCUSED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DEFOCUSED)) },
    { MP_ROM_QSTR(MP_QSTR_LEAVE), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_LEAVE)) },
    { MP_ROM_QSTR(MP_QSTR_VALUE_CHANGED), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_VALUE_CHANGED)) },
    { MP_ROM_QSTR(MP_QSTR_INSERT), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_INSERT)) },
    { MP_ROM_QSTR(MP_QSTR_REFRESH), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_REFRESH)) },
    { MP_ROM_QSTR(MP_QSTR_APPLY), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_APPLY)) },
    { MP_ROM_QSTR(MP_QSTR_CANCEL), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_CANCEL)) },
    { MP_ROM_QSTR(MP_QSTR_DELETE), MP_ROM_PTR(MP_ROM_INT(LV_EVENT_DELETE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_EVENT_locals_dict, LV_EVENT_locals_dict_table);

STATIC void LV_EVENT_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_EVENT");
}



STATIC const mp_obj_type_t mp_LV_EVENT_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_EVENT,
    .print = LV_EVENT_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_EVENT_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_SIGNAL object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SIGNAL_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_CLEANUP), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_CLEANUP)) },
    { MP_ROM_QSTR(MP_QSTR_CHILD_CHG), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_CHILD_CHG)) },
    { MP_ROM_QSTR(MP_QSTR_COORD_CHG), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_COORD_CHG)) },
    { MP_ROM_QSTR(MP_QSTR_PARENT_SIZE_CHG), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_PARENT_SIZE_CHG)) },
    { MP_ROM_QSTR(MP_QSTR_STYLE_CHG), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_STYLE_CHG)) },
    { MP_ROM_QSTR(MP_QSTR_BASE_DIR_CHG), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_BASE_DIR_CHG)) },
    { MP_ROM_QSTR(MP_QSTR_REFR_EXT_DRAW_PAD), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_REFR_EXT_DRAW_PAD)) },
    { MP_ROM_QSTR(MP_QSTR_GET_TYPE), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_GET_TYPE)) },
    { MP_ROM_QSTR(MP_QSTR_GET_STYLE), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_GET_STYLE)) },
    { MP_ROM_QSTR(MP_QSTR_GET_STATE_DSC), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_GET_STATE_DSC)) },
    { MP_ROM_QSTR(MP_QSTR_HIT_TEST), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_HIT_TEST)) },
    { MP_ROM_QSTR(MP_QSTR_PRESSED), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_PRESSED)) },
    { MP_ROM_QSTR(MP_QSTR_PRESSING), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_PRESSING)) },
    { MP_ROM_QSTR(MP_QSTR_PRESS_LOST), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_PRESS_LOST)) },
    { MP_ROM_QSTR(MP_QSTR_RELEASED), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_RELEASED)) },
    { MP_ROM_QSTR(MP_QSTR_LONG_PRESS), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_LONG_PRESS)) },
    { MP_ROM_QSTR(MP_QSTR_LONG_PRESS_REP), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_LONG_PRESS_REP)) },
    { MP_ROM_QSTR(MP_QSTR_DRAG_BEGIN), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_DRAG_BEGIN)) },
    { MP_ROM_QSTR(MP_QSTR_DRAG_THROW_BEGIN), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_DRAG_THROW_BEGIN)) },
    { MP_ROM_QSTR(MP_QSTR_DRAG_END), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_DRAG_END)) },
    { MP_ROM_QSTR(MP_QSTR_GESTURE), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_GESTURE)) },
    { MP_ROM_QSTR(MP_QSTR_LEAVE), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_LEAVE)) },
    { MP_ROM_QSTR(MP_QSTR_FOCUS), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_FOCUS)) },
    { MP_ROM_QSTR(MP_QSTR_DEFOCUS), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_DEFOCUS)) },
    { MP_ROM_QSTR(MP_QSTR_CONTROL), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_CONTROL)) },
    { MP_ROM_QSTR(MP_QSTR_GET_EDITABLE), MP_ROM_PTR(MP_ROM_INT(LV_SIGNAL_GET_EDITABLE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SIGNAL_locals_dict, LV_SIGNAL_locals_dict_table);

STATIC void LV_SIGNAL_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SIGNAL");
}



STATIC const mp_obj_type_t mp_LV_SIGNAL_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_SIGNAL,
    .print = LV_SIGNAL_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_SIGNAL_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_PROTECT object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_PROTECT_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_PROTECT_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_CHILD_CHG), MP_ROM_PTR(MP_ROM_INT(LV_PROTECT_CHILD_CHG)) },
    { MP_ROM_QSTR(MP_QSTR_PARENT), MP_ROM_PTR(MP_ROM_INT(LV_PROTECT_PARENT)) },
    { MP_ROM_QSTR(MP_QSTR_POS), MP_ROM_PTR(MP_ROM_INT(LV_PROTECT_POS)) },
    { MP_ROM_QSTR(MP_QSTR_FOLLOW), MP_ROM_PTR(MP_ROM_INT(LV_PROTECT_FOLLOW)) },
    { MP_ROM_QSTR(MP_QSTR_PRESS_LOST), MP_ROM_PTR(MP_ROM_INT(LV_PROTECT_PRESS_LOST)) },
    { MP_ROM_QSTR(MP_QSTR_CLICK_FOCUS), MP_ROM_PTR(MP_ROM_INT(LV_PROTECT_CLICK_FOCUS)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_PROTECT_locals_dict, LV_PROTECT_locals_dict_table);

STATIC void LV_PROTECT_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_PROTECT");
}



STATIC const mp_obj_type_t mp_LV_PROTECT_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_PROTECT,
    .print = LV_PROTECT_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_PROTECT_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_STATE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_STATE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_DEFAULT), MP_ROM_PTR(MP_ROM_INT(LV_STATE_DEFAULT)) },
    { MP_ROM_QSTR(MP_QSTR_CHECKED), MP_ROM_PTR(MP_ROM_INT(LV_STATE_CHECKED)) },
    { MP_ROM_QSTR(MP_QSTR_FOCUSED), MP_ROM_PTR(MP_ROM_INT(LV_STATE_FOCUSED)) },
    { MP_ROM_QSTR(MP_QSTR_EDITED), MP_ROM_PTR(MP_ROM_INT(LV_STATE_EDITED)) },
    { MP_ROM_QSTR(MP_QSTR_HOVERED), MP_ROM_PTR(MP_ROM_INT(LV_STATE_HOVERED)) },
    { MP_ROM_QSTR(MP_QSTR_PRESSED), MP_ROM_PTR(MP_ROM_INT(LV_STATE_PRESSED)) },
    { MP_ROM_QSTR(MP_QSTR_DISABLED), MP_ROM_PTR(MP_ROM_INT(LV_STATE_DISABLED)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_STATE_locals_dict, LV_STATE_locals_dict_table);

STATIC void LV_STATE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_STATE");
}



STATIC const mp_obj_type_t mp_LV_STATE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_STATE,
    .print = LV_STATE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_STATE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_OBJ_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_OBJ_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_MAIN), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_PART_MAIN)) },
    { MP_ROM_QSTR(MP_QSTR_ALL), MP_ROM_PTR(MP_ROM_INT(LV_OBJ_PART_ALL)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_OBJ_PART_locals_dict, LV_OBJ_PART_locals_dict_table);

STATIC void LV_OBJ_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_OBJ_PART");
}



STATIC const mp_obj_type_t mp_LV_OBJ_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_OBJ_PART,
    .print = LV_OBJ_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_OBJ_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_KEY object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_KEY_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_UP), MP_ROM_PTR(MP_ROM_INT(LV_KEY_UP)) },
    { MP_ROM_QSTR(MP_QSTR_DOWN), MP_ROM_PTR(MP_ROM_INT(LV_KEY_DOWN)) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_KEY_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_KEY_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_ESC), MP_ROM_PTR(MP_ROM_INT(LV_KEY_ESC)) },
    { MP_ROM_QSTR(MP_QSTR_DEL), MP_ROM_PTR(MP_ROM_INT(LV_KEY_DEL)) },
    { MP_ROM_QSTR(MP_QSTR_BACKSPACE), MP_ROM_PTR(MP_ROM_INT(LV_KEY_BACKSPACE)) },
    { MP_ROM_QSTR(MP_QSTR_ENTER), MP_ROM_PTR(MP_ROM_INT(LV_KEY_ENTER)) },
    { MP_ROM_QSTR(MP_QSTR_NEXT), MP_ROM_PTR(MP_ROM_INT(LV_KEY_NEXT)) },
    { MP_ROM_QSTR(MP_QSTR_PREV), MP_ROM_PTR(MP_ROM_INT(LV_KEY_PREV)) },
    { MP_ROM_QSTR(MP_QSTR_HOME), MP_ROM_PTR(MP_ROM_INT(LV_KEY_HOME)) },
    { MP_ROM_QSTR(MP_QSTR_END), MP_ROM_PTR(MP_ROM_INT(LV_KEY_END)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_KEY_locals_dict, LV_KEY_locals_dict_table);

STATIC void LV_KEY_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_KEY");
}



STATIC const mp_obj_type_t mp_LV_KEY_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_KEY,
    .print = LV_KEY_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_KEY_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_GROUP_REFOCUS_POLICY object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_GROUP_REFOCUS_POLICY_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NEXT), MP_ROM_PTR(MP_ROM_INT(LV_GROUP_REFOCUS_POLICY_NEXT)) },
    { MP_ROM_QSTR(MP_QSTR_PREV), MP_ROM_PTR(MP_ROM_INT(LV_GROUP_REFOCUS_POLICY_PREV)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_GROUP_REFOCUS_POLICY_locals_dict, LV_GROUP_REFOCUS_POLICY_locals_dict_table);

STATIC void LV_GROUP_REFOCUS_POLICY_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_GROUP_REFOCUS_POLICY");
}



STATIC const mp_obj_type_t mp_LV_GROUP_REFOCUS_POLICY_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_GROUP_REFOCUS_POLICY,
    .print = LV_GROUP_REFOCUS_POLICY_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_GROUP_REFOCUS_POLICY_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_FONT_FMT_TXT_CMAP object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_FONT_FMT_TXT_CMAP_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_FORMAT0_TINY), MP_ROM_PTR(MP_ROM_INT(LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY)) },
    { MP_ROM_QSTR(MP_QSTR_FORMAT0_FULL), MP_ROM_PTR(MP_ROM_INT(LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL)) },
    { MP_ROM_QSTR(MP_QSTR_SPARSE_TINY), MP_ROM_PTR(MP_ROM_INT(LV_FONT_FMT_TXT_CMAP_SPARSE_TINY)) },
    { MP_ROM_QSTR(MP_QSTR_SPARSE_FULL), MP_ROM_PTR(MP_ROM_INT(LV_FONT_FMT_TXT_CMAP_SPARSE_FULL)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_FONT_FMT_TXT_CMAP_locals_dict, LV_FONT_FMT_TXT_CMAP_locals_dict_table);

STATIC void LV_FONT_FMT_TXT_CMAP_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_FONT_FMT_TXT_CMAP");
}



STATIC const mp_obj_type_t mp_LV_FONT_FMT_TXT_CMAP_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_FONT_FMT_TXT_CMAP,
    .print = LV_FONT_FMT_TXT_CMAP_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_FONT_FMT_TXT_CMAP_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_LAYOUT object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_LAYOUT_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_OFF), MP_ROM_PTR(MP_ROM_INT(LV_LAYOUT_OFF)) },
    { MP_ROM_QSTR(MP_QSTR_CENTER), MP_ROM_PTR(MP_ROM_INT(LV_LAYOUT_CENTER)) },
    { MP_ROM_QSTR(MP_QSTR_COLUMN_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_LAYOUT_COLUMN_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_COLUMN_MID), MP_ROM_PTR(MP_ROM_INT(LV_LAYOUT_COLUMN_MID)) },
    { MP_ROM_QSTR(MP_QSTR_COLUMN_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_LAYOUT_COLUMN_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_ROW_TOP), MP_ROM_PTR(MP_ROM_INT(LV_LAYOUT_ROW_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_ROW_MID), MP_ROM_PTR(MP_ROM_INT(LV_LAYOUT_ROW_MID)) },
    { MP_ROM_QSTR(MP_QSTR_ROW_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_LAYOUT_ROW_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_PRETTY_TOP), MP_ROM_PTR(MP_ROM_INT(LV_LAYOUT_PRETTY_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_PRETTY_MID), MP_ROM_PTR(MP_ROM_INT(LV_LAYOUT_PRETTY_MID)) },
    { MP_ROM_QSTR(MP_QSTR_PRETTY_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_LAYOUT_PRETTY_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_GRID), MP_ROM_PTR(MP_ROM_INT(LV_LAYOUT_GRID)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_LAYOUT_locals_dict, LV_LAYOUT_locals_dict_table);

STATIC void LV_LAYOUT_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_LAYOUT");
}



STATIC const mp_obj_type_t mp_LV_LAYOUT_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_LAYOUT,
    .print = LV_LAYOUT_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_LAYOUT_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_FIT object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_FIT_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_FIT_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_TIGHT), MP_ROM_PTR(MP_ROM_INT(LV_FIT_TIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_PARENT), MP_ROM_PTR(MP_ROM_INT(LV_FIT_PARENT)) },
    { MP_ROM_QSTR(MP_QSTR_MAX), MP_ROM_PTR(MP_ROM_INT(LV_FIT_MAX)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_FIT_locals_dict, LV_FIT_locals_dict_table);

STATIC void LV_FIT_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_FIT");
}



STATIC const mp_obj_type_t mp_LV_FIT_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_FIT,
    .print = LV_FIT_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_FIT_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_CONT_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_CONT_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_MAIN), MP_ROM_PTR(MP_ROM_INT(LV_CONT_PART_MAIN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_CONT_PART_locals_dict, LV_CONT_PART_locals_dict_table);

STATIC void LV_CONT_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_CONT_PART");
}



STATIC const mp_obj_type_t mp_LV_CONT_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_CONT_PART,
    .print = LV_CONT_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_CONT_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_BTN_STATE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_BTN_STATE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_RELEASED), MP_ROM_PTR(MP_ROM_INT(LV_BTN_STATE_RELEASED)) },
    { MP_ROM_QSTR(MP_QSTR_PRESSED), MP_ROM_PTR(MP_ROM_INT(LV_BTN_STATE_PRESSED)) },
    { MP_ROM_QSTR(MP_QSTR_DISABLED), MP_ROM_PTR(MP_ROM_INT(LV_BTN_STATE_DISABLED)) },
    { MP_ROM_QSTR(MP_QSTR_CHECKED_RELEASED), MP_ROM_PTR(MP_ROM_INT(LV_BTN_STATE_CHECKED_RELEASED)) },
    { MP_ROM_QSTR(MP_QSTR_CHECKED_PRESSED), MP_ROM_PTR(MP_ROM_INT(LV_BTN_STATE_CHECKED_PRESSED)) },
    { MP_ROM_QSTR(MP_QSTR_CHECKED_DISABLED), MP_ROM_PTR(MP_ROM_INT(LV_BTN_STATE_CHECKED_DISABLED)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_BTN_STATE_locals_dict, LV_BTN_STATE_locals_dict_table);

STATIC void LV_BTN_STATE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_BTN_STATE");
}



STATIC const mp_obj_type_t mp_LV_BTN_STATE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_BTN_STATE,
    .print = LV_BTN_STATE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_BTN_STATE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_BTN_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_BTN_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_MAIN), MP_ROM_PTR(MP_ROM_INT(LV_BTN_PART_MAIN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_BTN_PART_locals_dict, LV_BTN_PART_locals_dict_table);

STATIC void LV_BTN_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_BTN_PART");
}



STATIC const mp_obj_type_t mp_LV_BTN_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_BTN_PART,
    .print = LV_BTN_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_BTN_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_IMGBTN_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_IMGBTN_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_MAIN), MP_ROM_PTR(MP_ROM_INT(LV_IMGBTN_PART_MAIN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_IMGBTN_PART_locals_dict, LV_IMGBTN_PART_locals_dict_table);

STATIC void LV_IMGBTN_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_IMGBTN_PART");
}



STATIC const mp_obj_type_t mp_LV_IMGBTN_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_IMGBTN_PART,
    .print = LV_IMGBTN_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_IMGBTN_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl ENUM_LV_LABEL_DOT object definitions
 */
    

STATIC const mp_rom_map_elem_t ENUM_LV_LABEL_DOT_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NUM), MP_ROM_PTR(MP_ROM_INT(ENUM_LV_LABEL_DOT_NUM)) }
};

STATIC MP_DEFINE_CONST_DICT(ENUM_LV_LABEL_DOT_locals_dict, ENUM_LV_LABEL_DOT_locals_dict_table);

STATIC void ENUM_LV_LABEL_DOT_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl ENUM_LV_LABEL_DOT");
}



STATIC const mp_obj_type_t mp_ENUM_LV_LABEL_DOT_type = {
    { &mp_type_type },
    .name = MP_QSTR_ENUM_LV_LABEL_DOT,
    .print = ENUM_LV_LABEL_DOT_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&ENUM_LV_LABEL_DOT_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl ENUM_LV_LABEL_POS object definitions
 */
    

STATIC const mp_rom_map_elem_t ENUM_LV_LABEL_POS_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_LAST), MP_ROM_PTR(MP_ROM_INT(ENUM_LV_LABEL_POS_LAST)) }
};

STATIC MP_DEFINE_CONST_DICT(ENUM_LV_LABEL_POS_locals_dict, ENUM_LV_LABEL_POS_locals_dict_table);

STATIC void ENUM_LV_LABEL_POS_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl ENUM_LV_LABEL_POS");
}



STATIC const mp_obj_type_t mp_ENUM_LV_LABEL_POS_type = {
    { &mp_type_type },
    .name = MP_QSTR_ENUM_LV_LABEL_POS,
    .print = ENUM_LV_LABEL_POS_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&ENUM_LV_LABEL_POS_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl ENUM_LV_LABEL_TEXT_SEL object definitions
 */
    

STATIC const mp_rom_map_elem_t ENUM_LV_LABEL_TEXT_SEL_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_OFF), MP_ROM_PTR(MP_ROM_INT(ENUM_LV_LABEL_TEXT_SEL_OFF)) }
};

STATIC MP_DEFINE_CONST_DICT(ENUM_LV_LABEL_TEXT_SEL_locals_dict, ENUM_LV_LABEL_TEXT_SEL_locals_dict_table);

STATIC void ENUM_LV_LABEL_TEXT_SEL_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl ENUM_LV_LABEL_TEXT_SEL");
}



STATIC const mp_obj_type_t mp_ENUM_LV_LABEL_TEXT_SEL_type = {
    { &mp_type_type },
    .name = MP_QSTR_ENUM_LV_LABEL_TEXT_SEL,
    .print = ENUM_LV_LABEL_TEXT_SEL_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&ENUM_LV_LABEL_TEXT_SEL_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_LABEL_LONG object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_LABEL_LONG_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_EXPAND), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_LONG_EXPAND)) },
    { MP_ROM_QSTR(MP_QSTR_BREAK), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_LONG_BREAK)) },
    { MP_ROM_QSTR(MP_QSTR_DOT), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_LONG_DOT)) },
    { MP_ROM_QSTR(MP_QSTR_SROLL), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_LONG_SROLL)) },
    { MP_ROM_QSTR(MP_QSTR_SROLL_CIRC), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_LONG_SROLL_CIRC)) },
    { MP_ROM_QSTR(MP_QSTR_CROP), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_LONG_CROP)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_LABEL_LONG_locals_dict, LV_LABEL_LONG_locals_dict_table);

STATIC void LV_LABEL_LONG_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_LABEL_LONG");
}



STATIC const mp_obj_type_t mp_LV_LABEL_LONG_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_LABEL_LONG,
    .print = LV_LABEL_LONG_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_LABEL_LONG_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_LABEL_ALIGN object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_LABEL_ALIGN_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_ALIGN_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_CENTER), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_ALIGN_CENTER)) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_ALIGN_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_AUTO), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_ALIGN_AUTO)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_LABEL_ALIGN_locals_dict, LV_LABEL_ALIGN_locals_dict_table);

STATIC void LV_LABEL_ALIGN_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_LABEL_ALIGN");
}



STATIC const mp_obj_type_t mp_LV_LABEL_ALIGN_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_LABEL_ALIGN,
    .print = LV_LABEL_ALIGN_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_LABEL_ALIGN_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_LABEL_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_LABEL_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_MAIN), MP_ROM_PTR(MP_ROM_INT(LV_LABEL_PART_MAIN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_LABEL_PART_locals_dict, LV_LABEL_PART_locals_dict_table);

STATIC void LV_LABEL_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_LABEL_PART");
}



STATIC const mp_obj_type_t mp_LV_LABEL_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_LABEL_PART,
    .print = LV_LABEL_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_LABEL_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_IMG_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_IMG_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_MAIN), MP_ROM_PTR(MP_ROM_INT(LV_IMG_PART_MAIN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_IMG_PART_locals_dict, LV_IMG_PART_locals_dict_table);

STATIC void LV_IMG_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_IMG_PART");
}



STATIC const mp_obj_type_t mp_LV_IMG_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_IMG_PART,
    .print = LV_IMG_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_IMG_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_LINE_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_LINE_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_MAIN), MP_ROM_PTR(MP_ROM_INT(LV_LINE_PART_MAIN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_LINE_PART_locals_dict, LV_LINE_PART_locals_dict_table);

STATIC void LV_LINE_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_LINE_PART");
}



STATIC const mp_obj_type_t mp_LV_LINE_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_LINE_PART,
    .print = LV_LINE_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_LINE_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_SCROLLBAR_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SCROLLBAR_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_OFF), MP_ROM_PTR(MP_ROM_INT(LV_SCROLLBAR_MODE_OFF)) },
    { MP_ROM_QSTR(MP_QSTR_ON), MP_ROM_PTR(MP_ROM_INT(LV_SCROLLBAR_MODE_ON)) },
    { MP_ROM_QSTR(MP_QSTR_DRAG), MP_ROM_PTR(MP_ROM_INT(LV_SCROLLBAR_MODE_DRAG)) },
    { MP_ROM_QSTR(MP_QSTR_AUTO), MP_ROM_PTR(MP_ROM_INT(LV_SCROLLBAR_MODE_AUTO)) },
    { MP_ROM_QSTR(MP_QSTR_HIDE), MP_ROM_PTR(MP_ROM_INT(LV_SCROLLBAR_MODE_HIDE)) },
    { MP_ROM_QSTR(MP_QSTR_UNHIDE), MP_ROM_PTR(MP_ROM_INT(LV_SCROLLBAR_MODE_UNHIDE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SCROLLBAR_MODE_locals_dict, LV_SCROLLBAR_MODE_locals_dict_table);

STATIC void LV_SCROLLBAR_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SCROLLBAR_MODE");
}



STATIC const mp_obj_type_t mp_LV_SCROLLBAR_MODE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_SCROLLBAR_MODE,
    .print = LV_SCROLLBAR_MODE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_SCROLLBAR_MODE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_PAGE_EDGE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_PAGE_EDGE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_PAGE_EDGE_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_TOP), MP_ROM_PTR(MP_ROM_INT(LV_PAGE_EDGE_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_PAGE_EDGE_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_PAGE_EDGE_BOTTOM)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_PAGE_EDGE_locals_dict, LV_PAGE_EDGE_locals_dict_table);

STATIC void LV_PAGE_EDGE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_PAGE_EDGE");
}



STATIC const mp_obj_type_t mp_LV_PAGE_EDGE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_PAGE_EDGE,
    .print = LV_PAGE_EDGE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_PAGE_EDGE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_PAGE_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_PAGE_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BG), MP_ROM_PTR(MP_ROM_INT(LV_PAGE_PART_BG)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLLBAR), MP_ROM_PTR(MP_ROM_INT(LV_PAGE_PART_SCROLLBAR)) },
    { MP_ROM_QSTR(MP_QSTR_EDGE_FLASH), MP_ROM_PTR(MP_ROM_INT(LV_PAGE_PART_EDGE_FLASH)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLLABLE), MP_ROM_PTR(MP_ROM_INT(LV_PAGE_PART_SCROLLABLE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_PAGE_PART_locals_dict, LV_PAGE_PART_locals_dict_table);

STATIC void LV_PAGE_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_PAGE_PART");
}



STATIC const mp_obj_type_t mp_LV_PAGE_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_PAGE_PART,
    .print = LV_PAGE_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_PAGE_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_LIST_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_LIST_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BG), MP_ROM_PTR(MP_ROM_INT(LV_LIST_PART_BG)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLLBAR), MP_ROM_PTR(MP_ROM_INT(LV_LIST_PART_SCROLLBAR)) },
    { MP_ROM_QSTR(MP_QSTR_EDGE_FLASH), MP_ROM_PTR(MP_ROM_INT(LV_LIST_PART_EDGE_FLASH)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLLABLE), MP_ROM_PTR(MP_ROM_INT(LV_LIST_PART_SCROLLABLE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_LIST_PART_locals_dict, LV_LIST_PART_locals_dict_table);

STATIC void LV_LIST_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_LIST_PART");
}



STATIC const mp_obj_type_t mp_LV_LIST_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_LIST_PART,
    .print = LV_LIST_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_LIST_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl ENUM_LV_CHART_POINT object definitions
 */
    

STATIC const mp_rom_map_elem_t ENUM_LV_CHART_POINT_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_DEF), MP_ROM_PTR(MP_ROM_INT(ENUM_LV_CHART_POINT_DEF)) }
};

STATIC MP_DEFINE_CONST_DICT(ENUM_LV_CHART_POINT_locals_dict, ENUM_LV_CHART_POINT_locals_dict_table);

STATIC void ENUM_LV_CHART_POINT_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl ENUM_LV_CHART_POINT");
}



STATIC const mp_obj_type_t mp_ENUM_LV_CHART_POINT_type = {
    { &mp_type_type },
    .name = MP_QSTR_ENUM_LV_CHART_POINT,
    .print = ENUM_LV_CHART_POINT_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&ENUM_LV_CHART_POINT_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl ENUM_LV_CHART_TICK_LENGTH object definitions
 */
    

STATIC const mp_rom_map_elem_t ENUM_LV_CHART_TICK_LENGTH_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_AUTO), MP_ROM_PTR(MP_ROM_INT(ENUM_LV_CHART_TICK_LENGTH_AUTO)) }
};

STATIC MP_DEFINE_CONST_DICT(ENUM_LV_CHART_TICK_LENGTH_locals_dict, ENUM_LV_CHART_TICK_LENGTH_locals_dict_table);

STATIC void ENUM_LV_CHART_TICK_LENGTH_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl ENUM_LV_CHART_TICK_LENGTH");
}



STATIC const mp_obj_type_t mp_ENUM_LV_CHART_TICK_LENGTH_type = {
    { &mp_type_type },
    .name = MP_QSTR_ENUM_LV_CHART_TICK_LENGTH,
    .print = ENUM_LV_CHART_TICK_LENGTH_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&ENUM_LV_CHART_TICK_LENGTH_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_CHART_TYPE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_CHART_TYPE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_CHART_TYPE_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_LINE), MP_ROM_PTR(MP_ROM_INT(LV_CHART_TYPE_LINE)) },
    { MP_ROM_QSTR(MP_QSTR_COLUMN), MP_ROM_PTR(MP_ROM_INT(LV_CHART_TYPE_COLUMN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_CHART_TYPE_locals_dict, LV_CHART_TYPE_locals_dict_table);

STATIC void LV_CHART_TYPE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_CHART_TYPE");
}



STATIC const mp_obj_type_t mp_LV_CHART_TYPE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_CHART_TYPE,
    .print = LV_CHART_TYPE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_CHART_TYPE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_CHART_UPDATE_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_CHART_UPDATE_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SHIFT), MP_ROM_PTR(MP_ROM_INT(LV_CHART_UPDATE_MODE_SHIFT)) },
    { MP_ROM_QSTR(MP_QSTR_CIRCULAR), MP_ROM_PTR(MP_ROM_INT(LV_CHART_UPDATE_MODE_CIRCULAR)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_CHART_UPDATE_MODE_locals_dict, LV_CHART_UPDATE_MODE_locals_dict_table);

STATIC void LV_CHART_UPDATE_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_CHART_UPDATE_MODE");
}



STATIC const mp_obj_type_t mp_LV_CHART_UPDATE_MODE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_CHART_UPDATE_MODE,
    .print = LV_CHART_UPDATE_MODE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_CHART_UPDATE_MODE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_CHART_AXIS object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_CHART_AXIS_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_PRIMARY_Y), MP_ROM_PTR(MP_ROM_INT(LV_CHART_AXIS_PRIMARY_Y)) },
    { MP_ROM_QSTR(MP_QSTR_SECONDARY_Y), MP_ROM_PTR(MP_ROM_INT(LV_CHART_AXIS_SECONDARY_Y)) },
    { MP_ROM_QSTR(MP_QSTR_SKIP_LAST_TICK), MP_ROM_PTR(MP_ROM_INT(LV_CHART_AXIS_SKIP_LAST_TICK)) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_LAST_TICK), MP_ROM_PTR(MP_ROM_INT(LV_CHART_AXIS_DRAW_LAST_TICK)) },
    { MP_ROM_QSTR(MP_QSTR_INVERSE_LABELS_ORDER), MP_ROM_PTR(MP_ROM_INT(LV_CHART_AXIS_INVERSE_LABELS_ORDER)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_CHART_AXIS_locals_dict, LV_CHART_AXIS_locals_dict_table);

STATIC void LV_CHART_AXIS_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_CHART_AXIS");
}



STATIC const mp_obj_type_t mp_LV_CHART_AXIS_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_CHART_AXIS,
    .print = LV_CHART_AXIS_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_CHART_AXIS_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_CHART_CURSOR object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_CHART_CURSOR_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_CHART_CURSOR_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_CHART_CURSOR_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_UP), MP_ROM_PTR(MP_ROM_INT(LV_CHART_CURSOR_UP)) },
    { MP_ROM_QSTR(MP_QSTR_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_CHART_CURSOR_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_DOWN), MP_ROM_PTR(MP_ROM_INT(LV_CHART_CURSOR_DOWN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_CHART_CURSOR_locals_dict, LV_CHART_CURSOR_locals_dict_table);

STATIC void LV_CHART_CURSOR_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_CHART_CURSOR");
}



STATIC const mp_obj_type_t mp_LV_CHART_CURSOR_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_CHART_CURSOR,
    .print = LV_CHART_CURSOR_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_CHART_CURSOR_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_CHART_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_CHART_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BG), MP_ROM_PTR(MP_ROM_INT(LV_CHART_PART_BG)) },
    { MP_ROM_QSTR(MP_QSTR_SERIES_BG), MP_ROM_PTR(MP_ROM_INT(LV_CHART_PART_SERIES_BG)) },
    { MP_ROM_QSTR(MP_QSTR_SERIES), MP_ROM_PTR(MP_ROM_INT(LV_CHART_PART_SERIES)) },
    { MP_ROM_QSTR(MP_QSTR_CURSOR), MP_ROM_PTR(MP_ROM_INT(LV_CHART_PART_CURSOR)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_CHART_PART_locals_dict, LV_CHART_PART_locals_dict_table);

STATIC void LV_CHART_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_CHART_PART");
}



STATIC const mp_obj_type_t mp_LV_CHART_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_CHART_PART,
    .print = LV_CHART_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_CHART_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_TABLE_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_TABLE_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BG), MP_ROM_PTR(MP_ROM_INT(LV_TABLE_PART_BG)) },
    { MP_ROM_QSTR(MP_QSTR_CELL1), MP_ROM_PTR(MP_ROM_INT(LV_TABLE_PART_CELL1)) },
    { MP_ROM_QSTR(MP_QSTR_CELL2), MP_ROM_PTR(MP_ROM_INT(LV_TABLE_PART_CELL2)) },
    { MP_ROM_QSTR(MP_QSTR_CELL3), MP_ROM_PTR(MP_ROM_INT(LV_TABLE_PART_CELL3)) },
    { MP_ROM_QSTR(MP_QSTR_CELL4), MP_ROM_PTR(MP_ROM_INT(LV_TABLE_PART_CELL4)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_TABLE_PART_locals_dict, LV_TABLE_PART_locals_dict_table);

STATIC void LV_TABLE_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_TABLE_PART");
}



STATIC const mp_obj_type_t mp_LV_TABLE_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_TABLE_PART,
    .print = LV_TABLE_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_TABLE_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_CHECKBOX_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_CHECKBOX_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BG), MP_ROM_PTR(MP_ROM_INT(LV_CHECKBOX_PART_BG)) },
    { MP_ROM_QSTR(MP_QSTR_BULLET), MP_ROM_PTR(MP_ROM_INT(LV_CHECKBOX_PART_BULLET)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_CHECKBOX_PART_locals_dict, LV_CHECKBOX_PART_locals_dict_table);

STATIC void LV_CHECKBOX_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_CHECKBOX_PART");
}



STATIC const mp_obj_type_t mp_LV_CHECKBOX_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_CHECKBOX_PART,
    .print = LV_CHECKBOX_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_CHECKBOX_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_CPICKER_TYPE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_CPICKER_TYPE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_RECT), MP_ROM_PTR(MP_ROM_INT(LV_CPICKER_TYPE_RECT)) },
    { MP_ROM_QSTR(MP_QSTR_DISC), MP_ROM_PTR(MP_ROM_INT(LV_CPICKER_TYPE_DISC)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_CPICKER_TYPE_locals_dict, LV_CPICKER_TYPE_locals_dict_table);

STATIC void LV_CPICKER_TYPE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_CPICKER_TYPE");
}



STATIC const mp_obj_type_t mp_LV_CPICKER_TYPE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_CPICKER_TYPE,
    .print = LV_CPICKER_TYPE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_CPICKER_TYPE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_CPICKER_COLOR_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_CPICKER_COLOR_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_HUE), MP_ROM_PTR(MP_ROM_INT(LV_CPICKER_COLOR_MODE_HUE)) },
    { MP_ROM_QSTR(MP_QSTR_SATURATION), MP_ROM_PTR(MP_ROM_INT(LV_CPICKER_COLOR_MODE_SATURATION)) },
    { MP_ROM_QSTR(MP_QSTR_VALUE), MP_ROM_PTR(MP_ROM_INT(LV_CPICKER_COLOR_MODE_VALUE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_CPICKER_COLOR_MODE_locals_dict, LV_CPICKER_COLOR_MODE_locals_dict_table);

STATIC void LV_CPICKER_COLOR_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_CPICKER_COLOR_MODE");
}



STATIC const mp_obj_type_t mp_LV_CPICKER_COLOR_MODE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_CPICKER_COLOR_MODE,
    .print = LV_CPICKER_COLOR_MODE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_CPICKER_COLOR_MODE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_CPICKER_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_CPICKER_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_MAIN), MP_ROM_PTR(MP_ROM_INT(LV_CPICKER_PART_MAIN)) },
    { MP_ROM_QSTR(MP_QSTR_KNOB), MP_ROM_PTR(MP_ROM_INT(LV_CPICKER_PART_KNOB)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_CPICKER_PART_locals_dict, LV_CPICKER_PART_locals_dict_table);

STATIC void LV_CPICKER_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_CPICKER_PART");
}



STATIC const mp_obj_type_t mp_LV_CPICKER_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_CPICKER_PART,
    .print = LV_CPICKER_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_CPICKER_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_BAR_TYPE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_BAR_TYPE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NORMAL), MP_ROM_PTR(MP_ROM_INT(LV_BAR_TYPE_NORMAL)) },
    { MP_ROM_QSTR(MP_QSTR_SYMMETRICAL), MP_ROM_PTR(MP_ROM_INT(LV_BAR_TYPE_SYMMETRICAL)) },
    { MP_ROM_QSTR(MP_QSTR_CUSTOM), MP_ROM_PTR(MP_ROM_INT(LV_BAR_TYPE_CUSTOM)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_BAR_TYPE_locals_dict, LV_BAR_TYPE_locals_dict_table);

STATIC void LV_BAR_TYPE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_BAR_TYPE");
}



STATIC const mp_obj_type_t mp_LV_BAR_TYPE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_BAR_TYPE,
    .print = LV_BAR_TYPE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_BAR_TYPE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_BAR_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_BAR_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BG), MP_ROM_PTR(MP_ROM_INT(LV_BAR_PART_BG)) },
    { MP_ROM_QSTR(MP_QSTR_INDIC), MP_ROM_PTR(MP_ROM_INT(LV_BAR_PART_INDIC)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_BAR_PART_locals_dict, LV_BAR_PART_locals_dict_table);

STATIC void LV_BAR_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_BAR_PART");
}



STATIC const mp_obj_type_t mp_LV_BAR_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_BAR_PART,
    .print = LV_BAR_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_BAR_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_SLIDER_TYPE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SLIDER_TYPE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NORMAL), MP_ROM_PTR(MP_ROM_INT(LV_SLIDER_TYPE_NORMAL)) },
    { MP_ROM_QSTR(MP_QSTR_SYMMETRICAL), MP_ROM_PTR(MP_ROM_INT(LV_SLIDER_TYPE_SYMMETRICAL)) },
    { MP_ROM_QSTR(MP_QSTR_RANGE), MP_ROM_PTR(MP_ROM_INT(LV_SLIDER_TYPE_RANGE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SLIDER_TYPE_locals_dict, LV_SLIDER_TYPE_locals_dict_table);

STATIC void LV_SLIDER_TYPE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SLIDER_TYPE");
}



STATIC const mp_obj_type_t mp_LV_SLIDER_TYPE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_SLIDER_TYPE,
    .print = LV_SLIDER_TYPE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_SLIDER_TYPE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_SLIDER_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SLIDER_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BG), MP_ROM_PTR(MP_ROM_INT(LV_SLIDER_PART_BG)) },
    { MP_ROM_QSTR(MP_QSTR_INDIC), MP_ROM_PTR(MP_ROM_INT(LV_SLIDER_PART_INDIC)) },
    { MP_ROM_QSTR(MP_QSTR_KNOB), MP_ROM_PTR(MP_ROM_INT(LV_SLIDER_PART_KNOB)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SLIDER_PART_locals_dict, LV_SLIDER_PART_locals_dict_table);

STATIC void LV_SLIDER_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SLIDER_PART");
}



STATIC const mp_obj_type_t mp_LV_SLIDER_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_SLIDER_PART,
    .print = LV_SLIDER_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_SLIDER_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_LED_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_LED_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_MAIN), MP_ROM_PTR(MP_ROM_INT(LV_LED_PART_MAIN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_LED_PART_locals_dict, LV_LED_PART_locals_dict_table);

STATIC void LV_LED_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_LED_PART");
}



STATIC const mp_obj_type_t mp_LV_LED_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_LED_PART,
    .print = LV_LED_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_LED_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl ENUM_LV_BTNMATRIX_BTN object definitions
 */
    

STATIC const mp_rom_map_elem_t ENUM_LV_BTNMATRIX_BTN_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(ENUM_LV_BTNMATRIX_BTN_NONE)) }
};

STATIC MP_DEFINE_CONST_DICT(ENUM_LV_BTNMATRIX_BTN_locals_dict, ENUM_LV_BTNMATRIX_BTN_locals_dict_table);

STATIC void ENUM_LV_BTNMATRIX_BTN_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl ENUM_LV_BTNMATRIX_BTN");
}



STATIC const mp_obj_type_t mp_ENUM_LV_BTNMATRIX_BTN_type = {
    { &mp_type_type },
    .name = MP_QSTR_ENUM_LV_BTNMATRIX_BTN,
    .print = ENUM_LV_BTNMATRIX_BTN_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&ENUM_LV_BTNMATRIX_BTN_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_BTNMATRIX_CTRL object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_BTNMATRIX_CTRL_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_HIDDEN), MP_ROM_PTR(MP_ROM_INT(LV_BTNMATRIX_CTRL_HIDDEN)) },
    { MP_ROM_QSTR(MP_QSTR_NO_REPEAT), MP_ROM_PTR(MP_ROM_INT(LV_BTNMATRIX_CTRL_NO_REPEAT)) },
    { MP_ROM_QSTR(MP_QSTR_DISABLED), MP_ROM_PTR(MP_ROM_INT(LV_BTNMATRIX_CTRL_DISABLED)) },
    { MP_ROM_QSTR(MP_QSTR_CHECKABLE), MP_ROM_PTR(MP_ROM_INT(LV_BTNMATRIX_CTRL_CHECKABLE)) },
    { MP_ROM_QSTR(MP_QSTR_CHECK_STATE), MP_ROM_PTR(MP_ROM_INT(LV_BTNMATRIX_CTRL_CHECK_STATE)) },
    { MP_ROM_QSTR(MP_QSTR_CLICK_TRIG), MP_ROM_PTR(MP_ROM_INT(LV_BTNMATRIX_CTRL_CLICK_TRIG)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_BTNMATRIX_CTRL_locals_dict, LV_BTNMATRIX_CTRL_locals_dict_table);

STATIC void LV_BTNMATRIX_CTRL_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_BTNMATRIX_CTRL");
}



STATIC const mp_obj_type_t mp_LV_BTNMATRIX_CTRL_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_BTNMATRIX_CTRL,
    .print = LV_BTNMATRIX_CTRL_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_BTNMATRIX_CTRL_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_BTNMATRIX_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_BTNMATRIX_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BG), MP_ROM_PTR(MP_ROM_INT(LV_BTNMATRIX_PART_BG)) },
    { MP_ROM_QSTR(MP_QSTR_BTN), MP_ROM_PTR(MP_ROM_INT(LV_BTNMATRIX_PART_BTN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_BTNMATRIX_PART_locals_dict, LV_BTNMATRIX_PART_locals_dict_table);

STATIC void LV_BTNMATRIX_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_BTNMATRIX_PART");
}



STATIC const mp_obj_type_t mp_LV_BTNMATRIX_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_BTNMATRIX_PART,
    .print = LV_BTNMATRIX_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_BTNMATRIX_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_KEYBOARD_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_KEYBOARD_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_TEXT_LOWER), MP_ROM_PTR(MP_ROM_INT(LV_KEYBOARD_MODE_TEXT_LOWER)) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_UPPER), MP_ROM_PTR(MP_ROM_INT(LV_KEYBOARD_MODE_TEXT_UPPER)) },
    { MP_ROM_QSTR(MP_QSTR_SPECIAL), MP_ROM_PTR(MP_ROM_INT(LV_KEYBOARD_MODE_SPECIAL)) },
    { MP_ROM_QSTR(MP_QSTR_NUM), MP_ROM_PTR(MP_ROM_INT(LV_KEYBOARD_MODE_NUM)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_KEYBOARD_MODE_locals_dict, LV_KEYBOARD_MODE_locals_dict_table);

STATIC void LV_KEYBOARD_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_KEYBOARD_MODE");
}



STATIC const mp_obj_type_t mp_LV_KEYBOARD_MODE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_KEYBOARD_MODE,
    .print = LV_KEYBOARD_MODE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_KEYBOARD_MODE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_KEYBOARD_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_KEYBOARD_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BG), MP_ROM_PTR(MP_ROM_INT(LV_KEYBOARD_PART_BG)) },
    { MP_ROM_QSTR(MP_QSTR_BTN), MP_ROM_PTR(MP_ROM_INT(LV_KEYBOARD_PART_BTN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_KEYBOARD_PART_locals_dict, LV_KEYBOARD_PART_locals_dict_table);

STATIC void LV_KEYBOARD_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_KEYBOARD_PART");
}



STATIC const mp_obj_type_t mp_LV_KEYBOARD_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_KEYBOARD_PART,
    .print = LV_KEYBOARD_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_KEYBOARD_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_DROPDOWN_DIR object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DROPDOWN_DIR_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_DOWN), MP_ROM_PTR(MP_ROM_INT(LV_DROPDOWN_DIR_DOWN)) },
    { MP_ROM_QSTR(MP_QSTR_UP), MP_ROM_PTR(MP_ROM_INT(LV_DROPDOWN_DIR_UP)) },
    { MP_ROM_QSTR(MP_QSTR_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_DROPDOWN_DIR_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_DROPDOWN_DIR_RIGHT)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DROPDOWN_DIR_locals_dict, LV_DROPDOWN_DIR_locals_dict_table);

STATIC void LV_DROPDOWN_DIR_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DROPDOWN_DIR");
}



STATIC const mp_obj_type_t mp_LV_DROPDOWN_DIR_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_DROPDOWN_DIR,
    .print = LV_DROPDOWN_DIR_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_DROPDOWN_DIR_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_DROPDOWN_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DROPDOWN_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_MAIN), MP_ROM_PTR(MP_ROM_INT(LV_DROPDOWN_PART_MAIN)) },
    { MP_ROM_QSTR(MP_QSTR_LIST), MP_ROM_PTR(MP_ROM_INT(LV_DROPDOWN_PART_LIST)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLLBAR), MP_ROM_PTR(MP_ROM_INT(LV_DROPDOWN_PART_SCROLLBAR)) },
    { MP_ROM_QSTR(MP_QSTR_SELECTED), MP_ROM_PTR(MP_ROM_INT(LV_DROPDOWN_PART_SELECTED)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DROPDOWN_PART_locals_dict, LV_DROPDOWN_PART_locals_dict_table);

STATIC void LV_DROPDOWN_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DROPDOWN_PART");
}



STATIC const mp_obj_type_t mp_LV_DROPDOWN_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_DROPDOWN_PART,
    .print = LV_DROPDOWN_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_DROPDOWN_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_ROLLER_MODE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_ROLLER_MODE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NORMAL), MP_ROM_PTR(MP_ROM_INT(LV_ROLLER_MODE_NORMAL)) },
    { MP_ROM_QSTR(MP_QSTR_INFINITE), MP_ROM_PTR(MP_ROM_INT(LV_ROLLER_MODE_INFINITE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_ROLLER_MODE_locals_dict, LV_ROLLER_MODE_locals_dict_table);

STATIC void LV_ROLLER_MODE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_ROLLER_MODE");
}



STATIC const mp_obj_type_t mp_LV_ROLLER_MODE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_ROLLER_MODE,
    .print = LV_ROLLER_MODE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_ROLLER_MODE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_ROLLER_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_ROLLER_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BG), MP_ROM_PTR(MP_ROM_INT(LV_ROLLER_PART_BG)) },
    { MP_ROM_QSTR(MP_QSTR_SELECTED), MP_ROM_PTR(MP_ROM_INT(LV_ROLLER_PART_SELECTED)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_ROLLER_PART_locals_dict, LV_ROLLER_PART_locals_dict_table);

STATIC void LV_ROLLER_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_ROLLER_PART");
}



STATIC const mp_obj_type_t mp_LV_ROLLER_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_ROLLER_PART,
    .print = LV_ROLLER_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_ROLLER_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl ENUM_LV_TEXTAREA_CURSOR object definitions
 */
    

STATIC const mp_rom_map_elem_t ENUM_LV_TEXTAREA_CURSOR_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_LAST), MP_ROM_PTR(MP_ROM_INT(ENUM_LV_TEXTAREA_CURSOR_LAST)) }
};

STATIC MP_DEFINE_CONST_DICT(ENUM_LV_TEXTAREA_CURSOR_locals_dict, ENUM_LV_TEXTAREA_CURSOR_locals_dict_table);

STATIC void ENUM_LV_TEXTAREA_CURSOR_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl ENUM_LV_TEXTAREA_CURSOR");
}



STATIC const mp_obj_type_t mp_ENUM_LV_TEXTAREA_CURSOR_type = {
    { &mp_type_type },
    .name = MP_QSTR_ENUM_LV_TEXTAREA_CURSOR,
    .print = ENUM_LV_TEXTAREA_CURSOR_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&ENUM_LV_TEXTAREA_CURSOR_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_TEXTAREA_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_TEXTAREA_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BG), MP_ROM_PTR(MP_ROM_INT(LV_TEXTAREA_PART_BG)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLLBAR), MP_ROM_PTR(MP_ROM_INT(LV_TEXTAREA_PART_SCROLLBAR)) },
    { MP_ROM_QSTR(MP_QSTR_EDGE_FLASH), MP_ROM_PTR(MP_ROM_INT(LV_TEXTAREA_PART_EDGE_FLASH)) },
    { MP_ROM_QSTR(MP_QSTR_CURSOR), MP_ROM_PTR(MP_ROM_INT(LV_TEXTAREA_PART_CURSOR)) },
    { MP_ROM_QSTR(MP_QSTR_PLACEHOLDER), MP_ROM_PTR(MP_ROM_INT(LV_TEXTAREA_PART_PLACEHOLDER)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_TEXTAREA_PART_locals_dict, LV_TEXTAREA_PART_locals_dict_table);

STATIC void LV_TEXTAREA_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_TEXTAREA_PART");
}



STATIC const mp_obj_type_t mp_LV_TEXTAREA_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_TEXTAREA_PART,
    .print = LV_TEXTAREA_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_TEXTAREA_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_CANVAS_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_CANVAS_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_MAIN), MP_ROM_PTR(MP_ROM_INT(LV_CANVAS_PART_MAIN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_CANVAS_PART_locals_dict, LV_CANVAS_PART_locals_dict_table);

STATIC void LV_CANVAS_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_CANVAS_PART");
}



STATIC const mp_obj_type_t mp_LV_CANVAS_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_CANVAS_PART,
    .print = LV_CANVAS_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_CANVAS_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_WIN_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_WIN_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BG), MP_ROM_PTR(MP_ROM_INT(LV_WIN_PART_BG)) },
    { MP_ROM_QSTR(MP_QSTR_HEADER), MP_ROM_PTR(MP_ROM_INT(LV_WIN_PART_HEADER)) },
    { MP_ROM_QSTR(MP_QSTR_CONTENT_SCROLLABLE), MP_ROM_PTR(MP_ROM_INT(LV_WIN_PART_CONTENT_SCROLLABLE)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLLBAR), MP_ROM_PTR(MP_ROM_INT(LV_WIN_PART_SCROLLBAR)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_WIN_PART_locals_dict, LV_WIN_PART_locals_dict_table);

STATIC void LV_WIN_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_WIN_PART");
}



STATIC const mp_obj_type_t mp_LV_WIN_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_WIN_PART,
    .print = LV_WIN_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_WIN_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_TABVIEW_TAB_POS object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_TABVIEW_TAB_POS_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_TABVIEW_TAB_POS_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_TOP), MP_ROM_PTR(MP_ROM_INT(LV_TABVIEW_TAB_POS_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_TABVIEW_TAB_POS_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_TABVIEW_TAB_POS_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_TABVIEW_TAB_POS_RIGHT)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_TABVIEW_TAB_POS_locals_dict, LV_TABVIEW_TAB_POS_locals_dict_table);

STATIC void LV_TABVIEW_TAB_POS_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_TABVIEW_TAB_POS");
}



STATIC const mp_obj_type_t mp_LV_TABVIEW_TAB_POS_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_TABVIEW_TAB_POS,
    .print = LV_TABVIEW_TAB_POS_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_TABVIEW_TAB_POS_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_TABVIEW_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_TABVIEW_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BG), MP_ROM_PTR(MP_ROM_INT(LV_TABVIEW_PART_BG)) },
    { MP_ROM_QSTR(MP_QSTR_BG_SCROLLABLE), MP_ROM_PTR(MP_ROM_INT(LV_TABVIEW_PART_BG_SCROLLABLE)) },
    { MP_ROM_QSTR(MP_QSTR_TAB_BG), MP_ROM_PTR(MP_ROM_INT(LV_TABVIEW_PART_TAB_BG)) },
    { MP_ROM_QSTR(MP_QSTR_TAB_BTN), MP_ROM_PTR(MP_ROM_INT(LV_TABVIEW_PART_TAB_BTN)) },
    { MP_ROM_QSTR(MP_QSTR_INDIC), MP_ROM_PTR(MP_ROM_INT(LV_TABVIEW_PART_INDIC)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_TABVIEW_PART_locals_dict, LV_TABVIEW_PART_locals_dict_table);

STATIC void LV_TABVIEW_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_TABVIEW_PART");
}



STATIC const mp_obj_type_t mp_LV_TABVIEW_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_TABVIEW_PART,
    .print = LV_TABVIEW_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_TABVIEW_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_TILEVIEW_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_TILEVIEW_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BG), MP_ROM_PTR(MP_ROM_INT(LV_TILEVIEW_PART_BG)) },
    { MP_ROM_QSTR(MP_QSTR_SCROLLBAR), MP_ROM_PTR(MP_ROM_INT(LV_TILEVIEW_PART_SCROLLBAR)) },
    { MP_ROM_QSTR(MP_QSTR_EDGE_FLASH), MP_ROM_PTR(MP_ROM_INT(LV_TILEVIEW_PART_EDGE_FLASH)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_TILEVIEW_PART_locals_dict, LV_TILEVIEW_PART_locals_dict_table);

STATIC void LV_TILEVIEW_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_TILEVIEW_PART");
}



STATIC const mp_obj_type_t mp_LV_TILEVIEW_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_TILEVIEW_PART,
    .print = LV_TILEVIEW_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_TILEVIEW_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_MSGBOX_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_MSGBOX_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BG), MP_ROM_PTR(MP_ROM_INT(LV_MSGBOX_PART_BG)) },
    { MP_ROM_QSTR(MP_QSTR_BTN_BG), MP_ROM_PTR(MP_ROM_INT(LV_MSGBOX_PART_BTN_BG)) },
    { MP_ROM_QSTR(MP_QSTR_BTN), MP_ROM_PTR(MP_ROM_INT(LV_MSGBOX_PART_BTN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_MSGBOX_PART_locals_dict, LV_MSGBOX_PART_locals_dict_table);

STATIC void LV_MSGBOX_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_MSGBOX_PART");
}



STATIC const mp_obj_type_t mp_LV_MSGBOX_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_MSGBOX_PART,
    .print = LV_MSGBOX_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_MSGBOX_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_OBJMASK_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_OBJMASK_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_MAIN), MP_ROM_PTR(MP_ROM_INT(LV_OBJMASK_PART_MAIN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_OBJMASK_PART_locals_dict, LV_OBJMASK_PART_locals_dict_table);

STATIC void LV_OBJMASK_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_OBJMASK_PART");
}



STATIC const mp_obj_type_t mp_LV_OBJMASK_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_OBJMASK_PART,
    .print = LV_OBJMASK_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_OBJMASK_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_LINEMETER_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_LINEMETER_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_MAIN), MP_ROM_PTR(MP_ROM_INT(LV_LINEMETER_PART_MAIN)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_LINEMETER_PART_locals_dict, LV_LINEMETER_PART_locals_dict_table);

STATIC void LV_LINEMETER_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_LINEMETER_PART");
}



STATIC const mp_obj_type_t mp_LV_LINEMETER_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_LINEMETER_PART,
    .print = LV_LINEMETER_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_LINEMETER_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_GAUGE_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_GAUGE_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_MAIN), MP_ROM_PTR(MP_ROM_INT(LV_GAUGE_PART_MAIN)) },
    { MP_ROM_QSTR(MP_QSTR_MAJOR), MP_ROM_PTR(MP_ROM_INT(LV_GAUGE_PART_MAJOR)) },
    { MP_ROM_QSTR(MP_QSTR_NEEDLE), MP_ROM_PTR(MP_ROM_INT(LV_GAUGE_PART_NEEDLE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_GAUGE_PART_locals_dict, LV_GAUGE_PART_locals_dict_table);

STATIC void LV_GAUGE_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_GAUGE_PART");
}



STATIC const mp_obj_type_t mp_LV_GAUGE_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_GAUGE_PART,
    .print = LV_GAUGE_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_GAUGE_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_SWITCH_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SWITCH_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BG), MP_ROM_PTR(MP_ROM_INT(LV_SWITCH_PART_BG)) },
    { MP_ROM_QSTR(MP_QSTR_INDIC), MP_ROM_PTR(MP_ROM_INT(LV_SWITCH_PART_INDIC)) },
    { MP_ROM_QSTR(MP_QSTR_KNOB), MP_ROM_PTR(MP_ROM_INT(LV_SWITCH_PART_KNOB)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SWITCH_PART_locals_dict, LV_SWITCH_PART_locals_dict_table);

STATIC void LV_SWITCH_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SWITCH_PART");
}



STATIC const mp_obj_type_t mp_LV_SWITCH_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_SWITCH_PART,
    .print = LV_SWITCH_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_SWITCH_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_ARC_TYPE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_ARC_TYPE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NORMAL), MP_ROM_PTR(MP_ROM_INT(LV_ARC_TYPE_NORMAL)) },
    { MP_ROM_QSTR(MP_QSTR_SYMMETRIC), MP_ROM_PTR(MP_ROM_INT(LV_ARC_TYPE_SYMMETRIC)) },
    { MP_ROM_QSTR(MP_QSTR_REVERSE), MP_ROM_PTR(MP_ROM_INT(LV_ARC_TYPE_REVERSE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_ARC_TYPE_locals_dict, LV_ARC_TYPE_locals_dict_table);

STATIC void LV_ARC_TYPE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_ARC_TYPE");
}



STATIC const mp_obj_type_t mp_LV_ARC_TYPE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_ARC_TYPE,
    .print = LV_ARC_TYPE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_ARC_TYPE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_ARC_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_ARC_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BG), MP_ROM_PTR(MP_ROM_INT(LV_ARC_PART_BG)) },
    { MP_ROM_QSTR(MP_QSTR_INDIC), MP_ROM_PTR(MP_ROM_INT(LV_ARC_PART_INDIC)) },
    { MP_ROM_QSTR(MP_QSTR_KNOB), MP_ROM_PTR(MP_ROM_INT(LV_ARC_PART_KNOB)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_ARC_PART_locals_dict, LV_ARC_PART_locals_dict_table);

STATIC void LV_ARC_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_ARC_PART");
}



STATIC const mp_obj_type_t mp_LV_ARC_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_ARC_PART,
    .print = LV_ARC_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_ARC_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_SPINNER_TYPE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SPINNER_TYPE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SPINNING_ARC), MP_ROM_PTR(MP_ROM_INT(LV_SPINNER_TYPE_SPINNING_ARC)) },
    { MP_ROM_QSTR(MP_QSTR_FILLSPIN_ARC), MP_ROM_PTR(MP_ROM_INT(LV_SPINNER_TYPE_FILLSPIN_ARC)) },
    { MP_ROM_QSTR(MP_QSTR_CONSTANT_ARC), MP_ROM_PTR(MP_ROM_INT(LV_SPINNER_TYPE_CONSTANT_ARC)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SPINNER_TYPE_locals_dict, LV_SPINNER_TYPE_locals_dict_table);

STATIC void LV_SPINNER_TYPE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SPINNER_TYPE");
}



STATIC const mp_obj_type_t mp_LV_SPINNER_TYPE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_SPINNER_TYPE,
    .print = LV_SPINNER_TYPE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_SPINNER_TYPE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_SPINNER_DIR object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SPINNER_DIR_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_FORWARD), MP_ROM_PTR(MP_ROM_INT(LV_SPINNER_DIR_FORWARD)) },
    { MP_ROM_QSTR(MP_QSTR_BACKWARD), MP_ROM_PTR(MP_ROM_INT(LV_SPINNER_DIR_BACKWARD)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SPINNER_DIR_locals_dict, LV_SPINNER_DIR_locals_dict_table);

STATIC void LV_SPINNER_DIR_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SPINNER_DIR");
}



STATIC const mp_obj_type_t mp_LV_SPINNER_DIR_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_SPINNER_DIR,
    .print = LV_SPINNER_DIR_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_SPINNER_DIR_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_SPINNER_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SPINNER_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BG), MP_ROM_PTR(MP_ROM_INT(LV_SPINNER_PART_BG)) },
    { MP_ROM_QSTR(MP_QSTR_INDIC), MP_ROM_PTR(MP_ROM_INT(LV_SPINNER_PART_INDIC)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SPINNER_PART_locals_dict, LV_SPINNER_PART_locals_dict_table);

STATIC void LV_SPINNER_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SPINNER_PART");
}



STATIC const mp_obj_type_t mp_LV_SPINNER_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_SPINNER_PART,
    .print = LV_SPINNER_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_SPINNER_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_CALENDAR_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_CALENDAR_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BG), MP_ROM_PTR(MP_ROM_INT(LV_CALENDAR_PART_BG)) },
    { MP_ROM_QSTR(MP_QSTR_HEADER), MP_ROM_PTR(MP_ROM_INT(LV_CALENDAR_PART_HEADER)) },
    { MP_ROM_QSTR(MP_QSTR_DAY_NAMES), MP_ROM_PTR(MP_ROM_INT(LV_CALENDAR_PART_DAY_NAMES)) },
    { MP_ROM_QSTR(MP_QSTR_DATE), MP_ROM_PTR(MP_ROM_INT(LV_CALENDAR_PART_DATE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_CALENDAR_PART_locals_dict, LV_CALENDAR_PART_locals_dict_table);

STATIC void LV_CALENDAR_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_CALENDAR_PART");
}



STATIC const mp_obj_type_t mp_LV_CALENDAR_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_CALENDAR_PART,
    .print = LV_CALENDAR_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_CALENDAR_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_SPINBOX_PART object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SPINBOX_PART_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_BG), MP_ROM_PTR(MP_ROM_INT(LV_SPINBOX_PART_BG)) },
    { MP_ROM_QSTR(MP_QSTR_CURSOR), MP_ROM_PTR(MP_ROM_INT(LV_SPINBOX_PART_CURSOR)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SPINBOX_PART_locals_dict, LV_SPINBOX_PART_locals_dict_table);

STATIC void LV_SPINBOX_PART_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SPINBOX_PART");
}



STATIC const mp_obj_type_t mp_LV_SPINBOX_PART_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_SPINBOX_PART,
    .print = LV_SPINBOX_PART_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_SPINBOX_PART_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_DISP_SIZE object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_DISP_SIZE_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SMALL), MP_ROM_PTR(MP_ROM_INT(LV_DISP_SIZE_SMALL)) },
    { MP_ROM_QSTR(MP_QSTR_MEDIUM), MP_ROM_PTR(MP_ROM_INT(LV_DISP_SIZE_MEDIUM)) },
    { MP_ROM_QSTR(MP_QSTR_LARGE), MP_ROM_PTR(MP_ROM_INT(LV_DISP_SIZE_LARGE)) },
    { MP_ROM_QSTR(MP_QSTR_EXTRA_LARGE), MP_ROM_PTR(MP_ROM_INT(LV_DISP_SIZE_EXTRA_LARGE)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_DISP_SIZE_locals_dict, LV_DISP_SIZE_locals_dict_table);

STATIC void LV_DISP_SIZE_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_DISP_SIZE");
}



STATIC const mp_obj_type_t mp_LV_DISP_SIZE_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_DISP_SIZE,
    .print = LV_DISP_SIZE_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_DISP_SIZE_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_SCR_LOAD_ANIM object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SCR_LOAD_ANIM_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_OVER_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_OVER_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_OVER_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_OVER_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_OVER_TOP), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_OVER_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_OVER_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_OVER_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_MOVE_LEFT), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_MOVE_LEFT)) },
    { MP_ROM_QSTR(MP_QSTR_MOVE_RIGHT), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_MOVE_RIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_MOVE_TOP), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_MOVE_TOP)) },
    { MP_ROM_QSTR(MP_QSTR_MOVE_BOTTOM), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_MOVE_BOTTOM)) },
    { MP_ROM_QSTR(MP_QSTR_FADE_ON), MP_ROM_PTR(MP_ROM_INT(LV_SCR_LOAD_ANIM_FADE_ON)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SCR_LOAD_ANIM_locals_dict, LV_SCR_LOAD_ANIM_locals_dict_table);

STATIC void LV_SCR_LOAD_ANIM_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SCR_LOAD_ANIM");
}



STATIC const mp_obj_type_t mp_LV_SCR_LOAD_ANIM_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_SCR_LOAD_ANIM,
    .print = LV_SCR_LOAD_ANIM_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_SCR_LOAD_ANIM_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_THEME object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_THEME_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_NONE), MP_ROM_PTR(MP_ROM_INT(LV_THEME_NONE)) },
    { MP_ROM_QSTR(MP_QSTR_SCR), MP_ROM_PTR(MP_ROM_INT(LV_THEME_SCR)) },
    { MP_ROM_QSTR(MP_QSTR_OBJ), MP_ROM_PTR(MP_ROM_INT(LV_THEME_OBJ)) },
    { MP_ROM_QSTR(MP_QSTR_ARC), MP_ROM_PTR(MP_ROM_INT(LV_THEME_ARC)) },
    { MP_ROM_QSTR(MP_QSTR_BAR), MP_ROM_PTR(MP_ROM_INT(LV_THEME_BAR)) },
    { MP_ROM_QSTR(MP_QSTR_BTN), MP_ROM_PTR(MP_ROM_INT(LV_THEME_BTN)) },
    { MP_ROM_QSTR(MP_QSTR_BTNMATRIX), MP_ROM_PTR(MP_ROM_INT(LV_THEME_BTNMATRIX)) },
    { MP_ROM_QSTR(MP_QSTR_CALENDAR), MP_ROM_PTR(MP_ROM_INT(LV_THEME_CALENDAR)) },
    { MP_ROM_QSTR(MP_QSTR_CANVAS), MP_ROM_PTR(MP_ROM_INT(LV_THEME_CANVAS)) },
    { MP_ROM_QSTR(MP_QSTR_CHECKBOX), MP_ROM_PTR(MP_ROM_INT(LV_THEME_CHECKBOX)) },
    { MP_ROM_QSTR(MP_QSTR_CHART), MP_ROM_PTR(MP_ROM_INT(LV_THEME_CHART)) },
    { MP_ROM_QSTR(MP_QSTR_CONT), MP_ROM_PTR(MP_ROM_INT(LV_THEME_CONT)) },
    { MP_ROM_QSTR(MP_QSTR_CPICKER), MP_ROM_PTR(MP_ROM_INT(LV_THEME_CPICKER)) },
    { MP_ROM_QSTR(MP_QSTR_DROPDOWN), MP_ROM_PTR(MP_ROM_INT(LV_THEME_DROPDOWN)) },
    { MP_ROM_QSTR(MP_QSTR_GAUGE), MP_ROM_PTR(MP_ROM_INT(LV_THEME_GAUGE)) },
    { MP_ROM_QSTR(MP_QSTR_IMAGE), MP_ROM_PTR(MP_ROM_INT(LV_THEME_IMAGE)) },
    { MP_ROM_QSTR(MP_QSTR_IMGBTN), MP_ROM_PTR(MP_ROM_INT(LV_THEME_IMGBTN)) },
    { MP_ROM_QSTR(MP_QSTR_KEYBOARD), MP_ROM_PTR(MP_ROM_INT(LV_THEME_KEYBOARD)) },
    { MP_ROM_QSTR(MP_QSTR_LABEL), MP_ROM_PTR(MP_ROM_INT(LV_THEME_LABEL)) },
    { MP_ROM_QSTR(MP_QSTR_LED), MP_ROM_PTR(MP_ROM_INT(LV_THEME_LED)) },
    { MP_ROM_QSTR(MP_QSTR_LINE), MP_ROM_PTR(MP_ROM_INT(LV_THEME_LINE)) },
    { MP_ROM_QSTR(MP_QSTR_LIST), MP_ROM_PTR(MP_ROM_INT(LV_THEME_LIST)) },
    { MP_ROM_QSTR(MP_QSTR_LIST_BTN), MP_ROM_PTR(MP_ROM_INT(LV_THEME_LIST_BTN)) },
    { MP_ROM_QSTR(MP_QSTR_LINEMETER), MP_ROM_PTR(MP_ROM_INT(LV_THEME_LINEMETER)) },
    { MP_ROM_QSTR(MP_QSTR_MSGBOX), MP_ROM_PTR(MP_ROM_INT(LV_THEME_MSGBOX)) },
    { MP_ROM_QSTR(MP_QSTR_MSGBOX_BTNS), MP_ROM_PTR(MP_ROM_INT(LV_THEME_MSGBOX_BTNS)) },
    { MP_ROM_QSTR(MP_QSTR_OBJMASK), MP_ROM_PTR(MP_ROM_INT(LV_THEME_OBJMASK)) },
    { MP_ROM_QSTR(MP_QSTR_PAGE), MP_ROM_PTR(MP_ROM_INT(LV_THEME_PAGE)) },
    { MP_ROM_QSTR(MP_QSTR_ROLLER), MP_ROM_PTR(MP_ROM_INT(LV_THEME_ROLLER)) },
    { MP_ROM_QSTR(MP_QSTR_SLIDER), MP_ROM_PTR(MP_ROM_INT(LV_THEME_SLIDER)) },
    { MP_ROM_QSTR(MP_QSTR_SPINBOX), MP_ROM_PTR(MP_ROM_INT(LV_THEME_SPINBOX)) },
    { MP_ROM_QSTR(MP_QSTR_SPINBOX_BTN), MP_ROM_PTR(MP_ROM_INT(LV_THEME_SPINBOX_BTN)) },
    { MP_ROM_QSTR(MP_QSTR_SPINNER), MP_ROM_PTR(MP_ROM_INT(LV_THEME_SPINNER)) },
    { MP_ROM_QSTR(MP_QSTR_SWITCH), MP_ROM_PTR(MP_ROM_INT(LV_THEME_SWITCH)) },
    { MP_ROM_QSTR(MP_QSTR_TABLE), MP_ROM_PTR(MP_ROM_INT(LV_THEME_TABLE)) },
    { MP_ROM_QSTR(MP_QSTR_TABVIEW), MP_ROM_PTR(MP_ROM_INT(LV_THEME_TABVIEW)) },
    { MP_ROM_QSTR(MP_QSTR_TABVIEW_PAGE), MP_ROM_PTR(MP_ROM_INT(LV_THEME_TABVIEW_PAGE)) },
    { MP_ROM_QSTR(MP_QSTR_TEXTAREA), MP_ROM_PTR(MP_ROM_INT(LV_THEME_TEXTAREA)) },
    { MP_ROM_QSTR(MP_QSTR_TILEVIEW), MP_ROM_PTR(MP_ROM_INT(LV_THEME_TILEVIEW)) },
    { MP_ROM_QSTR(MP_QSTR_WIN), MP_ROM_PTR(MP_ROM_INT(LV_THEME_WIN)) },
    { MP_ROM_QSTR(MP_QSTR_WIN_BTN), MP_ROM_PTR(MP_ROM_INT(LV_THEME_WIN_BTN)) },
    { MP_ROM_QSTR(MP_QSTR_CUSTOM_START), MP_ROM_PTR(MP_ROM_INT(LV_THEME_CUSTOM_START)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_THEME_locals_dict, LV_THEME_locals_dict_table);

STATIC void LV_THEME_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_THEME");
}



STATIC const mp_obj_type_t mp_LV_THEME_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_THEME,
    .print = LV_THEME_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_THEME_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_THEME_MATERIAL_FLAG object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_THEME_MATERIAL_FLAG_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_DARK), MP_ROM_PTR(MP_ROM_INT(LV_THEME_MATERIAL_FLAG_DARK)) },
    { MP_ROM_QSTR(MP_QSTR_LIGHT), MP_ROM_PTR(MP_ROM_INT(LV_THEME_MATERIAL_FLAG_LIGHT)) },
    { MP_ROM_QSTR(MP_QSTR_NO_TRANSITION), MP_ROM_PTR(MP_ROM_INT(LV_THEME_MATERIAL_FLAG_NO_TRANSITION)) },
    { MP_ROM_QSTR(MP_QSTR_NO_FOCUS), MP_ROM_PTR(MP_ROM_INT(LV_THEME_MATERIAL_FLAG_NO_FOCUS)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_THEME_MATERIAL_FLAG_locals_dict, LV_THEME_MATERIAL_FLAG_locals_dict_table);

STATIC void LV_THEME_MATERIAL_FLAG_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_THEME_MATERIAL_FLAG");
}



STATIC const mp_obj_type_t mp_LV_THEME_MATERIAL_FLAG_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_THEME_MATERIAL_FLAG,
    .print = LV_THEME_MATERIAL_FLAG_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_THEME_MATERIAL_FLAG_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_FONT_FMT_TXT object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_FONT_FMT_TXT_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_PLAIN), MP_ROM_PTR(MP_ROM_INT(LV_FONT_FMT_TXT_PLAIN)) },
    { MP_ROM_QSTR(MP_QSTR_COMPRESSED), MP_ROM_PTR(MP_ROM_INT(LV_FONT_FMT_TXT_COMPRESSED)) },
    { MP_ROM_QSTR(MP_QSTR_COMPRESSED_NO_PREFILTER), MP_ROM_PTR(MP_ROM_INT(LV_FONT_FMT_TXT_COMPRESSED_NO_PREFILTER)) }
};

STATIC MP_DEFINE_CONST_DICT(LV_FONT_FMT_TXT_locals_dict, LV_FONT_FMT_TXT_locals_dict_table);

STATIC void LV_FONT_FMT_TXT_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_FONT_FMT_TXT");
}



STATIC const mp_obj_type_t mp_LV_FONT_FMT_TXT_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_FONT_FMT_TXT,
    .print = LV_FONT_FMT_TXT_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_FONT_FMT_TXT_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl LV_SYMBOL object definitions
 */
    

STATIC const mp_rom_map_elem_t LV_SYMBOL_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_AUDIO), MP_ROM_PTR(&mp_LV_SYMBOL_AUDIO) },
    { MP_ROM_QSTR(MP_QSTR_VIDEO), MP_ROM_PTR(&mp_LV_SYMBOL_VIDEO) },
    { MP_ROM_QSTR(MP_QSTR_LIST), MP_ROM_PTR(&mp_LV_SYMBOL_LIST) },
    { MP_ROM_QSTR(MP_QSTR_OK), MP_ROM_PTR(&mp_LV_SYMBOL_OK) },
    { MP_ROM_QSTR(MP_QSTR_CLOSE), MP_ROM_PTR(&mp_LV_SYMBOL_CLOSE) },
    { MP_ROM_QSTR(MP_QSTR_POWER), MP_ROM_PTR(&mp_LV_SYMBOL_POWER) },
    { MP_ROM_QSTR(MP_QSTR_SETTINGS), MP_ROM_PTR(&mp_LV_SYMBOL_SETTINGS) },
    { MP_ROM_QSTR(MP_QSTR_HOME), MP_ROM_PTR(&mp_LV_SYMBOL_HOME) },
    { MP_ROM_QSTR(MP_QSTR_DOWNLOAD), MP_ROM_PTR(&mp_LV_SYMBOL_DOWNLOAD) },
    { MP_ROM_QSTR(MP_QSTR_DRIVE), MP_ROM_PTR(&mp_LV_SYMBOL_DRIVE) },
    { MP_ROM_QSTR(MP_QSTR_REFRESH), MP_ROM_PTR(&mp_LV_SYMBOL_REFRESH) },
    { MP_ROM_QSTR(MP_QSTR_MUTE), MP_ROM_PTR(&mp_LV_SYMBOL_MUTE) },
    { MP_ROM_QSTR(MP_QSTR_VOLUME_MID), MP_ROM_PTR(&mp_LV_SYMBOL_VOLUME_MID) },
    { MP_ROM_QSTR(MP_QSTR_VOLUME_MAX), MP_ROM_PTR(&mp_LV_SYMBOL_VOLUME_MAX) },
    { MP_ROM_QSTR(MP_QSTR_IMAGE), MP_ROM_PTR(&mp_LV_SYMBOL_IMAGE) },
    { MP_ROM_QSTR(MP_QSTR_EDIT), MP_ROM_PTR(&mp_LV_SYMBOL_EDIT) },
    { MP_ROM_QSTR(MP_QSTR_PREV), MP_ROM_PTR(&mp_LV_SYMBOL_PREV) },
    { MP_ROM_QSTR(MP_QSTR_PLAY), MP_ROM_PTR(&mp_LV_SYMBOL_PLAY) },
    { MP_ROM_QSTR(MP_QSTR_PAUSE), MP_ROM_PTR(&mp_LV_SYMBOL_PAUSE) },
    { MP_ROM_QSTR(MP_QSTR_STOP), MP_ROM_PTR(&mp_LV_SYMBOL_STOP) },
    { MP_ROM_QSTR(MP_QSTR_NEXT), MP_ROM_PTR(&mp_LV_SYMBOL_NEXT) },
    { MP_ROM_QSTR(MP_QSTR_EJECT), MP_ROM_PTR(&mp_LV_SYMBOL_EJECT) },
    { MP_ROM_QSTR(MP_QSTR_LEFT), MP_ROM_PTR(&mp_LV_SYMBOL_LEFT) },
    { MP_ROM_QSTR(MP_QSTR_RIGHT), MP_ROM_PTR(&mp_LV_SYMBOL_RIGHT) },
    { MP_ROM_QSTR(MP_QSTR_PLUS), MP_ROM_PTR(&mp_LV_SYMBOL_PLUS) },
    { MP_ROM_QSTR(MP_QSTR_MINUS), MP_ROM_PTR(&mp_LV_SYMBOL_MINUS) },
    { MP_ROM_QSTR(MP_QSTR_EYE_OPEN), MP_ROM_PTR(&mp_LV_SYMBOL_EYE_OPEN) },
    { MP_ROM_QSTR(MP_QSTR_EYE_CLOSE), MP_ROM_PTR(&mp_LV_SYMBOL_EYE_CLOSE) },
    { MP_ROM_QSTR(MP_QSTR_WARNING), MP_ROM_PTR(&mp_LV_SYMBOL_WARNING) },
    { MP_ROM_QSTR(MP_QSTR_SHUFFLE), MP_ROM_PTR(&mp_LV_SYMBOL_SHUFFLE) },
    { MP_ROM_QSTR(MP_QSTR_UP), MP_ROM_PTR(&mp_LV_SYMBOL_UP) },
    { MP_ROM_QSTR(MP_QSTR_DOWN), MP_ROM_PTR(&mp_LV_SYMBOL_DOWN) },
    { MP_ROM_QSTR(MP_QSTR_LOOP), MP_ROM_PTR(&mp_LV_SYMBOL_LOOP) },
    { MP_ROM_QSTR(MP_QSTR_DIRECTORY), MP_ROM_PTR(&mp_LV_SYMBOL_DIRECTORY) },
    { MP_ROM_QSTR(MP_QSTR_UPLOAD), MP_ROM_PTR(&mp_LV_SYMBOL_UPLOAD) },
    { MP_ROM_QSTR(MP_QSTR_CALL), MP_ROM_PTR(&mp_LV_SYMBOL_CALL) },
    { MP_ROM_QSTR(MP_QSTR_CUT), MP_ROM_PTR(&mp_LV_SYMBOL_CUT) },
    { MP_ROM_QSTR(MP_QSTR_COPY), MP_ROM_PTR(&mp_LV_SYMBOL_COPY) },
    { MP_ROM_QSTR(MP_QSTR_SAVE), MP_ROM_PTR(&mp_LV_SYMBOL_SAVE) },
    { MP_ROM_QSTR(MP_QSTR_CHARGE), MP_ROM_PTR(&mp_LV_SYMBOL_CHARGE) },
    { MP_ROM_QSTR(MP_QSTR_PASTE), MP_ROM_PTR(&mp_LV_SYMBOL_PASTE) },
    { MP_ROM_QSTR(MP_QSTR_BELL), MP_ROM_PTR(&mp_LV_SYMBOL_BELL) },
    { MP_ROM_QSTR(MP_QSTR_KEYBOARD), MP_ROM_PTR(&mp_LV_SYMBOL_KEYBOARD) },
    { MP_ROM_QSTR(MP_QSTR_GPS), MP_ROM_PTR(&mp_LV_SYMBOL_GPS) },
    { MP_ROM_QSTR(MP_QSTR_FILE), MP_ROM_PTR(&mp_LV_SYMBOL_FILE) },
    { MP_ROM_QSTR(MP_QSTR_WIFI), MP_ROM_PTR(&mp_LV_SYMBOL_WIFI) },
    { MP_ROM_QSTR(MP_QSTR_BATTERY_FULL), MP_ROM_PTR(&mp_LV_SYMBOL_BATTERY_FULL) },
    { MP_ROM_QSTR(MP_QSTR_BATTERY_3), MP_ROM_PTR(&mp_LV_SYMBOL_BATTERY_3) },
    { MP_ROM_QSTR(MP_QSTR_BATTERY_2), MP_ROM_PTR(&mp_LV_SYMBOL_BATTERY_2) },
    { MP_ROM_QSTR(MP_QSTR_BATTERY_1), MP_ROM_PTR(&mp_LV_SYMBOL_BATTERY_1) },
    { MP_ROM_QSTR(MP_QSTR_BATTERY_EMPTY), MP_ROM_PTR(&mp_LV_SYMBOL_BATTERY_EMPTY) },
    { MP_ROM_QSTR(MP_QSTR_USB), MP_ROM_PTR(&mp_LV_SYMBOL_USB) },
    { MP_ROM_QSTR(MP_QSTR_BLUETOOTH), MP_ROM_PTR(&mp_LV_SYMBOL_BLUETOOTH) },
    { MP_ROM_QSTR(MP_QSTR_TRASH), MP_ROM_PTR(&mp_LV_SYMBOL_TRASH) },
    { MP_ROM_QSTR(MP_QSTR_BACKSPACE), MP_ROM_PTR(&mp_LV_SYMBOL_BACKSPACE) },
    { MP_ROM_QSTR(MP_QSTR_SD_CARD), MP_ROM_PTR(&mp_LV_SYMBOL_SD_CARD) },
    { MP_ROM_QSTR(MP_QSTR_NEW_LINE), MP_ROM_PTR(&mp_LV_SYMBOL_NEW_LINE) },
    { MP_ROM_QSTR(MP_QSTR_DUMMY), MP_ROM_PTR(&mp_LV_SYMBOL_DUMMY) }
};

STATIC MP_DEFINE_CONST_DICT(LV_SYMBOL_locals_dict, LV_SYMBOL_locals_dict_table);

STATIC void LV_SYMBOL_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl LV_SYMBOL");
}



STATIC const mp_obj_type_t mp_LV_SYMBOL_type = {
    { &mp_type_type },
    .name = MP_QSTR_LV_SYMBOL,
    .print = LV_SYMBOL_print,
    
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&LV_SYMBOL_locals_dict,
    
    .parent = NULL,
};
    

/*
 * lvgl extension definition for:
 * inline static lv_style_int_t lv_obj_get_style_radius(const lv_obj_t *obj, uint8_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_radius(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_int_t _res = ((lv_style_int_t (*)(const lv_obj_t *, uint8_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_radius_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_radius);
    

/*
 * lvgl extension definition for:
 * inline static void lv_obj_set_style_local_radius(lv_obj_t *obj, uint8_t part, lv_state_t state, lv_style_int_t value)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_local_radius(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_style_int_t value = (int16_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, uint8_t, lv_state_t, lv_style_int_t))lv_func_ptr)(obj, part, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_radius_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_radius);
    

/*
 * lvgl extension definition for:
 * inline static bool lv_obj_get_style_clip_corner(const lv_obj_t *obj, uint8_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_clip_corner(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    bool _res = ((bool (*)(const lv_obj_t *, uint8_t))lv_func_ptr)(obj, part);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_clip_corner_obj, 2, mp_lv_obj_get_style_clip_corner, lv_obj_get_style_clip_corner);
    

/*
 * lvgl extension definition for:
 * inline static void lv_obj_set_style_local_clip_corner(lv_obj_t *obj, uint8_t part, lv_state_t state, bool value)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_local_clip_corner(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[2]);
    bool value = mp_obj_is_true(mp_args[3]);
    ((void (*)(lv_obj_t *, uint8_t, lv_state_t, bool))lv_func_ptr)(obj, part, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_clip_corner_obj, 4, mp_lv_obj_set_style_local_clip_corner, lv_obj_set_style_local_clip_corner);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_size */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_size_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_size);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_size */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_size_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_size);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_transform_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transform_width_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_transform_width);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_transform_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_transform_width_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_transform_width);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_transform_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transform_height_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_transform_height);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_transform_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_transform_height_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_transform_height);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_transform_angle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transform_angle_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_transform_angle);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_transform_angle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_transform_angle_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_transform_angle);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_transform_zoom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transform_zoom_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_transform_zoom);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_transform_zoom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_transform_zoom_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_transform_zoom);
    

/*
 * lvgl extension definition for:
 * inline static lv_opa_t lv_obj_get_style_opa_scale(const lv_obj_t *obj, uint8_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_opa_scale(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_opa_t _res = ((lv_opa_t (*)(const lv_obj_t *, uint8_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_opa_scale_obj, 2, mp_lv_obj_get_style_opa_scale, lv_obj_get_style_opa_scale);
    

/*
 * lvgl extension definition for:
 * inline static void lv_obj_set_style_local_opa_scale(lv_obj_t *obj, uint8_t part, lv_state_t state, lv_opa_t value)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_local_opa_scale(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_opa_t value = (uint8_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, uint8_t, lv_state_t, lv_opa_t))lv_func_ptr)(obj, part, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_opa_scale_obj, 4, mp_lv_obj_set_style_local_opa_scale, lv_obj_set_style_local_opa_scale);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_pad_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_pad_top_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_pad_top);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_pad_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_pad_top_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_pad_top);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_pad_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_pad_bottom_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_pad_bottom);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_pad_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_pad_bottom_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_pad_bottom);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_pad_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_pad_left_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_pad_left);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_pad_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_pad_left_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_pad_left);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_pad_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_pad_right_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_pad_right);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_pad_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_pad_right_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_pad_right);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_pad_inner */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_pad_inner_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_pad_inner);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_pad_inner */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_pad_inner_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_pad_inner);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_margin_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_margin_top_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_margin_top);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_margin_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_margin_top_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_margin_top);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_margin_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_margin_bottom_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_margin_bottom);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_margin_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_margin_bottom_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_margin_bottom);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_margin_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_margin_left_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_margin_left);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_margin_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_margin_left_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_margin_left);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_margin_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_margin_right_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_margin_right);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_margin_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_margin_right_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_margin_right);
    

/*
 * lvgl extension definition for:
 * inline static lv_blend_mode_t lv_obj_get_style_bg_blend_mode(const lv_obj_t *obj, uint8_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_bg_blend_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_blend_mode_t _res = ((lv_blend_mode_t (*)(const lv_obj_t *, uint8_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_blend_mode_obj, 2, mp_lv_obj_get_style_bg_blend_mode, lv_obj_get_style_bg_blend_mode);
    

/*
 * lvgl extension definition for:
 * inline static void lv_obj_set_style_local_bg_blend_mode(lv_obj_t *obj, uint8_t part, lv_state_t state, lv_blend_mode_t value)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_local_bg_blend_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_blend_mode_t value = (uint8_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, uint8_t, lv_state_t, lv_blend_mode_t))lv_func_ptr)(obj, part, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_bg_blend_mode_obj, 4, mp_lv_obj_set_style_local_bg_blend_mode, lv_obj_set_style_local_bg_blend_mode);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_bg_main_stop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_main_stop_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_bg_main_stop);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_bg_main_stop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_bg_main_stop_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_bg_main_stop);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_bg_grad_stop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_grad_stop_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_bg_grad_stop);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_bg_grad_stop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_bg_grad_stop_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_bg_grad_stop);
    

/*
 * lvgl extension definition for:
 * inline static lv_grad_dir_t lv_obj_get_style_bg_grad_dir(const lv_obj_t *obj, uint8_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_bg_grad_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_grad_dir_t _res = ((lv_grad_dir_t (*)(const lv_obj_t *, uint8_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_grad_dir_obj, 2, mp_lv_obj_get_style_bg_grad_dir, lv_obj_get_style_bg_grad_dir);
    

/*
 * lvgl extension definition for:
 * inline static void lv_obj_set_style_local_bg_grad_dir(lv_obj_t *obj, uint8_t part, lv_state_t state, lv_grad_dir_t value)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_local_bg_grad_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_grad_dir_t value = (uint8_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, uint8_t, lv_state_t, lv_grad_dir_t))lv_func_ptr)(obj, part, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_bg_grad_dir_obj, 4, mp_lv_obj_set_style_local_bg_grad_dir, lv_obj_set_style_local_bg_grad_dir);
    
typedef __typeof__( ((lv_color32_t*)(0))->ch ) lv_color32_ch_t;

/*
 * Struct lv_color32_ch_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_color32_ch_t_type();

STATIC inline lv_color32_ch_t* mp_write_ptr_lv_color32_ch_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_color32_ch_t_type()));
    return (lv_color32_ch_t*)self->data;
}

#define mp_write_lv_color32_ch_t(struct_obj) *mp_write_ptr_lv_color32_ch_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_color32_ch_t(lv_color32_ch_t *field)
{
    return lv_to_mp_struct(get_mp_lv_color32_ch_t_type(), (void*)field);
}

#define mp_read_lv_color32_ch_t(field) mp_read_ptr_lv_color32_ch_t(copy_buffer(&field, sizeof(lv_color32_ch_t)))
#define mp_read_byref_lv_color32_ch_t(field) mp_read_ptr_lv_color32_ch_t(&field)

STATIC void mp_lv_color32_ch_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_color32_ch_t *data = (lv_color32_ch_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_blue: dest[0] = mp_obj_new_int_from_uint(data->blue); break; // converting from uint8_t;
            case MP_QSTR_green: dest[0] = mp_obj_new_int_from_uint(data->green); break; // converting from uint8_t;
            case MP_QSTR_red: dest[0] = mp_obj_new_int_from_uint(data->red); break; // converting from uint8_t;
            case MP_QSTR_alpha: dest[0] = mp_obj_new_int_from_uint(data->alpha); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_blue: data->blue = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_green: data->green = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_red: data->red = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_alpha: data->alpha = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_color32_ch_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_color32_ch_t");
}

STATIC const mp_obj_dict_t mp_lv_color32_ch_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_color32_ch_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_color32_ch_t,
    .print = mp_lv_color32_ch_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_color32_ch_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_color32_ch_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_color32_ch_t_type()
{
    return &mp_lv_color32_ch_t_type;
}
    

/*
 * Struct lv_color32_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_color32_t_type();

STATIC inline lv_color32_t* mp_write_ptr_lv_color32_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_color32_t_type()));
    return (lv_color32_t*)self->data;
}

#define mp_write_lv_color32_t(struct_obj) *mp_write_ptr_lv_color32_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_color32_t(lv_color32_t *field)
{
    return lv_to_mp_struct(get_mp_lv_color32_t_type(), (void*)field);
}

#define mp_read_lv_color32_t(field) mp_read_ptr_lv_color32_t(copy_buffer(&field, sizeof(lv_color32_t)))
#define mp_read_byref_lv_color32_t(field) mp_read_ptr_lv_color32_t(&field)

STATIC void mp_lv_color32_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_color32_t *data = (lv_color32_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_ch: dest[0] = mp_read_byref_lv_color32_ch_t(data->ch); break; // converting from lv_color32_ch_t;
            case MP_QSTR_full: dest[0] = mp_obj_new_int_from_uint(data->full); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_ch: data->ch = mp_write_lv_color32_ch_t(dest[1]); break; // converting to lv_color32_ch_t;
                case MP_QSTR_full: data->full = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_color32_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_color32_t");
}

STATIC const mp_obj_dict_t mp_lv_color32_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_color32_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_color32_t,
    .print = mp_lv_color32_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_color32_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_color32_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_color32_t_type()
{
    return &mp_lv_color32_t_type;
}
    

/*
 * lvgl extension definition for:
 * inline static lv_color_t lv_obj_get_style_bg_color(const lv_obj_t *obj, uint8_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_bg_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_color_t _res = ((lv_color_t (*)(const lv_obj_t *, uint8_t))lv_func_ptr)(obj, part);
    return mp_read_lv_color32_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_color_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_bg_color);
    

/*
 * lvgl extension definition for:
 * inline static void lv_obj_set_style_local_bg_color(lv_obj_t *obj, uint8_t part, lv_state_t state, lv_color_t value)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_local_bg_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_color_t value = mp_write_lv_color32_t(mp_args[3]);
    ((void (*)(lv_obj_t *, uint8_t, lv_state_t, lv_color_t))lv_func_ptr)(obj, part, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_bg_color_obj, 4, mp_lv_obj_set_style_local_bg_color, lv_obj_set_style_local_bg_color);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_bg_grad_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_grad_color_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_bg_grad_color);
    
/* Reusing lv_obj_set_style_local_bg_color for lv_obj_set_style_local_bg_grad_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_bg_grad_color_obj, 4, mp_lv_obj_set_style_local_bg_color, lv_obj_set_style_local_bg_grad_color);
    
/* Reusing lv_obj_get_style_opa_scale for lv_obj_get_style_bg_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_bg_opa_obj, 2, mp_lv_obj_get_style_opa_scale, lv_obj_get_style_bg_opa);
    
/* Reusing lv_obj_set_style_local_opa_scale for lv_obj_set_style_local_bg_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_bg_opa_obj, 4, mp_lv_obj_set_style_local_opa_scale, lv_obj_set_style_local_bg_opa);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_border_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_border_width_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_border_width);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_border_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_border_width_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_border_width);
    

/*
 * lvgl extension definition for:
 * inline static lv_border_side_t lv_obj_get_style_border_side(const lv_obj_t *obj, uint8_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_border_side(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_border_side_t _res = ((lv_border_side_t (*)(const lv_obj_t *, uint8_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_border_side_obj, 2, mp_lv_obj_get_style_border_side, lv_obj_get_style_border_side);
    

/*
 * lvgl extension definition for:
 * inline static void lv_obj_set_style_local_border_side(lv_obj_t *obj, uint8_t part, lv_state_t state, lv_border_side_t value)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_local_border_side(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_border_side_t value = (uint8_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, uint8_t, lv_state_t, lv_border_side_t))lv_func_ptr)(obj, part, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_border_side_obj, 4, mp_lv_obj_set_style_local_border_side, lv_obj_set_style_local_border_side);
    
/* Reusing lv_obj_get_style_bg_blend_mode for lv_obj_get_style_border_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_border_blend_mode_obj, 2, mp_lv_obj_get_style_bg_blend_mode, lv_obj_get_style_border_blend_mode);
    
/* Reusing lv_obj_set_style_local_bg_blend_mode for lv_obj_set_style_local_border_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_border_blend_mode_obj, 4, mp_lv_obj_set_style_local_bg_blend_mode, lv_obj_set_style_local_border_blend_mode);
    
/* Reusing lv_obj_get_style_clip_corner for lv_obj_get_style_border_post */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_border_post_obj, 2, mp_lv_obj_get_style_clip_corner, lv_obj_get_style_border_post);
    
/* Reusing lv_obj_set_style_local_clip_corner for lv_obj_set_style_local_border_post */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_border_post_obj, 4, mp_lv_obj_set_style_local_clip_corner, lv_obj_set_style_local_border_post);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_border_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_border_color_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_border_color);
    
/* Reusing lv_obj_set_style_local_bg_color for lv_obj_set_style_local_border_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_border_color_obj, 4, mp_lv_obj_set_style_local_bg_color, lv_obj_set_style_local_border_color);
    
/* Reusing lv_obj_get_style_opa_scale for lv_obj_get_style_border_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_border_opa_obj, 2, mp_lv_obj_get_style_opa_scale, lv_obj_get_style_border_opa);
    
/* Reusing lv_obj_set_style_local_opa_scale for lv_obj_set_style_local_border_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_border_opa_obj, 4, mp_lv_obj_set_style_local_opa_scale, lv_obj_set_style_local_border_opa);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_outline_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_outline_width_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_outline_width);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_outline_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_outline_width_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_outline_width);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_outline_pad */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_outline_pad_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_outline_pad);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_outline_pad */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_outline_pad_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_outline_pad);
    
/* Reusing lv_obj_get_style_bg_blend_mode for lv_obj_get_style_outline_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_outline_blend_mode_obj, 2, mp_lv_obj_get_style_bg_blend_mode, lv_obj_get_style_outline_blend_mode);
    
/* Reusing lv_obj_set_style_local_bg_blend_mode for lv_obj_set_style_local_outline_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_outline_blend_mode_obj, 4, mp_lv_obj_set_style_local_bg_blend_mode, lv_obj_set_style_local_outline_blend_mode);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_outline_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_outline_color_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_outline_color);
    
/* Reusing lv_obj_set_style_local_bg_color for lv_obj_set_style_local_outline_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_outline_color_obj, 4, mp_lv_obj_set_style_local_bg_color, lv_obj_set_style_local_outline_color);
    
/* Reusing lv_obj_get_style_opa_scale for lv_obj_get_style_outline_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_outline_opa_obj, 2, mp_lv_obj_get_style_opa_scale, lv_obj_get_style_outline_opa);
    
/* Reusing lv_obj_set_style_local_opa_scale for lv_obj_set_style_local_outline_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_outline_opa_obj, 4, mp_lv_obj_set_style_local_opa_scale, lv_obj_set_style_local_outline_opa);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_shadow_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_shadow_width_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_shadow_width);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_shadow_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_shadow_width_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_shadow_width);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_shadow_ofs_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_shadow_ofs_x_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_shadow_ofs_x);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_shadow_ofs_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_shadow_ofs_x_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_shadow_ofs_x);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_shadow_ofs_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_shadow_ofs_y_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_shadow_ofs_y);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_shadow_ofs_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_shadow_ofs_y_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_shadow_ofs_y);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_shadow_spread */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_shadow_spread_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_shadow_spread);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_shadow_spread */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_shadow_spread_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_shadow_spread);
    
/* Reusing lv_obj_get_style_bg_blend_mode for lv_obj_get_style_shadow_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_shadow_blend_mode_obj, 2, mp_lv_obj_get_style_bg_blend_mode, lv_obj_get_style_shadow_blend_mode);
    
/* Reusing lv_obj_set_style_local_bg_blend_mode for lv_obj_set_style_local_shadow_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_shadow_blend_mode_obj, 4, mp_lv_obj_set_style_local_bg_blend_mode, lv_obj_set_style_local_shadow_blend_mode);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_shadow_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_shadow_color_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_shadow_color);
    
/* Reusing lv_obj_set_style_local_bg_color for lv_obj_set_style_local_shadow_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_shadow_color_obj, 4, mp_lv_obj_set_style_local_bg_color, lv_obj_set_style_local_shadow_color);
    
/* Reusing lv_obj_get_style_opa_scale for lv_obj_get_style_shadow_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_shadow_opa_obj, 2, mp_lv_obj_get_style_opa_scale, lv_obj_get_style_shadow_opa);
    
/* Reusing lv_obj_set_style_local_opa_scale for lv_obj_set_style_local_shadow_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_shadow_opa_obj, 4, mp_lv_obj_set_style_local_opa_scale, lv_obj_set_style_local_shadow_opa);
    
/* Reusing lv_obj_get_style_clip_corner for lv_obj_get_style_pattern_repeat */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_pattern_repeat_obj, 2, mp_lv_obj_get_style_clip_corner, lv_obj_get_style_pattern_repeat);
    
/* Reusing lv_obj_set_style_local_clip_corner for lv_obj_set_style_local_pattern_repeat */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_pattern_repeat_obj, 4, mp_lv_obj_set_style_local_clip_corner, lv_obj_set_style_local_pattern_repeat);
    
/* Reusing lv_obj_get_style_bg_blend_mode for lv_obj_get_style_pattern_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_pattern_blend_mode_obj, 2, mp_lv_obj_get_style_bg_blend_mode, lv_obj_get_style_pattern_blend_mode);
    
/* Reusing lv_obj_set_style_local_bg_blend_mode for lv_obj_set_style_local_pattern_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_pattern_blend_mode_obj, 4, mp_lv_obj_set_style_local_bg_blend_mode, lv_obj_set_style_local_pattern_blend_mode);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_pattern_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_pattern_recolor_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_pattern_recolor);
    
/* Reusing lv_obj_set_style_local_bg_color for lv_obj_set_style_local_pattern_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_pattern_recolor_obj, 4, mp_lv_obj_set_style_local_bg_color, lv_obj_set_style_local_pattern_recolor);
    
/* Reusing lv_obj_get_style_opa_scale for lv_obj_get_style_pattern_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_pattern_opa_obj, 2, mp_lv_obj_get_style_opa_scale, lv_obj_get_style_pattern_opa);
    
/* Reusing lv_obj_set_style_local_opa_scale for lv_obj_set_style_local_pattern_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_pattern_opa_obj, 4, mp_lv_obj_set_style_local_opa_scale, lv_obj_set_style_local_pattern_opa);
    
/* Reusing lv_obj_get_style_opa_scale for lv_obj_get_style_pattern_recolor_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_pattern_recolor_opa_obj, 2, mp_lv_obj_get_style_opa_scale, lv_obj_get_style_pattern_recolor_opa);
    
/* Reusing lv_obj_set_style_local_opa_scale for lv_obj_set_style_local_pattern_recolor_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_pattern_recolor_opa_obj, 4, mp_lv_obj_set_style_local_opa_scale, lv_obj_set_style_local_pattern_recolor_opa);
    

/*
 * lvgl extension definition for:
 * inline static const void *lv_obj_get_style_pattern_image(const lv_obj_t *obj, uint8_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_pattern_image(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    const void * _res = ((const void *(*)(const lv_obj_t *, uint8_t))lv_func_ptr)(obj, part);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_pattern_image_obj, 2, mp_lv_obj_get_style_pattern_image, lv_obj_get_style_pattern_image);
    

/*
 * lvgl extension definition for:
 * inline static void lv_obj_set_style_local_pattern_image(lv_obj_t *obj, uint8_t part, lv_state_t state, const void *value)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_local_pattern_image(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[2]);
    const void *value = mp_to_ptr(mp_args[3]);
    ((void (*)(lv_obj_t *, uint8_t, lv_state_t, const void *))lv_func_ptr)(obj, part, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_pattern_image_obj, 4, mp_lv_obj_set_style_local_pattern_image, lv_obj_set_style_local_pattern_image);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_value_letter_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_value_letter_space_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_value_letter_space);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_value_letter_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_value_letter_space_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_value_letter_space);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_value_line_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_value_line_space_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_value_line_space);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_value_line_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_value_line_space_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_value_line_space);
    
/* Reusing lv_obj_get_style_bg_blend_mode for lv_obj_get_style_value_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_value_blend_mode_obj, 2, mp_lv_obj_get_style_bg_blend_mode, lv_obj_get_style_value_blend_mode);
    
/* Reusing lv_obj_set_style_local_bg_blend_mode for lv_obj_set_style_local_value_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_value_blend_mode_obj, 4, mp_lv_obj_set_style_local_bg_blend_mode, lv_obj_set_style_local_value_blend_mode);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_value_ofs_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_value_ofs_x_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_value_ofs_x);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_value_ofs_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_value_ofs_x_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_value_ofs_x);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_value_ofs_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_value_ofs_y_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_value_ofs_y);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_value_ofs_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_value_ofs_y_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_value_ofs_y);
    

/*
 * lvgl extension definition for:
 * inline static lv_align_t lv_obj_get_style_value_align(const lv_obj_t *obj, uint8_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_value_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_align_t _res = ((lv_align_t (*)(const lv_obj_t *, uint8_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_value_align_obj, 2, mp_lv_obj_get_style_value_align, lv_obj_get_style_value_align);
    

/*
 * lvgl extension definition for:
 * inline static void lv_obj_set_style_local_value_align(lv_obj_t *obj, uint8_t part, lv_state_t state, lv_align_t value)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_local_value_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_align_t value = (uint8_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, uint8_t, lv_state_t, lv_align_t))lv_func_ptr)(obj, part, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_value_align_obj, 4, mp_lv_obj_set_style_local_value_align, lv_obj_set_style_local_value_align);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_value_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_value_color_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_value_color);
    
/* Reusing lv_obj_set_style_local_bg_color for lv_obj_set_style_local_value_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_value_color_obj, 4, mp_lv_obj_set_style_local_bg_color, lv_obj_set_style_local_value_color);
    
/* Reusing lv_obj_get_style_opa_scale for lv_obj_get_style_value_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_value_opa_obj, 2, mp_lv_obj_get_style_opa_scale, lv_obj_get_style_value_opa);
    
/* Reusing lv_obj_set_style_local_opa_scale for lv_obj_set_style_local_value_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_value_opa_obj, 4, mp_lv_obj_set_style_local_opa_scale, lv_obj_set_style_local_value_opa);
    
#define funcptr_get_glyph_dsc NULL


/*
 * Struct lv_font_glyph_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_font_glyph_dsc_t_type();

STATIC inline lv_font_glyph_dsc_t* mp_write_ptr_lv_font_glyph_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_font_glyph_dsc_t_type()));
    return (lv_font_glyph_dsc_t*)self->data;
}

#define mp_write_lv_font_glyph_dsc_t(struct_obj) *mp_write_ptr_lv_font_glyph_dsc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_font_glyph_dsc_t(lv_font_glyph_dsc_t *field)
{
    return lv_to_mp_struct(get_mp_lv_font_glyph_dsc_t_type(), (void*)field);
}

#define mp_read_lv_font_glyph_dsc_t(field) mp_read_ptr_lv_font_glyph_dsc_t(copy_buffer(&field, sizeof(lv_font_glyph_dsc_t)))
#define mp_read_byref_lv_font_glyph_dsc_t(field) mp_read_ptr_lv_font_glyph_dsc_t(&field)

STATIC void mp_lv_font_glyph_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_font_glyph_dsc_t *data = (lv_font_glyph_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_adv_w: dest[0] = mp_obj_new_int_from_uint(data->adv_w); break; // converting from uint16_t;
            case MP_QSTR_box_w: dest[0] = mp_obj_new_int_from_uint(data->box_w); break; // converting from uint16_t;
            case MP_QSTR_box_h: dest[0] = mp_obj_new_int_from_uint(data->box_h); break; // converting from uint16_t;
            case MP_QSTR_ofs_x: dest[0] = mp_obj_new_int(data->ofs_x); break; // converting from int16_t;
            case MP_QSTR_ofs_y: dest[0] = mp_obj_new_int(data->ofs_y); break; // converting from int16_t;
            case MP_QSTR_bpp: dest[0] = mp_obj_new_int_from_uint(data->bpp); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_adv_w: data->adv_w = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_box_w: data->box_w = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_box_h: data->box_h = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_ofs_x: data->ofs_x = (int16_t)mp_obj_get_int(dest[1]); break; // converting to int16_t;
                case MP_QSTR_ofs_y: data->ofs_y = (int16_t)mp_obj_get_int(dest[1]); break; // converting to int16_t;
                case MP_QSTR_bpp: data->bpp = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_font_glyph_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_font_glyph_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_font_glyph_dsc_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_font_glyph_dsc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_font_glyph_dsc_t,
    .print = mp_lv_font_glyph_dsc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_font_glyph_dsc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_font_glyph_dsc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_font_glyph_dsc_t_type()
{
    return &mp_lv_font_glyph_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * bool get_glyph_dsc(const struct _lv_font_struct *, lv_font_glyph_dsc_t *, uint32_t letter, uint32_t letter_next)
 */
 
STATIC mp_obj_t mp_funcptr_get_glyph_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_font_struct *arg0 = mp_to_ptr(mp_args[0]);
    lv_font_glyph_dsc_t *arg1 = mp_write_ptr_lv_font_glyph_dsc_t(mp_args[1]);
    uint32_t letter = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint32_t letter_next = (uint32_t)mp_obj_get_int(mp_args[3]);
    bool _res = ((bool (*)(const struct _lv_font_struct *, lv_font_glyph_dsc_t *, uint32_t, uint32_t))lv_func_ptr)(arg0, arg1, letter, letter_next);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_get_glyph_dsc_obj, 4, mp_funcptr_get_glyph_dsc, funcptr_get_glyph_dsc);
    
STATIC inline mp_obj_t mp_lv_funcptr_get_glyph_dsc(void *func){ return mp_lv_funcptr(&mp_funcptr_get_glyph_dsc_obj, func, NULL, MP_QSTR_, NULL); }

STATIC bool lv_font_t_get_glyph_dsc_callback(const struct _lv_font_struct *, lv_font_glyph_dsc_t *, uint32_t letter, uint32_t letter_next);
#define funcptr_get_glyph_bitmap NULL


/*
 * lvgl extension definition for:
 * const uint8_t *get_glyph_bitmap(const struct _lv_font_struct *, uint32_t)
 */
 
STATIC mp_obj_t mp_funcptr_get_glyph_bitmap(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_font_struct *arg0 = mp_to_ptr(mp_args[0]);
    uint32_t arg1 = (uint32_t)mp_obj_get_int(mp_args[1]);
    const uint8_t * _res = ((const uint8_t *(*)(const struct _lv_font_struct *, uint32_t))lv_func_ptr)(arg0, arg1);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_get_glyph_bitmap_obj, 2, mp_funcptr_get_glyph_bitmap, funcptr_get_glyph_bitmap);
    
STATIC inline mp_obj_t mp_lv_funcptr_get_glyph_bitmap(void *func){ return mp_lv_funcptr(&mp_funcptr_get_glyph_bitmap_obj, func, NULL, MP_QSTR_, NULL); }

STATIC const uint8_t * lv_font_t_get_glyph_bitmap_callback(const struct _lv_font_struct *, uint32_t);

/*
 * Struct lv_font_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_font_t_type();

STATIC inline lv_font_t* mp_write_ptr_lv_font_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_font_t_type()));
    return (lv_font_t*)self->data;
}

#define mp_write_lv_font_t(struct_obj) *mp_write_ptr_lv_font_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_font_t(lv_font_t *field)
{
    return lv_to_mp_struct(get_mp_lv_font_t_type(), (void*)field);
}

#define mp_read_lv_font_t(field) mp_read_ptr_lv_font_t(copy_buffer(&field, sizeof(lv_font_t)))
#define mp_read_byref_lv_font_t(field) mp_read_ptr_lv_font_t(&field)

STATIC void mp_lv_font_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_font_t *data = (lv_font_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_get_glyph_dsc: dest[0] = mp_lv_funcptr(&mp_funcptr_get_glyph_dsc_obj, (void*)data->get_glyph_dsc, lv_font_t_get_glyph_dsc_callback ,MP_QSTR_lv_font_t_get_glyph_dsc, data->user_data); break; // converting from callback bool (*)(lv_font_t *, lv_font_glyph_dsc_t *, uint32_t letter, uint32_t letter_next);
            case MP_QSTR_get_glyph_bitmap: dest[0] = mp_lv_funcptr(&mp_funcptr_get_glyph_bitmap_obj, (void*)data->get_glyph_bitmap, lv_font_t_get_glyph_bitmap_callback ,MP_QSTR_lv_font_t_get_glyph_bitmap, data->user_data); break; // converting from callback uint8_t *(*)(lv_font_t *, uint32_t);
            case MP_QSTR_line_height: dest[0] = mp_obj_new_int(data->line_height); break; // converting from lv_coord_t;
            case MP_QSTR_base_line: dest[0] = mp_obj_new_int(data->base_line); break; // converting from lv_coord_t;
            case MP_QSTR_subpx: dest[0] = mp_obj_new_int_from_uint(data->subpx); break; // converting from uint8_t;
            case MP_QSTR_underline_position: dest[0] = mp_obj_new_int(data->underline_position); break; // converting from int8_t;
            case MP_QSTR_underline_thickness: dest[0] = mp_obj_new_int(data->underline_thickness); break; // converting from int8_t;
            case MP_QSTR_dsc: dest[0] = ptr_to_mp((void*)data->dsc); break; // converting from void *;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp(data->user_data); break; // converting from lv_font_user_data_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_get_glyph_dsc: data->get_glyph_dsc = (void*)mp_lv_callback(dest[1], lv_font_t_get_glyph_dsc_callback ,MP_QSTR_lv_font_t_get_glyph_dsc, &data->user_data); break; // converting to callback bool (*)(lv_font_t *, lv_font_glyph_dsc_t *, uint32_t letter, uint32_t letter_next);
                case MP_QSTR_get_glyph_bitmap: data->get_glyph_bitmap = (void*)mp_lv_callback(dest[1], lv_font_t_get_glyph_bitmap_callback ,MP_QSTR_lv_font_t_get_glyph_bitmap, &data->user_data); break; // converting to callback uint8_t *(*)(lv_font_t *, uint32_t);
                case MP_QSTR_line_height: data->line_height = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_base_line: data->base_line = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_subpx: data->subpx = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_underline_position: data->underline_position = (int8_t)mp_obj_get_int(dest[1]); break; // converting to int8_t;
                case MP_QSTR_underline_thickness: data->underline_thickness = (int8_t)mp_obj_get_int(dest[1]); break; // converting to int8_t;
                case MP_QSTR_dsc: data->dsc = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_user_data: data->user_data = mp_to_ptr(dest[1]); break; // converting to lv_font_user_data_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_font_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_font_t");
}

STATIC const mp_obj_dict_t mp_lv_font_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_font_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_font_t,
    .print = mp_lv_font_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_font_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_font_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_font_t_type()
{
    return &mp_lv_font_t_type;
}
    

/*
 * lvgl extension definition for:
 * inline static const lv_font_t *lv_obj_get_style_value_font(const lv_obj_t *obj, uint8_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_value_font(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    const lv_font_t * _res = ((const lv_font_t *(*)(const lv_obj_t *, uint8_t))lv_func_ptr)(obj, part);
    return mp_read_ptr_lv_font_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_value_font_obj, 2, mp_lv_obj_get_style_value_font, lv_obj_get_style_value_font);
    

/*
 * lvgl extension definition for:
 * inline static void lv_obj_set_style_local_value_font(lv_obj_t *obj, uint8_t part, lv_state_t state, const lv_font_t *value)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_local_value_font(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[2]);
    const lv_font_t *value = mp_write_ptr_lv_font_t(mp_args[3]);
    ((void (*)(lv_obj_t *, uint8_t, lv_state_t, const lv_font_t *))lv_func_ptr)(obj, part, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_value_font_obj, 4, mp_lv_obj_set_style_local_value_font, lv_obj_set_style_local_value_font);
    

/*
 * lvgl extension definition for:
 * inline static const char *lv_obj_get_style_value_str(const lv_obj_t *obj, uint8_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_value_str(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    const char * _res = ((const char *(*)(const lv_obj_t *, uint8_t))lv_func_ptr)(obj, part);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_value_str_obj, 2, mp_lv_obj_get_style_value_str, lv_obj_get_style_value_str);
    

/*
 * lvgl extension definition for:
 * inline static void lv_obj_set_style_local_value_str(lv_obj_t *obj, uint8_t part, lv_state_t state, const char *value)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_local_value_str(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[2]);
    const char *value = (char*)convert_from_str(mp_args[3]);
    ((void (*)(lv_obj_t *, uint8_t, lv_state_t, const char *))lv_func_ptr)(obj, part, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_value_str_obj, 4, mp_lv_obj_set_style_local_value_str, lv_obj_set_style_local_value_str);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_text_letter_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_letter_space_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_text_letter_space);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_text_letter_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_text_letter_space_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_text_letter_space);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_text_line_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_line_space_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_text_line_space);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_text_line_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_text_line_space_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_text_line_space);
    

/*
 * lvgl extension definition for:
 * inline static lv_text_decor_t lv_obj_get_style_text_decor(const lv_obj_t *obj, uint8_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_text_decor(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_text_decor_t _res = ((lv_text_decor_t (*)(const lv_obj_t *, uint8_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_decor_obj, 2, mp_lv_obj_get_style_text_decor, lv_obj_get_style_text_decor);
    

/*
 * lvgl extension definition for:
 * inline static void lv_obj_set_style_local_text_decor(lv_obj_t *obj, uint8_t part, lv_state_t state, lv_text_decor_t value)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_local_text_decor(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_text_decor_t value = (uint8_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, uint8_t, lv_state_t, lv_text_decor_t))lv_func_ptr)(obj, part, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_text_decor_obj, 4, mp_lv_obj_set_style_local_text_decor, lv_obj_set_style_local_text_decor);
    
/* Reusing lv_obj_get_style_bg_blend_mode for lv_obj_get_style_text_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_blend_mode_obj, 2, mp_lv_obj_get_style_bg_blend_mode, lv_obj_get_style_text_blend_mode);
    
/* Reusing lv_obj_set_style_local_bg_blend_mode for lv_obj_set_style_local_text_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_text_blend_mode_obj, 4, mp_lv_obj_set_style_local_bg_blend_mode, lv_obj_set_style_local_text_blend_mode);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_text_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_color_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_text_color);
    
/* Reusing lv_obj_set_style_local_bg_color for lv_obj_set_style_local_text_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_text_color_obj, 4, mp_lv_obj_set_style_local_bg_color, lv_obj_set_style_local_text_color);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_text_sel_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_sel_color_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_text_sel_color);
    
/* Reusing lv_obj_set_style_local_bg_color for lv_obj_set_style_local_text_sel_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_text_sel_color_obj, 4, mp_lv_obj_set_style_local_bg_color, lv_obj_set_style_local_text_sel_color);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_text_sel_bg_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_sel_bg_color_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_text_sel_bg_color);
    
/* Reusing lv_obj_set_style_local_bg_color for lv_obj_set_style_local_text_sel_bg_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_text_sel_bg_color_obj, 4, mp_lv_obj_set_style_local_bg_color, lv_obj_set_style_local_text_sel_bg_color);
    
/* Reusing lv_obj_get_style_opa_scale for lv_obj_get_style_text_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_opa_obj, 2, mp_lv_obj_get_style_opa_scale, lv_obj_get_style_text_opa);
    
/* Reusing lv_obj_set_style_local_opa_scale for lv_obj_set_style_local_text_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_text_opa_obj, 4, mp_lv_obj_set_style_local_opa_scale, lv_obj_set_style_local_text_opa);
    
/* Reusing lv_obj_get_style_value_font for lv_obj_get_style_text_font */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_text_font_obj, 2, mp_lv_obj_get_style_value_font, lv_obj_get_style_text_font);
    
/* Reusing lv_obj_set_style_local_value_font for lv_obj_set_style_local_text_font */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_text_font_obj, 4, mp_lv_obj_set_style_local_value_font, lv_obj_set_style_local_text_font);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_line_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_line_width_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_line_width);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_line_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_line_width_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_line_width);
    
/* Reusing lv_obj_get_style_bg_blend_mode for lv_obj_get_style_line_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_line_blend_mode_obj, 2, mp_lv_obj_get_style_bg_blend_mode, lv_obj_get_style_line_blend_mode);
    
/* Reusing lv_obj_set_style_local_bg_blend_mode for lv_obj_set_style_local_line_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_line_blend_mode_obj, 4, mp_lv_obj_set_style_local_bg_blend_mode, lv_obj_set_style_local_line_blend_mode);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_line_dash_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_line_dash_width_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_line_dash_width);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_line_dash_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_line_dash_width_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_line_dash_width);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_line_dash_gap */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_line_dash_gap_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_line_dash_gap);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_line_dash_gap */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_line_dash_gap_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_line_dash_gap);
    
/* Reusing lv_obj_get_style_clip_corner for lv_obj_get_style_line_rounded */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_line_rounded_obj, 2, mp_lv_obj_get_style_clip_corner, lv_obj_get_style_line_rounded);
    
/* Reusing lv_obj_set_style_local_clip_corner for lv_obj_set_style_local_line_rounded */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_line_rounded_obj, 4, mp_lv_obj_set_style_local_clip_corner, lv_obj_set_style_local_line_rounded);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_line_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_line_color_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_line_color);
    
/* Reusing lv_obj_set_style_local_bg_color for lv_obj_set_style_local_line_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_line_color_obj, 4, mp_lv_obj_set_style_local_bg_color, lv_obj_set_style_local_line_color);
    
/* Reusing lv_obj_get_style_opa_scale for lv_obj_get_style_line_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_line_opa_obj, 2, mp_lv_obj_get_style_opa_scale, lv_obj_get_style_line_opa);
    
/* Reusing lv_obj_set_style_local_opa_scale for lv_obj_set_style_local_line_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_line_opa_obj, 4, mp_lv_obj_set_style_local_opa_scale, lv_obj_set_style_local_line_opa);
    
/* Reusing lv_obj_get_style_bg_blend_mode for lv_obj_get_style_image_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_image_blend_mode_obj, 2, mp_lv_obj_get_style_bg_blend_mode, lv_obj_get_style_image_blend_mode);
    
/* Reusing lv_obj_set_style_local_bg_blend_mode for lv_obj_set_style_local_image_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_image_blend_mode_obj, 4, mp_lv_obj_set_style_local_bg_blend_mode, lv_obj_set_style_local_image_blend_mode);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_image_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_image_recolor_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_image_recolor);
    
/* Reusing lv_obj_set_style_local_bg_color for lv_obj_set_style_local_image_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_image_recolor_obj, 4, mp_lv_obj_set_style_local_bg_color, lv_obj_set_style_local_image_recolor);
    
/* Reusing lv_obj_get_style_opa_scale for lv_obj_get_style_image_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_image_opa_obj, 2, mp_lv_obj_get_style_opa_scale, lv_obj_get_style_image_opa);
    
/* Reusing lv_obj_set_style_local_opa_scale for lv_obj_set_style_local_image_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_image_opa_obj, 4, mp_lv_obj_set_style_local_opa_scale, lv_obj_set_style_local_image_opa);
    
/* Reusing lv_obj_get_style_opa_scale for lv_obj_get_style_image_recolor_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_image_recolor_opa_obj, 2, mp_lv_obj_get_style_opa_scale, lv_obj_get_style_image_recolor_opa);
    
/* Reusing lv_obj_set_style_local_opa_scale for lv_obj_set_style_local_image_recolor_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_image_recolor_opa_obj, 4, mp_lv_obj_set_style_local_opa_scale, lv_obj_set_style_local_image_recolor_opa);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_transition_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transition_time_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_transition_time);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_transition_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_transition_time_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_transition_time);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_transition_delay */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transition_delay_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_transition_delay);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_transition_delay */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_transition_delay_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_transition_delay);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_transition_prop_1 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transition_prop_1_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_transition_prop_1);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_transition_prop_1 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_transition_prop_1_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_transition_prop_1);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_transition_prop_2 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transition_prop_2_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_transition_prop_2);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_transition_prop_2 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_transition_prop_2_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_transition_prop_2);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_transition_prop_3 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transition_prop_3_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_transition_prop_3);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_transition_prop_3 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_transition_prop_3_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_transition_prop_3);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_transition_prop_4 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transition_prop_4_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_transition_prop_4);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_transition_prop_4 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_transition_prop_4_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_transition_prop_4);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_transition_prop_5 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transition_prop_5_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_transition_prop_5);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_transition_prop_5 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_transition_prop_5_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_transition_prop_5);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_transition_prop_6 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transition_prop_6_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_transition_prop_6);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_transition_prop_6 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_transition_prop_6_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_transition_prop_6);
    
#define funcptr_lv_anim_path_cb_t NULL

#define funcptr_lv_anim_exec_xcb_t NULL


/*
 * lvgl extension definition for:
 * void lv_anim_exec_xcb_t(void *, lv_anim_value_t)
 */
 
STATIC mp_obj_t mp_funcptr_lv_anim_exec_xcb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *arg0 = mp_to_ptr(mp_args[0]);
    lv_anim_value_t arg1 = (int16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(void *, lv_anim_value_t))lv_func_ptr)(arg0, arg1);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_anim_exec_xcb_t_obj, 2, mp_funcptr_lv_anim_exec_xcb_t, funcptr_lv_anim_exec_xcb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_anim_exec_xcb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_anim_exec_xcb_t_obj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_anim_t_exec_cb_callback'
 * lv_anim_exec_xcb_t exec_cb
 */
    
#define funcptr_lv_anim_start_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_anim_start_cb_t(struct _lv_anim_t *)
 */
 
STATIC mp_obj_t mp_funcptr_lv_anim_start_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_anim_t *arg0 = mp_to_ptr(mp_args[0]);
    ((void (*)(struct _lv_anim_t *))lv_func_ptr)(arg0);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_anim_start_cb_t_obj, 1, mp_funcptr_lv_anim_start_cb_t, funcptr_lv_anim_start_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_anim_start_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_anim_start_cb_t_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_anim_t_start_cb_callback(struct _lv_anim_t *);
STATIC void lv_anim_t_ready_cb_callback(struct _lv_anim_t *);
/* Already started generating lv_anim_path_t! skipping field 'path' */

/*
 * Struct lv_anim_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_anim_t_type();

STATIC inline lv_anim_t* mp_write_ptr_lv_anim_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_anim_t_type()));
    return (lv_anim_t*)self->data;
}

#define mp_write_lv_anim_t(struct_obj) *mp_write_ptr_lv_anim_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_anim_t(lv_anim_t *field)
{
    return lv_to_mp_struct(get_mp_lv_anim_t_type(), (void*)field);
}

#define mp_read_lv_anim_t(field) mp_read_ptr_lv_anim_t(copy_buffer(&field, sizeof(lv_anim_t)))
#define mp_read_byref_lv_anim_t(field) mp_read_ptr_lv_anim_t(&field)

STATIC void mp_lv_anim_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_anim_t *data = (lv_anim_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_var: dest[0] = ptr_to_mp((void*)data->var); break; // converting from void *;
            case MP_QSTR_exec_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_anim_exec_xcb_t_obj, data->exec_cb, NULL ,MP_QSTR_lv_anim_t_exec_cb, NULL); break; // converting from callback lv_anim_exec_xcb_t;
            case MP_QSTR_start_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_anim_start_cb_t_obj, data->start_cb, lv_anim_t_start_cb_callback ,MP_QSTR_lv_anim_t_start_cb, data->user_data); break; // converting from callback lv_anim_start_cb_t;
            case MP_QSTR_ready_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_anim_start_cb_t_obj, data->ready_cb, lv_anim_t_ready_cb_callback ,MP_QSTR_lv_anim_t_ready_cb, data->user_data); break; // converting from callback lv_anim_ready_cb_t;
            case MP_QSTR_start: dest[0] = mp_obj_new_int(data->start); break; // converting from int32_t;
            case MP_QSTR_current: dest[0] = mp_obj_new_int(data->current); break; // converting from int32_t;
            case MP_QSTR_end: dest[0] = mp_obj_new_int(data->end); break; // converting from int32_t;
            case MP_QSTR_time: dest[0] = mp_obj_new_int(data->time); break; // converting from int32_t;
            case MP_QSTR_act_time: dest[0] = mp_obj_new_int(data->act_time); break; // converting from int32_t;
            case MP_QSTR_playback_delay: dest[0] = mp_obj_new_int_from_uint(data->playback_delay); break; // converting from uint32_t;
            case MP_QSTR_playback_time: dest[0] = mp_obj_new_int_from_uint(data->playback_time); break; // converting from uint32_t;
            case MP_QSTR_repeat_delay: dest[0] = mp_obj_new_int_from_uint(data->repeat_delay); break; // converting from uint32_t;
            case MP_QSTR_repeat_cnt: dest[0] = mp_obj_new_int_from_uint(data->repeat_cnt); break; // converting from uint16_t;
            case MP_QSTR_early_apply: dest[0] = mp_obj_new_int_from_uint(data->early_apply); break; // converting from uint8_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp(data->user_data); break; // converting from lv_anim_user_data_t;
            case MP_QSTR_time_orig: dest[0] = mp_obj_new_int_from_uint(data->time_orig); break; // converting from uint32_t;
            case MP_QSTR_playback_now: dest[0] = mp_obj_new_int_from_uint(data->playback_now); break; // converting from uint8_t;
            case MP_QSTR_has_run: dest[0] = mp_obj_new_int_from_uint(data->has_run); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_var: data->var = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_exec_cb: data->exec_cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_anim_t_exec_cb, NULL); break; // converting to callback lv_anim_exec_xcb_t;
                case MP_QSTR_start_cb: data->start_cb = mp_lv_callback(dest[1], lv_anim_t_start_cb_callback ,MP_QSTR_lv_anim_t_start_cb, &data->user_data); break; // converting to callback lv_anim_start_cb_t;
                case MP_QSTR_ready_cb: data->ready_cb = mp_lv_callback(dest[1], lv_anim_t_ready_cb_callback ,MP_QSTR_lv_anim_t_ready_cb, &data->user_data); break; // converting to callback lv_anim_ready_cb_t;
                case MP_QSTR_start: data->start = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_current: data->current = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_end: data->end = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_time: data->time = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_act_time: data->act_time = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_playback_delay: data->playback_delay = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_playback_time: data->playback_time = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_repeat_delay: data->repeat_delay = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_repeat_cnt: data->repeat_cnt = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_early_apply: data->early_apply = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_user_data: data->user_data = mp_to_ptr(dest[1]); break; // converting to lv_anim_user_data_t;
                case MP_QSTR_time_orig: data->time_orig = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_playback_now: data->playback_now = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_has_run: data->has_run = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_anim_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_anim_t");
}

STATIC const mp_obj_dict_t mp_lv_anim_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_anim_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_anim_t,
    .print = mp_lv_anim_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_anim_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_anim_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_anim_t_type()
{
    return &mp_lv_anim_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_anim_value_t lv_anim_path_cb_t(const struct _lv_anim_path_t *, const struct _lv_anim_t *)
 */
 
STATIC mp_obj_t mp_funcptr_lv_anim_path_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const struct _lv_anim_path_t *arg0 = mp_to_ptr(mp_args[0]);
    const struct _lv_anim_t *arg1 = mp_write_ptr_lv_anim_t(mp_args[1]);
    lv_anim_value_t _res = ((lv_anim_value_t (*)(const struct _lv_anim_path_t *, const struct _lv_anim_t *))lv_func_ptr)(arg0, arg1);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_anim_path_cb_t_obj, 2, mp_funcptr_lv_anim_path_cb_t, funcptr_lv_anim_path_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_anim_path_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_anim_path_cb_t_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_anim_value_t lv_anim_path_t_cb_callback(const struct _lv_anim_path_t *, const struct _lv_anim_t *);

/*
 * Struct lv_anim_path_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_anim_path_t_type();

STATIC inline lv_anim_path_t* mp_write_ptr_lv_anim_path_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_anim_path_t_type()));
    return (lv_anim_path_t*)self->data;
}

#define mp_write_lv_anim_path_t(struct_obj) *mp_write_ptr_lv_anim_path_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_anim_path_t(lv_anim_path_t *field)
{
    return lv_to_mp_struct(get_mp_lv_anim_path_t_type(), (void*)field);
}

#define mp_read_lv_anim_path_t(field) mp_read_ptr_lv_anim_path_t(copy_buffer(&field, sizeof(lv_anim_path_t)))
#define mp_read_byref_lv_anim_path_t(field) mp_read_ptr_lv_anim_path_t(&field)

STATIC void mp_lv_anim_path_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_anim_path_t *data = (lv_anim_path_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_anim_path_cb_t_obj, data->cb, lv_anim_path_t_cb_callback ,MP_QSTR_lv_anim_path_t_cb, data->user_data); break; // converting from callback lv_anim_path_cb_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_cb: data->cb = mp_lv_callback(dest[1], lv_anim_path_t_cb_callback ,MP_QSTR_lv_anim_path_t_cb, &data->user_data); break; // converting to callback lv_anim_path_cb_t;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_anim_path_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_anim_path_t");
}

STATIC const mp_obj_dict_t mp_lv_anim_path_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_anim_path_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_anim_path_t,
    .print = mp_lv_anim_path_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_anim_path_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_anim_path_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_anim_path_t_type()
{
    return &mp_lv_anim_path_t_type;
}
    

/*
 * lvgl extension definition for:
 * inline static lv_anim_path_t *lv_obj_get_style_transition_path(const lv_obj_t *obj, uint8_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_transition_path(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_anim_path_t * _res = ((lv_anim_path_t *(*)(const lv_obj_t *, uint8_t))lv_func_ptr)(obj, part);
    return mp_read_ptr_lv_anim_path_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_transition_path_obj, 2, mp_lv_obj_get_style_transition_path, lv_obj_get_style_transition_path);
    

/*
 * lvgl extension definition for:
 * inline static void lv_obj_set_style_local_transition_path(lv_obj_t *obj, uint8_t part, lv_state_t state, lv_anim_path_t *value)
 */
 
STATIC mp_obj_t mp_lv_obj_set_style_local_transition_path(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_anim_path_t *value = mp_write_ptr_lv_anim_path_t(mp_args[3]);
    ((void (*)(lv_obj_t *, uint8_t, lv_state_t, lv_anim_path_t *))lv_func_ptr)(obj, part, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_transition_path_obj, 4, mp_lv_obj_set_style_local_transition_path, lv_obj_set_style_local_transition_path);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_scale_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_scale_width_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_scale_width);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_scale_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_scale_width_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_scale_width);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_scale_border_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_scale_border_width_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_scale_border_width);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_scale_border_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_scale_border_width_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_scale_border_width);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_scale_end_border_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_scale_end_border_width_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_scale_end_border_width);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_scale_end_border_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_scale_end_border_width_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_scale_end_border_width);
    
/* Reusing lv_obj_get_style_radius for lv_obj_get_style_scale_end_line_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_scale_end_line_width_obj, 2, mp_lv_obj_get_style_radius, lv_obj_get_style_scale_end_line_width);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_scale_end_line_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_scale_end_line_width_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_scale_end_line_width);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_scale_grad_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_scale_grad_color_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_scale_grad_color);
    
/* Reusing lv_obj_set_style_local_bg_color for lv_obj_set_style_local_scale_grad_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_scale_grad_color_obj, 4, mp_lv_obj_set_style_local_bg_color, lv_obj_set_style_local_scale_grad_color);
    
/* Reusing lv_obj_get_style_bg_color for lv_obj_get_style_scale_end_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_scale_end_color_obj, 2, mp_lv_obj_get_style_bg_color, lv_obj_get_style_scale_end_color);
    
/* Reusing lv_obj_set_style_local_bg_color for lv_obj_set_style_local_scale_end_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_scale_end_color_obj, 4, mp_lv_obj_set_style_local_bg_color, lv_obj_set_style_local_scale_end_color);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_pad_all */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_pad_all_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_pad_all);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_pad_hor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_pad_hor_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_pad_hor);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_pad_ver */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_pad_ver_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_pad_ver);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_margin_all */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_margin_all_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_margin_all);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_margin_hor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_margin_hor_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_margin_hor);
    
/* Reusing lv_obj_set_style_local_radius for lv_obj_set_style_local_margin_ver */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_style_local_margin_ver_obj, 4, mp_lv_obj_set_style_local_radius, lv_obj_set_style_local_margin_ver);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_obj_del(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_del(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_res_t _res = ((lv_res_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_del_obj, 1, mp_lv_obj_del, lv_obj_del);
    

/*
 * lvgl extension definition for:
 * void lv_obj_del_anim_ready_cb(lv_anim_t *a)
 */
 
STATIC mp_obj_t mp_lv_obj_del_anim_ready_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    ((void (*)(lv_anim_t *))lv_func_ptr)(a);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_obj_del_anim_ready_cb_obj, 1, mp_lv_obj_del_anim_ready_cb, lv_obj_del_anim_ready_cb);
    

/*
 * lvgl extension definition for:
 * void lv_obj_del_async(struct _lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_del_async(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    ((void (*)(struct _lv_obj_t *))lv_func_ptr)(obj);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_del_async_obj, 1, mp_lv_obj_del_async, lv_obj_del_async);
    

/*
 * lvgl extension definition for:
 * void lv_obj_clean(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_clean(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    ((void (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_clean_obj, 1, mp_lv_obj_clean, lv_obj_clean);
    

/*
 * Struct lv_area_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_area_t_type();

STATIC inline lv_area_t* mp_write_ptr_lv_area_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_area_t_type()));
    return (lv_area_t*)self->data;
}

#define mp_write_lv_area_t(struct_obj) *mp_write_ptr_lv_area_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_area_t(lv_area_t *field)
{
    return lv_to_mp_struct(get_mp_lv_area_t_type(), (void*)field);
}

#define mp_read_lv_area_t(field) mp_read_ptr_lv_area_t(copy_buffer(&field, sizeof(lv_area_t)))
#define mp_read_byref_lv_area_t(field) mp_read_ptr_lv_area_t(&field)

STATIC void mp_lv_area_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_area_t *data = (lv_area_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_x1: dest[0] = mp_obj_new_int(data->x1); break; // converting from lv_coord_t;
            case MP_QSTR_y1: dest[0] = mp_obj_new_int(data->y1); break; // converting from lv_coord_t;
            case MP_QSTR_x2: dest[0] = mp_obj_new_int(data->x2); break; // converting from lv_coord_t;
            case MP_QSTR_y2: dest[0] = mp_obj_new_int(data->y2); break; // converting from lv_coord_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_x1: data->x1 = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_y1: data->y1 = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_x2: data->x2 = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_y2: data->y2 = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_area_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_area_t");
}

STATIC const mp_obj_dict_t mp_lv_area_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_area_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_area_t,
    .print = mp_lv_area_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_area_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_area_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_area_t_type()
{
    return &mp_lv_area_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_obj_invalidate_area(const lv_obj_t *obj, const lv_area_t *area)
 */
 
STATIC mp_obj_t mp_lv_obj_invalidate_area(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_area_t *area = mp_write_ptr_lv_area_t(mp_args[1]);
    ((void (*)(const lv_obj_t *, const lv_area_t *))lv_func_ptr)(obj, area);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_invalidate_area_obj, 2, mp_lv_obj_invalidate_area, lv_obj_invalidate_area);
    

/*
 * lvgl extension definition for:
 * void lv_obj_invalidate(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_invalidate(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    ((void (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_invalidate_obj, 1, mp_lv_obj_invalidate, lv_obj_invalidate);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_area_is_visible(const lv_obj_t *obj, lv_area_t *area)
 */
 
STATIC mp_obj_t mp_lv_obj_area_is_visible(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_area_t *area = mp_write_ptr_lv_area_t(mp_args[1]);
    bool _res = ((bool (*)(const lv_obj_t *, lv_area_t *))lv_func_ptr)(obj, area);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_area_is_visible_obj, 2, mp_lv_obj_area_is_visible, lv_obj_area_is_visible);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_is_visible(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_is_visible(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    bool _res = ((bool (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_is_visible_obj, 1, mp_lv_obj_is_visible, lv_obj_is_visible);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_parent(lv_obj_t *obj, lv_obj_t *parent)
 */
 
STATIC mp_obj_t mp_lv_obj_set_parent(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_obj_t *parent = mp_to_lv(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_obj_t *))lv_func_ptr)(obj, parent);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_parent_obj, 2, mp_lv_obj_set_parent, lv_obj_set_parent);
    
/* Reusing lv_obj_clean for lv_obj_move_foreground */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_move_foreground_obj, 1, mp_lv_obj_clean, lv_obj_move_foreground);
    
/* Reusing lv_obj_clean for lv_obj_move_background */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_move_background_obj, 1, mp_lv_obj_clean, lv_obj_move_background);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_pos(lv_obj_t *obj, lv_coord_t x, lv_coord_t y)
 */
 
STATIC mp_obj_t mp_lv_obj_set_pos(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_coord_t, lv_coord_t))lv_func_ptr)(obj, x, y);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_pos_obj, 3, mp_lv_obj_set_pos, lv_obj_set_pos);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_x(lv_obj_t *obj, lv_coord_t x)
 */
 
STATIC mp_obj_t mp_lv_obj_set_x(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_coord_t))lv_func_ptr)(obj, x);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_x_obj, 2, mp_lv_obj_set_x, lv_obj_set_x);
    
/* Reusing lv_obj_set_x for lv_obj_set_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_y_obj, 2, mp_lv_obj_set_x, lv_obj_set_y);
    
/* Reusing lv_obj_set_pos for lv_obj_set_size */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_size_obj, 3, mp_lv_obj_set_pos, lv_obj_set_size);
    
/* Reusing lv_obj_set_x for lv_obj_set_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_width_obj, 2, mp_lv_obj_set_x, lv_obj_set_width);
    
/* Reusing lv_obj_set_x for lv_obj_set_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_height_obj, 2, mp_lv_obj_set_x, lv_obj_set_height);
    
/* Reusing lv_obj_set_x for lv_obj_set_width_fit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_width_fit_obj, 2, mp_lv_obj_set_x, lv_obj_set_width_fit);
    
/* Reusing lv_obj_set_x for lv_obj_set_height_fit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_height_fit_obj, 2, mp_lv_obj_set_x, lv_obj_set_height_fit);
    
/* Reusing lv_obj_set_x for lv_obj_set_width_margin */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_width_margin_obj, 2, mp_lv_obj_set_x, lv_obj_set_width_margin);
    
/* Reusing lv_obj_set_x for lv_obj_set_height_margin */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_height_margin_obj, 2, mp_lv_obj_set_x, lv_obj_set_height_margin);
    

/*
 * lvgl extension definition for:
 * void lv_obj_align(lv_obj_t *obj, const lv_obj_t *base, lv_align_t align, lv_coord_t x_ofs, lv_coord_t y_ofs)
 */
 
STATIC mp_obj_t mp_lv_obj_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_obj_t *base = mp_to_lv(mp_args[1]);
    lv_align_t align = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t x_ofs = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t y_ofs = (int16_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(lv_obj_t *, const lv_obj_t *, lv_align_t, lv_coord_t, lv_coord_t))lv_func_ptr)(obj, base, align, x_ofs, y_ofs);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_align_obj, 5, mp_lv_obj_align, lv_obj_align);
    

/*
 * lvgl extension definition for:
 * void lv_obj_align_x(lv_obj_t *obj, const lv_obj_t *base, lv_align_t align, lv_coord_t x_ofs)
 */
 
STATIC mp_obj_t mp_lv_obj_align_x(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_obj_t *base = mp_to_lv(mp_args[1]);
    lv_align_t align = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t x_ofs = (int16_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, const lv_obj_t *, lv_align_t, lv_coord_t))lv_func_ptr)(obj, base, align, x_ofs);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_align_x_obj, 4, mp_lv_obj_align_x, lv_obj_align_x);
    
/* Reusing lv_obj_align_x for lv_obj_align_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_align_y_obj, 4, mp_lv_obj_align_x, lv_obj_align_y);
    
/* Reusing lv_obj_align for lv_obj_align_mid */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_align_mid_obj, 5, mp_lv_obj_align, lv_obj_align_mid);
    
/* Reusing lv_obj_align_x for lv_obj_align_mid_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_align_mid_x_obj, 4, mp_lv_obj_align_x, lv_obj_align_mid_x);
    
/* Reusing lv_obj_align_x for lv_obj_align_mid_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_align_mid_y_obj, 4, mp_lv_obj_align_x, lv_obj_align_mid_y);
    
/* Reusing lv_obj_clean for lv_obj_realign */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_realign_obj, 1, mp_lv_obj_clean, lv_obj_realign);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_auto_realign(lv_obj_t *obj, bool en)
 */
 
STATIC mp_obj_t mp_lv_obj_set_auto_realign(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    bool en = mp_obj_is_true(mp_args[1]);
    ((void (*)(lv_obj_t *, bool))lv_func_ptr)(obj, en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_auto_realign_obj, 2, mp_lv_obj_set_auto_realign, lv_obj_set_auto_realign);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_ext_click_area(lv_obj_t *obj, lv_coord_t left, lv_coord_t right, lv_coord_t top, lv_coord_t bottom)
 */
 
STATIC mp_obj_t mp_lv_obj_set_ext_click_area(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_coord_t left = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t right = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t top = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t bottom = (int16_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(lv_obj_t *, lv_coord_t, lv_coord_t, lv_coord_t, lv_coord_t))lv_func_ptr)(obj, left, right, top, bottom);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_ext_click_area_obj, 5, mp_lv_obj_set_ext_click_area, lv_obj_set_ext_click_area);
    

/*
 * Struct lv_style_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_style_t_type();

STATIC inline lv_style_t* mp_write_ptr_lv_style_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_style_t_type()));
    return (lv_style_t*)self->data;
}

#define mp_write_lv_style_t(struct_obj) *mp_write_ptr_lv_style_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_style_t(lv_style_t *field)
{
    return lv_to_mp_struct(get_mp_lv_style_t_type(), (void*)field);
}

#define mp_read_lv_style_t(field) mp_read_ptr_lv_style_t(copy_buffer(&field, sizeof(lv_style_t)))
#define mp_read_byref_lv_style_t(field) mp_read_ptr_lv_style_t(&field)

STATIC void mp_lv_style_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_style_t *data = (lv_style_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_map: dest[0] = ptr_to_mp((void*)data->map); break; // converting from uint8_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_map: data->map = (void*)mp_to_ptr(dest[1]); break; // converting to uint8_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_style_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_style_t");
}

STATIC const mp_obj_dict_t mp_lv_style_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_style_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_style_t,
    .print = mp_lv_style_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_style_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_style_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_style_t_type()
{
    return &mp_lv_style_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_obj_add_style(lv_obj_t *obj, uint8_t part, lv_style_t *style)
 */
 
STATIC mp_obj_t mp_lv_obj_add_style(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[2]);
    ((void (*)(lv_obj_t *, uint8_t, lv_style_t *))lv_func_ptr)(obj, part, style);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_add_style_obj, 3, mp_lv_obj_add_style, lv_obj_add_style);
    
/* Reusing lv_obj_add_style for lv_obj_remove_style */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_remove_style_obj, 3, mp_lv_obj_add_style, lv_obj_remove_style);
    

/*
 * lvgl extension definition for:
 * void lv_obj_clean_style_list(lv_obj_t *obj, uint8_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_clean_style_list(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, uint8_t))lv_func_ptr)(obj, part);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_clean_style_list_obj, 2, mp_lv_obj_clean_style_list, lv_obj_clean_style_list);
    
/* Reusing lv_obj_clean_style_list for lv_obj_reset_style_list */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_reset_style_list_obj, 2, mp_lv_obj_clean_style_list, lv_obj_reset_style_list);
    

/*
 * lvgl extension definition for:
 * void lv_obj_refresh_style(lv_obj_t *obj, uint8_t part, lv_style_property_t prop)
 */
 
STATIC mp_obj_t mp_lv_obj_refresh_style(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_property_t prop = (uint16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint8_t, lv_style_property_t))lv_func_ptr)(obj, part, prop);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_refresh_style_obj, 3, mp_lv_obj_refresh_style, lv_obj_refresh_style);
    

/*
 * lvgl extension definition for:
 * void lv_obj_report_style_mod(lv_style_t *style)
 */
 
STATIC mp_obj_t mp_lv_obj_report_style_mod(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    ((void (*)(lv_style_t *))lv_func_ptr)(style);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_obj_report_style_mod_obj, 1, mp_lv_obj_report_style_mod, lv_obj_report_style_mod);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_remove_style_local_prop(lv_obj_t *obj, uint8_t part, lv_style_property_t prop)
 */
 
STATIC mp_obj_t mp_lv_obj_remove_style_local_prop(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_property_t prop = (uint16_t)mp_obj_get_int(mp_args[2]);
    bool _res = ((bool (*)(lv_obj_t *, uint8_t, lv_style_property_t))lv_func_ptr)(obj, part, prop);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_remove_style_local_prop_obj, 3, mp_lv_obj_remove_style_local_prop, lv_obj_remove_style_local_prop);
    
/* Reusing lv_obj_set_auto_realign for lv_obj_set_hidden */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_hidden_obj, 2, mp_lv_obj_set_auto_realign, lv_obj_set_hidden);
    
/* Reusing lv_obj_set_auto_realign for lv_obj_set_adv_hittest */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_adv_hittest_obj, 2, mp_lv_obj_set_auto_realign, lv_obj_set_adv_hittest);
    
/* Reusing lv_obj_set_auto_realign for lv_obj_set_click */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_click_obj, 2, mp_lv_obj_set_auto_realign, lv_obj_set_click);
    
/* Reusing lv_obj_set_auto_realign for lv_obj_set_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_top_obj, 2, mp_lv_obj_set_auto_realign, lv_obj_set_top);
    
/* Reusing lv_obj_set_auto_realign for lv_obj_set_drag */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_drag_obj, 2, mp_lv_obj_set_auto_realign, lv_obj_set_drag);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_drag_dir(lv_obj_t *obj, lv_drag_dir_t drag_dir)
 */
 
STATIC mp_obj_t mp_lv_obj_set_drag_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_drag_dir_t drag_dir = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_drag_dir_t))lv_func_ptr)(obj, drag_dir);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_drag_dir_obj, 2, mp_lv_obj_set_drag_dir, lv_obj_set_drag_dir);
    
/* Reusing lv_obj_set_auto_realign for lv_obj_set_drag_throw */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_drag_throw_obj, 2, mp_lv_obj_set_auto_realign, lv_obj_set_drag_throw);
    
/* Reusing lv_obj_set_auto_realign for lv_obj_set_drag_parent */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_drag_parent_obj, 2, mp_lv_obj_set_auto_realign, lv_obj_set_drag_parent);
    
/* Reusing lv_obj_set_auto_realign for lv_obj_set_focus_parent */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_focus_parent_obj, 2, mp_lv_obj_set_auto_realign, lv_obj_set_focus_parent);
    
/* Reusing lv_obj_set_auto_realign for lv_obj_set_gesture_parent */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_gesture_parent_obj, 2, mp_lv_obj_set_auto_realign, lv_obj_set_gesture_parent);
    
/* Reusing lv_obj_set_auto_realign for lv_obj_set_parent_event */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_parent_event_obj, 2, mp_lv_obj_set_auto_realign, lv_obj_set_parent_event);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_base_dir(lv_obj_t *obj, lv_bidi_dir_t dir)
 */
 
STATIC mp_obj_t mp_lv_obj_set_base_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_bidi_dir_t dir = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_bidi_dir_t))lv_func_ptr)(obj, dir);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_base_dir_obj, 2, mp_lv_obj_set_base_dir, lv_obj_set_base_dir);
    
/* Reusing lv_obj_clean_style_list for lv_obj_add_protect */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_add_protect_obj, 2, mp_lv_obj_clean_style_list, lv_obj_add_protect);
    
/* Reusing lv_obj_clean_style_list for lv_obj_clear_protect */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_clear_protect_obj, 2, mp_lv_obj_clean_style_list, lv_obj_clear_protect);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_state(lv_obj_t *obj, lv_state_t state)
 */
 
STATIC mp_obj_t mp_lv_obj_set_state(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_state_t))lv_func_ptr)(obj, state);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_state_obj, 2, mp_lv_obj_set_state, lv_obj_set_state);
    
/* Reusing lv_obj_set_state for lv_obj_add_state */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_add_state_obj, 2, mp_lv_obj_set_state, lv_obj_add_state);
    
/* Reusing lv_obj_set_state for lv_obj_clear_state */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_clear_state_obj, 2, mp_lv_obj_set_state, lv_obj_clear_state);
    
/* Reusing lv_obj_clean_style_list for lv_obj_finish_transitions */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_finish_transitions_obj, 2, mp_lv_obj_clean_style_list, lv_obj_finish_transitions);
    

/*
 * Callback function lv_obj_t_event_cb
 * void lv_event_cb_t(struct _lv_obj_t *obj, lv_event_t event)
 */

STATIC void lv_obj_t_event_cb_callback(struct _lv_obj_t * arg0, lv_event_t arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = lv_to_mp((void*)arg0);
    mp_args[1] = mp_obj_new_int_from_uint(arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_obj_t_event_cb)) , 2, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * void lv_obj_set_event_cb(lv_obj_t *obj, lv_event_cb_t event_cb)
 */
 
STATIC mp_obj_t mp_lv_obj_set_event_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    void *event_cb = mp_lv_callback(mp_args[1], &lv_obj_t_event_cb_callback, MP_QSTR_lv_obj_t_event_cb, &obj->user_data);
    ((void (*)(lv_obj_t *, lv_event_cb_t))lv_func_ptr)(obj, event_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_event_cb_obj, 2, mp_lv_obj_set_event_cb, lv_obj_set_event_cb);
    

/*
 * Callback function lv_obj_t_signal_cb
 * lv_res_t lv_signal_cb_t(struct _lv_obj_t *obj, lv_signal_t sign, void *param)
 */

STATIC lv_res_t lv_obj_t_signal_cb_callback(struct _lv_obj_t * arg0, lv_signal_t arg1, void * arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = lv_to_mp((void*)arg0);
    mp_args[1] = mp_obj_new_int_from_uint(arg1);
    mp_args[2] = ptr_to_mp((void*)arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_obj_t_signal_cb)) , 3, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * lvgl extension definition for:
 * void lv_obj_set_signal_cb(lv_obj_t *obj, lv_signal_cb_t signal_cb)
 */
 
STATIC mp_obj_t mp_lv_obj_set_signal_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    void *signal_cb = mp_lv_callback(mp_args[1], &lv_obj_t_signal_cb_callback, MP_QSTR_lv_obj_t_signal_cb, &obj->user_data);
    ((void (*)(lv_obj_t *, lv_signal_cb_t))lv_func_ptr)(obj, signal_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_signal_cb_obj, 2, mp_lv_obj_set_signal_cb, lv_obj_set_signal_cb);
    

/*
 * Callback function lv_obj_t_design_cb
 * lv_design_res_t lv_design_cb_t(struct _lv_obj_t *obj, const lv_area_t *clip_area, lv_design_mode_t mode)
 */

STATIC lv_design_res_t lv_obj_t_design_cb_callback(struct _lv_obj_t * arg0, const lv_area_t * arg1, lv_design_mode_t arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = lv_to_mp((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_area_t((void*)arg1);
    mp_args[2] = mp_obj_new_int_from_uint(arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_obj_t_design_cb)) , 3, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * lvgl extension definition for:
 * void lv_obj_set_design_cb(lv_obj_t *obj, lv_design_cb_t design_cb)
 */
 
STATIC mp_obj_t mp_lv_obj_set_design_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    void *design_cb = mp_lv_callback(mp_args[1], &lv_obj_t_design_cb_callback, MP_QSTR_lv_obj_t_design_cb, &obj->user_data);
    ((void (*)(lv_obj_t *, lv_design_cb_t))lv_func_ptr)(obj, design_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_design_cb_obj, 2, mp_lv_obj_set_design_cb, lv_obj_set_design_cb);
    

/*
 * lvgl extension definition for:
 * void *lv_obj_allocate_ext_attr(lv_obj_t *obj, uint16_t ext_size)
 */
 
STATIC mp_obj_t mp_lv_obj_allocate_ext_attr(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t ext_size = (uint16_t)mp_obj_get_int(mp_args[1]);
    void * _res = ((void *(*)(lv_obj_t *, uint16_t))lv_func_ptr)(obj, ext_size);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_allocate_ext_attr_obj, 2, mp_lv_obj_allocate_ext_attr, lv_obj_allocate_ext_attr);
    
/* Reusing lv_obj_clean for lv_obj_refresh_ext_draw_pad */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_refresh_ext_draw_pad_obj, 1, mp_lv_obj_clean, lv_obj_refresh_ext_draw_pad);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_obj_get_screen(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_screen(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_obj_t * _res = ((lv_obj_t *(*)(const lv_obj_t *))lv_func_ptr)(obj);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_screen_obj, 1, mp_lv_obj_get_screen, lv_obj_get_screen);
    

/*
 * Struct lv_disp_buf_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_disp_buf_t_type();

STATIC inline lv_disp_buf_t* mp_write_ptr_lv_disp_buf_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_disp_buf_t_type()));
    return (lv_disp_buf_t*)self->data;
}

#define mp_write_lv_disp_buf_t(struct_obj) *mp_write_ptr_lv_disp_buf_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_disp_buf_t(lv_disp_buf_t *field)
{
    return lv_to_mp_struct(get_mp_lv_disp_buf_t_type(), (void*)field);
}

#define mp_read_lv_disp_buf_t(field) mp_read_ptr_lv_disp_buf_t(copy_buffer(&field, sizeof(lv_disp_buf_t)))
#define mp_read_byref_lv_disp_buf_t(field) mp_read_ptr_lv_disp_buf_t(&field)

STATIC void mp_lv_disp_buf_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_disp_buf_t *data = (lv_disp_buf_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_buf1: dest[0] = ptr_to_mp((void*)data->buf1); break; // converting from void *;
            case MP_QSTR_buf2: dest[0] = ptr_to_mp((void*)data->buf2); break; // converting from void *;
            case MP_QSTR_buf_act: dest[0] = ptr_to_mp((void*)data->buf_act); break; // converting from void *;
            case MP_QSTR_size: dest[0] = mp_obj_new_int_from_uint(data->size); break; // converting from uint32_t;
            case MP_QSTR_area: dest[0] = mp_read_byref_lv_area_t(data->area); break; // converting from lv_area_t;
            case MP_QSTR_flushing: dest[0] = mp_obj_new_int(data->flushing); break; // converting from int;
            case MP_QSTR_flushing_last: dest[0] = mp_obj_new_int(data->flushing_last); break; // converting from int;
            case MP_QSTR_last_area: dest[0] = mp_obj_new_int_from_uint(data->last_area); break; // converting from uint32_t;
            case MP_QSTR_last_part: dest[0] = mp_obj_new_int_from_uint(data->last_part); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_buf1: data->buf1 = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_buf2: data->buf2 = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_buf_act: data->buf_act = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_size: data->size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_area: data->area = mp_write_lv_area_t(dest[1]); break; // converting to lv_area_t;
                case MP_QSTR_flushing: data->flushing = (int)mp_obj_get_int(dest[1]); break; // converting to int;
                case MP_QSTR_flushing_last: data->flushing_last = (int)mp_obj_get_int(dest[1]); break; // converting to int;
                case MP_QSTR_last_area: data->last_area = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_last_part: data->last_part = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_disp_buf_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_disp_buf_t");
}

STATIC const mp_obj_dict_t mp_lv_disp_buf_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_disp_buf_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_disp_buf_t,
    .print = mp_lv_disp_buf_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_disp_buf_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_disp_buf_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_disp_buf_t_type()
{
    return &mp_lv_disp_buf_t_type;
}
    
#define funcptr_flush_cb NULL


/*
 * lvgl extension definition for:
 * void flush_cb(struct _disp_drv_t *disp_drv, const lv_area_t *area, lv_color_t *color_p)
 */
 
STATIC mp_obj_t mp_funcptr_flush_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _disp_drv_t *disp_drv = mp_to_ptr(mp_args[0]);
    const lv_area_t *area = mp_write_ptr_lv_area_t(mp_args[1]);
    lv_color_t *color_p = mp_write_ptr_lv_color32_t(mp_args[2]);
    ((void (*)(struct _disp_drv_t *, const lv_area_t *, lv_color_t *))lv_func_ptr)(disp_drv, area, color_p);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_flush_cb_obj, 3, mp_funcptr_flush_cb, funcptr_flush_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_flush_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_flush_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_disp_drv_t_flush_cb_callback(struct _disp_drv_t *disp_drv, const lv_area_t *area, lv_color_t *color_p);
#define funcptr_rounder_cb NULL


/*
 * lvgl extension definition for:
 * void rounder_cb(struct _disp_drv_t *disp_drv, lv_area_t *area)
 */
 
STATIC mp_obj_t mp_funcptr_rounder_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _disp_drv_t *disp_drv = mp_to_ptr(mp_args[0]);
    lv_area_t *area = mp_write_ptr_lv_area_t(mp_args[1]);
    ((void (*)(struct _disp_drv_t *, lv_area_t *))lv_func_ptr)(disp_drv, area);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_rounder_cb_obj, 2, mp_funcptr_rounder_cb, funcptr_rounder_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_rounder_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_rounder_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_disp_drv_t_rounder_cb_callback(struct _disp_drv_t *disp_drv, lv_area_t *area);
#define funcptr_set_px_cb NULL


/*
 * lvgl extension definition for:
 * void set_px_cb(struct _disp_drv_t *disp_drv, uint8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y, lv_color_t color, lv_opa_t opa)
 */
 
STATIC mp_obj_t mp_funcptr_set_px_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _disp_drv_t *disp_drv = mp_to_ptr(mp_args[0]);
    uint8_t *buf = mp_to_ptr(mp_args[1]);
    lv_coord_t buf_w = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[4]);
    lv_color_t color = mp_write_lv_color32_t(mp_args[5]);
    lv_opa_t opa = (uint8_t)mp_obj_get_int(mp_args[6]);
    ((void (*)(struct _disp_drv_t *, uint8_t *, lv_coord_t, lv_coord_t, lv_coord_t, lv_color_t, lv_opa_t))lv_func_ptr)(disp_drv, buf, buf_w, x, y, color, opa);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_set_px_cb_obj, 7, mp_funcptr_set_px_cb, funcptr_set_px_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_set_px_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_set_px_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_disp_drv_t_set_px_cb_callback(struct _disp_drv_t *disp_drv, uint8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y, lv_color_t color, lv_opa_t opa);
#define funcptr_monitor_cb NULL


/*
 * lvgl extension definition for:
 * void monitor_cb(struct _disp_drv_t *disp_drv, uint32_t time, uint32_t px)
 */
 
STATIC mp_obj_t mp_funcptr_monitor_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _disp_drv_t *disp_drv = mp_to_ptr(mp_args[0]);
    uint32_t time = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t px = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _disp_drv_t *, uint32_t, uint32_t))lv_func_ptr)(disp_drv, time, px);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_monitor_cb_obj, 3, mp_funcptr_monitor_cb, funcptr_monitor_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_monitor_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_monitor_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_disp_drv_t_monitor_cb_callback(struct _disp_drv_t *disp_drv, uint32_t time, uint32_t px);
#define funcptr_wait_cb NULL


/*
 * lvgl extension definition for:
 * void wait_cb(struct _disp_drv_t *disp_drv)
 */
 
STATIC mp_obj_t mp_funcptr_wait_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _disp_drv_t *disp_drv = mp_to_ptr(mp_args[0]);
    ((void (*)(struct _disp_drv_t *))lv_func_ptr)(disp_drv);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_wait_cb_obj, 1, mp_funcptr_wait_cb, funcptr_wait_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_wait_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_wait_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_disp_drv_t_wait_cb_callback(struct _disp_drv_t *disp_drv);
STATIC void lv_disp_drv_t_clean_dcache_cb_callback(struct _disp_drv_t *disp_drv);
STATIC void lv_disp_drv_t_gpu_wait_cb_callback(struct _disp_drv_t *disp_drv);
#define funcptr_gpu_blend_cb NULL


/*
 * lvgl extension definition for:
 * void gpu_blend_cb(struct _disp_drv_t *disp_drv, lv_color_t *dest, const lv_color_t *src, uint32_t length, lv_opa_t opa)
 */
 
STATIC mp_obj_t mp_funcptr_gpu_blend_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _disp_drv_t *disp_drv = mp_to_ptr(mp_args[0]);
    lv_color_t *dest = mp_write_ptr_lv_color32_t(mp_args[1]);
    const lv_color_t *src = mp_write_ptr_lv_color32_t(mp_args[2]);
    uint32_t length = (uint32_t)mp_obj_get_int(mp_args[3]);
    lv_opa_t opa = (uint8_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(struct _disp_drv_t *, lv_color_t *, const lv_color_t *, uint32_t, lv_opa_t))lv_func_ptr)(disp_drv, dest, src, length, opa);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_gpu_blend_cb_obj, 5, mp_funcptr_gpu_blend_cb, funcptr_gpu_blend_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_gpu_blend_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_gpu_blend_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_disp_drv_t_gpu_blend_cb_callback(struct _disp_drv_t *disp_drv, lv_color_t *dest, const lv_color_t *src, uint32_t length, lv_opa_t opa);
#define funcptr_gpu_fill_cb NULL


/*
 * lvgl extension definition for:
 * void gpu_fill_cb(struct _disp_drv_t *disp_drv, lv_color_t *dest_buf, lv_coord_t dest_width, const lv_area_t *fill_area, lv_color_t color)
 */
 
STATIC mp_obj_t mp_funcptr_gpu_fill_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _disp_drv_t *disp_drv = mp_to_ptr(mp_args[0]);
    lv_color_t *dest_buf = mp_write_ptr_lv_color32_t(mp_args[1]);
    lv_coord_t dest_width = (int16_t)mp_obj_get_int(mp_args[2]);
    const lv_area_t *fill_area = mp_write_ptr_lv_area_t(mp_args[3]);
    lv_color_t color = mp_write_lv_color32_t(mp_args[4]);
    ((void (*)(struct _disp_drv_t *, lv_color_t *, lv_coord_t, const lv_area_t *, lv_color_t))lv_func_ptr)(disp_drv, dest_buf, dest_width, fill_area, color);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_gpu_fill_cb_obj, 5, mp_funcptr_gpu_fill_cb, funcptr_gpu_fill_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_gpu_fill_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_gpu_fill_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_disp_drv_t_gpu_fill_cb_callback(struct _disp_drv_t *disp_drv, lv_color_t *dest_buf, lv_coord_t dest_width, const lv_area_t *fill_area, lv_color_t color);

/*
 * Struct lv_disp_drv_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_disp_drv_t_type();

STATIC inline lv_disp_drv_t* mp_write_ptr_lv_disp_drv_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_disp_drv_t_type()));
    return (lv_disp_drv_t*)self->data;
}

#define mp_write_lv_disp_drv_t(struct_obj) *mp_write_ptr_lv_disp_drv_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_disp_drv_t(lv_disp_drv_t *field)
{
    return lv_to_mp_struct(get_mp_lv_disp_drv_t_type(), (void*)field);
}

#define mp_read_lv_disp_drv_t(field) mp_read_ptr_lv_disp_drv_t(copy_buffer(&field, sizeof(lv_disp_drv_t)))
#define mp_read_byref_lv_disp_drv_t(field) mp_read_ptr_lv_disp_drv_t(&field)

STATIC void mp_lv_disp_drv_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_disp_drv_t *data = (lv_disp_drv_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_hor_res: dest[0] = mp_obj_new_int(data->hor_res); break; // converting from lv_coord_t;
            case MP_QSTR_ver_res: dest[0] = mp_obj_new_int(data->ver_res); break; // converting from lv_coord_t;
            case MP_QSTR_buffer: dest[0] = mp_read_ptr_lv_disp_buf_t((void*)data->buffer); break; // converting from lv_disp_buf_t *;
            case MP_QSTR_antialiasing: dest[0] = mp_obj_new_int_from_uint(data->antialiasing); break; // converting from uint32_t;
            case MP_QSTR_rotated: dest[0] = mp_obj_new_int_from_uint(data->rotated); break; // converting from uint32_t;
            case MP_QSTR_dpi: dest[0] = mp_obj_new_int_from_uint(data->dpi); break; // converting from uint32_t;
            case MP_QSTR_flush_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_flush_cb_obj, (void*)data->flush_cb, lv_disp_drv_t_flush_cb_callback ,MP_QSTR_lv_disp_drv_t_flush_cb, data->user_data); break; // converting from callback void (*)(lv_disp_drv_t *disp_drv, lv_area_t *area, lv_color_t *color_p);
            case MP_QSTR_rounder_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_rounder_cb_obj, (void*)data->rounder_cb, lv_disp_drv_t_rounder_cb_callback ,MP_QSTR_lv_disp_drv_t_rounder_cb, data->user_data); break; // converting from callback void (*)(lv_disp_drv_t *disp_drv, lv_area_t *area);
            case MP_QSTR_set_px_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_set_px_cb_obj, (void*)data->set_px_cb, lv_disp_drv_t_set_px_cb_callback ,MP_QSTR_lv_disp_drv_t_set_px_cb, data->user_data); break; // converting from callback void (*)(lv_disp_drv_t *disp_drv, uint8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y, lv_color_t color, lv_opa_t opa);
            case MP_QSTR_monitor_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_monitor_cb_obj, (void*)data->monitor_cb, lv_disp_drv_t_monitor_cb_callback ,MP_QSTR_lv_disp_drv_t_monitor_cb, data->user_data); break; // converting from callback void (*)(lv_disp_drv_t *disp_drv, uint32_t time, uint32_t px);
            case MP_QSTR_wait_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_wait_cb_obj, (void*)data->wait_cb, lv_disp_drv_t_wait_cb_callback ,MP_QSTR_lv_disp_drv_t_wait_cb, data->user_data); break; // converting from callback void (*)(lv_disp_drv_t *disp_drv);
            case MP_QSTR_clean_dcache_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_wait_cb_obj, (void*)data->clean_dcache_cb, lv_disp_drv_t_clean_dcache_cb_callback ,MP_QSTR_lv_disp_drv_t_clean_dcache_cb, data->user_data); break; // converting from callback void (*)(lv_disp_drv_t *disp_drv);
            case MP_QSTR_gpu_wait_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_wait_cb_obj, (void*)data->gpu_wait_cb, lv_disp_drv_t_gpu_wait_cb_callback ,MP_QSTR_lv_disp_drv_t_gpu_wait_cb, data->user_data); break; // converting from callback void (*)(lv_disp_drv_t *disp_drv);
            case MP_QSTR_gpu_blend_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_gpu_blend_cb_obj, (void*)data->gpu_blend_cb, lv_disp_drv_t_gpu_blend_cb_callback ,MP_QSTR_lv_disp_drv_t_gpu_blend_cb, data->user_data); break; // converting from callback void (*)(lv_disp_drv_t *disp_drv, lv_color_t *dest, lv_color_t *src, uint32_t length, lv_opa_t opa);
            case MP_QSTR_gpu_fill_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_gpu_fill_cb_obj, (void*)data->gpu_fill_cb, lv_disp_drv_t_gpu_fill_cb_callback ,MP_QSTR_lv_disp_drv_t_gpu_fill_cb, data->user_data); break; // converting from callback void (*)(lv_disp_drv_t *disp_drv, lv_color_t *dest_buf, lv_coord_t dest_width, lv_area_t *fill_area, lv_color_t color);
            case MP_QSTR_color_chroma_key: dest[0] = mp_read_byref_lv_color32_t(data->color_chroma_key); break; // converting from lv_color_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp(data->user_data); break; // converting from lv_disp_drv_user_data_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_hor_res: data->hor_res = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_ver_res: data->ver_res = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_buffer: data->buffer = (void*)mp_write_ptr_lv_disp_buf_t(dest[1]); break; // converting to lv_disp_buf_t *;
                case MP_QSTR_antialiasing: data->antialiasing = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_rotated: data->rotated = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_dpi: data->dpi = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_flush_cb: data->flush_cb = (void*)mp_lv_callback(dest[1], lv_disp_drv_t_flush_cb_callback ,MP_QSTR_lv_disp_drv_t_flush_cb, &data->user_data); break; // converting to callback void (*)(lv_disp_drv_t *disp_drv, lv_area_t *area, lv_color_t *color_p);
                case MP_QSTR_rounder_cb: data->rounder_cb = (void*)mp_lv_callback(dest[1], lv_disp_drv_t_rounder_cb_callback ,MP_QSTR_lv_disp_drv_t_rounder_cb, &data->user_data); break; // converting to callback void (*)(lv_disp_drv_t *disp_drv, lv_area_t *area);
                case MP_QSTR_set_px_cb: data->set_px_cb = (void*)mp_lv_callback(dest[1], lv_disp_drv_t_set_px_cb_callback ,MP_QSTR_lv_disp_drv_t_set_px_cb, &data->user_data); break; // converting to callback void (*)(lv_disp_drv_t *disp_drv, uint8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y, lv_color_t color, lv_opa_t opa);
                case MP_QSTR_monitor_cb: data->monitor_cb = (void*)mp_lv_callback(dest[1], lv_disp_drv_t_monitor_cb_callback ,MP_QSTR_lv_disp_drv_t_monitor_cb, &data->user_data); break; // converting to callback void (*)(lv_disp_drv_t *disp_drv, uint32_t time, uint32_t px);
                case MP_QSTR_wait_cb: data->wait_cb = (void*)mp_lv_callback(dest[1], lv_disp_drv_t_wait_cb_callback ,MP_QSTR_lv_disp_drv_t_wait_cb, &data->user_data); break; // converting to callback void (*)(lv_disp_drv_t *disp_drv);
                case MP_QSTR_clean_dcache_cb: data->clean_dcache_cb = (void*)mp_lv_callback(dest[1], lv_disp_drv_t_clean_dcache_cb_callback ,MP_QSTR_lv_disp_drv_t_clean_dcache_cb, &data->user_data); break; // converting to callback void (*)(lv_disp_drv_t *disp_drv);
                case MP_QSTR_gpu_wait_cb: data->gpu_wait_cb = (void*)mp_lv_callback(dest[1], lv_disp_drv_t_gpu_wait_cb_callback ,MP_QSTR_lv_disp_drv_t_gpu_wait_cb, &data->user_data); break; // converting to callback void (*)(lv_disp_drv_t *disp_drv);
                case MP_QSTR_gpu_blend_cb: data->gpu_blend_cb = (void*)mp_lv_callback(dest[1], lv_disp_drv_t_gpu_blend_cb_callback ,MP_QSTR_lv_disp_drv_t_gpu_blend_cb, &data->user_data); break; // converting to callback void (*)(lv_disp_drv_t *disp_drv, lv_color_t *dest, lv_color_t *src, uint32_t length, lv_opa_t opa);
                case MP_QSTR_gpu_fill_cb: data->gpu_fill_cb = (void*)mp_lv_callback(dest[1], lv_disp_drv_t_gpu_fill_cb_callback ,MP_QSTR_lv_disp_drv_t_gpu_fill_cb, &data->user_data); break; // converting to callback void (*)(lv_disp_drv_t *disp_drv, lv_color_t *dest_buf, lv_coord_t dest_width, lv_area_t *fill_area, lv_color_t color);
                case MP_QSTR_color_chroma_key: data->color_chroma_key = mp_write_lv_color32_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_user_data: data->user_data = mp_to_ptr(dest[1]); break; // converting to lv_disp_drv_user_data_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_disp_drv_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_disp_drv_t");
}

STATIC const mp_obj_dict_t mp_lv_disp_drv_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_disp_drv_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_disp_drv_t,
    .print = mp_lv_disp_drv_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_disp_drv_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_disp_drv_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_disp_drv_t_type()
{
    return &mp_lv_disp_drv_t_type;
}
    
#define funcptr_lv_task_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_task_cb_t(struct _lv_task_t *)
 */
 
STATIC mp_obj_t mp_funcptr_lv_task_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_task_t *arg0 = mp_to_ptr(mp_args[0]);
    ((void (*)(struct _lv_task_t *))lv_func_ptr)(arg0);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_task_cb_t_obj, 1, mp_funcptr_lv_task_cb_t, funcptr_lv_task_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_task_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_task_cb_t_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_task_t_task_cb_callback(struct _lv_task_t *);

/*
 * Struct lv_task_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_task_t_type();

STATIC inline lv_task_t* mp_write_ptr_lv_task_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_task_t_type()));
    return (lv_task_t*)self->data;
}

#define mp_write_lv_task_t(struct_obj) *mp_write_ptr_lv_task_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_task_t(lv_task_t *field)
{
    return lv_to_mp_struct(get_mp_lv_task_t_type(), (void*)field);
}

#define mp_read_lv_task_t(field) mp_read_ptr_lv_task_t(copy_buffer(&field, sizeof(lv_task_t)))
#define mp_read_byref_lv_task_t(field) mp_read_ptr_lv_task_t(&field)

STATIC void mp_lv_task_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_task_t *data = (lv_task_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_period: dest[0] = mp_obj_new_int_from_uint(data->period); break; // converting from uint32_t;
            case MP_QSTR_last_run: dest[0] = mp_obj_new_int_from_uint(data->last_run); break; // converting from uint32_t;
            case MP_QSTR_task_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_task_cb_t_obj, data->task_cb, lv_task_t_task_cb_callback ,MP_QSTR_lv_task_t_task_cb, data->user_data); break; // converting from callback lv_task_cb_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            case MP_QSTR_repeat_count: dest[0] = mp_obj_new_int(data->repeat_count); break; // converting from int32_t;
            case MP_QSTR_prio: dest[0] = mp_obj_new_int_from_uint(data->prio); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_period: data->period = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_last_run: data->last_run = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_task_cb: data->task_cb = mp_lv_callback(dest[1], lv_task_t_task_cb_callback ,MP_QSTR_lv_task_t_task_cb, &data->user_data); break; // converting to callback lv_task_cb_t;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_repeat_count: data->repeat_count = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_prio: data->prio = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_task_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_task_t");
}

STATIC const mp_obj_dict_t mp_lv_task_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_task_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_task_t,
    .print = mp_lv_task_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_task_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_task_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_task_t_type()
{
    return &mp_lv_task_t_type;
}
    

/*
 * Struct lv_ll_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_ll_t_type();

STATIC inline lv_ll_t* mp_write_ptr_lv_ll_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_ll_t_type()));
    return (lv_ll_t*)self->data;
}

#define mp_write_lv_ll_t(struct_obj) *mp_write_ptr_lv_ll_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_ll_t(lv_ll_t *field)
{
    return lv_to_mp_struct(get_mp_lv_ll_t_type(), (void*)field);
}

#define mp_read_lv_ll_t(field) mp_read_ptr_lv_ll_t(copy_buffer(&field, sizeof(lv_ll_t)))
#define mp_read_byref_lv_ll_t(field) mp_read_ptr_lv_ll_t(&field)

STATIC void mp_lv_ll_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_ll_t *data = (lv_ll_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_n_size: dest[0] = mp_obj_new_int_from_uint(data->n_size); break; // converting from uint32_t;
            case MP_QSTR_head: dest[0] = ptr_to_mp((void*)data->head); break; // converting from lv_ll_node_t *;
            case MP_QSTR_tail: dest[0] = ptr_to_mp((void*)data->tail); break; // converting from lv_ll_node_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_n_size: data->n_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_head: data->head = (void*)mp_to_ptr(dest[1]); break; // converting to lv_ll_node_t *;
                case MP_QSTR_tail: data->tail = (void*)mp_to_ptr(dest[1]); break; // converting to lv_ll_node_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_ll_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_ll_t");
}

STATIC const mp_obj_dict_t mp_lv_ll_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_ll_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_ll_t,
    .print = mp_lv_ll_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_ll_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_ll_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_ll_t_type()
{
    return &mp_lv_ll_t_type;
}
    

/*
 * Array convertors for lv_area_t [32]
 */

STATIC lv_area_t *mp_arr_to_lv_area_t___32__(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    lv_area_t *lv_arr = (lv_area_t*)m_malloc(len * sizeof(lv_area_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = mp_write_lv_area_t(item);
    }
    return (lv_area_t *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_lv_area_t___32__(lv_area_t *arr)
{
    mp_obj_t obj_arr[32];
    for (size_t i=0; i<32; i++){
        obj_arr[i] = mp_read_lv_area_t(arr[i]);
    }
    return mp_obj_new_list(32, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * Array convertors for uint8_t [32]
 */

STATIC uint8_t *mp_arr_to_uint8_t___32__(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    uint8_t *lv_arr = (uint8_t*)m_malloc(len * sizeof(uint8_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (uint8_t)mp_obj_get_int(item);
    }
    return (uint8_t *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_uint8_t___32__(uint8_t *arr)
{
    mp_obj_t obj_arr[32];
    for (size_t i=0; i<32; i++){
        obj_arr[i] = mp_obj_new_int_from_uint(arr[i]);
    }
    return mp_obj_new_list(32, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * Struct lv_disp_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_disp_t_type();

STATIC inline lv_disp_t* mp_write_ptr_lv_disp_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_disp_t_type()));
    return (lv_disp_t*)self->data;
}

#define mp_write_lv_disp_t(struct_obj) *mp_write_ptr_lv_disp_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_disp_t(lv_disp_t *field)
{
    return lv_to_mp_struct(get_mp_lv_disp_t_type(), (void*)field);
}

#define mp_read_lv_disp_t(field) mp_read_ptr_lv_disp_t(copy_buffer(&field, sizeof(lv_disp_t)))
#define mp_read_byref_lv_disp_t(field) mp_read_ptr_lv_disp_t(&field)

STATIC void mp_lv_disp_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_disp_t *data = (lv_disp_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_driver: dest[0] = mp_read_byref_lv_disp_drv_t(data->driver); break; // converting from lv_disp_drv_t;
            case MP_QSTR_refr_task: dest[0] = mp_read_ptr_lv_task_t((void*)data->refr_task); break; // converting from lv_task_t *;
            case MP_QSTR_scr_ll: dest[0] = mp_read_byref_lv_ll_t(data->scr_ll); break; // converting from lv_ll_t;
            case MP_QSTR_act_scr: dest[0] = lv_to_mp((void*)data->act_scr); break; // converting from lv_obj_t *;
            case MP_QSTR_prev_scr: dest[0] = lv_to_mp((void*)data->prev_scr); break; // converting from lv_obj_t *;
            case MP_QSTR_scr_to_load: dest[0] = lv_to_mp((void*)data->scr_to_load); break; // converting from lv_obj_t *;
            case MP_QSTR_top_layer: dest[0] = lv_to_mp((void*)data->top_layer); break; // converting from lv_obj_t *;
            case MP_QSTR_sys_layer: dest[0] = lv_to_mp((void*)data->sys_layer); break; // converting from lv_obj_t *;
            case MP_QSTR_del_prev: dest[0] = mp_obj_new_int_from_uint(data->del_prev); break; // converting from uint8_t;
            case MP_QSTR_bg_color: dest[0] = mp_read_byref_lv_color32_t(data->bg_color); break; // converting from lv_color_t;
            case MP_QSTR_bg_img: dest[0] = ptr_to_mp((void*)data->bg_img); break; // converting from void *;
            case MP_QSTR_bg_opa: dest[0] = mp_obj_new_int_from_uint(data->bg_opa); break; // converting from lv_opa_t;
            case MP_QSTR_inv_areas: dest[0] = mp_arr_from_lv_area_t___32__(data->inv_areas); break; // converting from lv_area_t [32];
            case MP_QSTR_inv_area_joined: dest[0] = mp_arr_from_uint8_t___32__(data->inv_area_joined); break; // converting from uint8_t [32];
            case MP_QSTR_inv_p: dest[0] = mp_obj_new_int_from_uint(data->inv_p); break; // converting from uint32_t;
            case MP_QSTR_last_activity_time: dest[0] = mp_obj_new_int_from_uint(data->last_activity_time); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_driver: data->driver = mp_write_lv_disp_drv_t(dest[1]); break; // converting to lv_disp_drv_t;
                case MP_QSTR_refr_task: data->refr_task = (void*)mp_write_ptr_lv_task_t(dest[1]); break; // converting to lv_task_t *;
                case MP_QSTR_scr_ll: data->scr_ll = mp_write_lv_ll_t(dest[1]); break; // converting to lv_ll_t;
                case MP_QSTR_act_scr: data->act_scr = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_prev_scr: data->prev_scr = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_scr_to_load: data->scr_to_load = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_top_layer: data->top_layer = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_sys_layer: data->sys_layer = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_del_prev: data->del_prev = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_bg_color: data->bg_color = mp_write_lv_color32_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_bg_img: data->bg_img = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_bg_opa: data->bg_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_inv_areas: memcpy((void*)&data->inv_areas, mp_arr_to_lv_area_t___32__(dest[1]), sizeof(lv_area_t)*32); break; // converting to lv_area_t [32];
                case MP_QSTR_inv_area_joined: memcpy((void*)&data->inv_area_joined, mp_arr_to_uint8_t___32__(dest[1]), sizeof(uint8_t)*32); break; // converting to uint8_t [32];
                case MP_QSTR_inv_p: data->inv_p = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_last_activity_time: data->last_activity_time = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_disp_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_disp_t");
}

STATIC const mp_obj_dict_t mp_lv_disp_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_disp_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_disp_t,
    .print = mp_lv_disp_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_disp_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_disp_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_disp_t_type()
{
    return &mp_lv_disp_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_disp_t *lv_obj_get_disp(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_disp(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_disp_t * _res = ((lv_disp_t *(*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_read_ptr_lv_disp_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_disp_obj, 1, mp_lv_obj_get_disp, lv_obj_get_disp);
    
/* Reusing lv_obj_get_screen for lv_obj_get_parent */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_parent_obj, 1, mp_lv_obj_get_screen, lv_obj_get_parent);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_obj_get_child(const lv_obj_t *obj, const lv_obj_t *child)
 */
 
STATIC mp_obj_t mp_lv_obj_get_child(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_obj_t *child = mp_to_lv(mp_args[1]);
    lv_obj_t * _res = ((lv_obj_t *(*)(const lv_obj_t *, const lv_obj_t *))lv_func_ptr)(obj, child);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_child_obj, 2, mp_lv_obj_get_child, lv_obj_get_child);
    
/* Reusing lv_obj_get_child for lv_obj_get_child_back */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_child_back_obj, 2, mp_lv_obj_get_child, lv_obj_get_child_back);
    

/*
 * lvgl extension definition for:
 * uint16_t lv_obj_count_children(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_count_children(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint16_t _res = ((uint16_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_count_children_obj, 1, mp_lv_obj_count_children, lv_obj_count_children);
    
/* Reusing lv_obj_count_children for lv_obj_count_children_recursive */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_count_children_recursive_obj, 1, mp_lv_obj_count_children, lv_obj_count_children_recursive);
    

/*
 * lvgl extension definition for:
 * void lv_obj_get_coords(const lv_obj_t *obj, lv_area_t *cords_p)
 */
 
STATIC mp_obj_t mp_lv_obj_get_coords(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_area_t *cords_p = mp_write_ptr_lv_area_t(mp_args[1]);
    ((void (*)(const lv_obj_t *, lv_area_t *))lv_func_ptr)(obj, cords_p);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_coords_obj, 2, mp_lv_obj_get_coords, lv_obj_get_coords);
    
/* Reusing lv_obj_get_coords for lv_obj_get_inner_coords */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_inner_coords_obj, 2, mp_lv_obj_get_coords, lv_obj_get_inner_coords);
    

/*
 * lvgl extension definition for:
 * lv_coord_t lv_obj_get_x(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_x(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_coord_t _res = ((lv_coord_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_x_obj, 1, mp_lv_obj_get_x, lv_obj_get_x);
    
/* Reusing lv_obj_get_x for lv_obj_get_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_y_obj, 1, mp_lv_obj_get_x, lv_obj_get_y);
    
/* Reusing lv_obj_get_x for lv_obj_get_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_width_obj, 1, mp_lv_obj_get_x, lv_obj_get_width);
    
/* Reusing lv_obj_get_x for lv_obj_get_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_height_obj, 1, mp_lv_obj_get_x, lv_obj_get_height);
    
/* Reusing lv_obj_get_x for lv_obj_get_width_fit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_width_fit_obj, 1, mp_lv_obj_get_x, lv_obj_get_width_fit);
    
/* Reusing lv_obj_get_x for lv_obj_get_height_fit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_height_fit_obj, 1, mp_lv_obj_get_x, lv_obj_get_height_fit);
    

/*
 * lvgl extension definition for:
 * lv_coord_t lv_obj_get_height_margin(lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_height_margin(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_coord_t _res = ((lv_coord_t (*)(lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_height_margin_obj, 1, mp_lv_obj_get_height_margin, lv_obj_get_height_margin);
    
/* Reusing lv_obj_get_height_margin for lv_obj_get_width_margin */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_width_margin_obj, 1, mp_lv_obj_get_height_margin, lv_obj_get_width_margin);
    

/*
 * lvgl extension definition for:
 * lv_coord_t lv_obj_get_width_grid(lv_obj_t *obj, uint8_t div, uint8_t span)
 */
 
STATIC mp_obj_t mp_lv_obj_get_width_grid(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t div = (uint8_t)mp_obj_get_int(mp_args[1]);
    uint8_t span = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t _res = ((lv_coord_t (*)(lv_obj_t *, uint8_t, uint8_t))lv_func_ptr)(obj, div, span);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_width_grid_obj, 3, mp_lv_obj_get_width_grid, lv_obj_get_width_grid);
    
/* Reusing lv_obj_get_width_grid for lv_obj_get_height_grid */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_height_grid_obj, 3, mp_lv_obj_get_width_grid, lv_obj_get_height_grid);
    
/* Reusing lv_obj_is_visible for lv_obj_get_auto_realign */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_auto_realign_obj, 1, mp_lv_obj_is_visible, lv_obj_get_auto_realign);
    
/* Reusing lv_obj_get_x for lv_obj_get_ext_click_pad_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_ext_click_pad_left_obj, 1, mp_lv_obj_get_x, lv_obj_get_ext_click_pad_left);
    
/* Reusing lv_obj_get_x for lv_obj_get_ext_click_pad_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_ext_click_pad_right_obj, 1, mp_lv_obj_get_x, lv_obj_get_ext_click_pad_right);
    
/* Reusing lv_obj_get_x for lv_obj_get_ext_click_pad_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_ext_click_pad_top_obj, 1, mp_lv_obj_get_x, lv_obj_get_ext_click_pad_top);
    
/* Reusing lv_obj_get_x for lv_obj_get_ext_click_pad_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_ext_click_pad_bottom_obj, 1, mp_lv_obj_get_x, lv_obj_get_ext_click_pad_bottom);
    
/* Reusing lv_obj_get_x for lv_obj_get_ext_draw_pad */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_ext_draw_pad_obj, 1, mp_lv_obj_get_x, lv_obj_get_ext_draw_pad);
    

/*
 * Struct lv_style_list_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_style_list_t_type();

STATIC inline lv_style_list_t* mp_write_ptr_lv_style_list_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_style_list_t_type()));
    return (lv_style_list_t*)self->data;
}

#define mp_write_lv_style_list_t(struct_obj) *mp_write_ptr_lv_style_list_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_style_list_t(lv_style_list_t *field)
{
    return lv_to_mp_struct(get_mp_lv_style_list_t_type(), (void*)field);
}

#define mp_read_lv_style_list_t(field) mp_read_ptr_lv_style_list_t(copy_buffer(&field, sizeof(lv_style_list_t)))
#define mp_read_byref_lv_style_list_t(field) mp_read_ptr_lv_style_list_t(&field)

STATIC void mp_lv_style_list_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_style_list_t *data = (lv_style_list_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_style_list: dest[0] = ptr_to_mp((void*)data->style_list); break; // converting from lv_style_t **;
            case MP_QSTR_style_cnt: dest[0] = mp_obj_new_int_from_uint(data->style_cnt); break; // converting from uint32_t;
            case MP_QSTR_has_local: dest[0] = mp_obj_new_int_from_uint(data->has_local); break; // converting from uint32_t;
            case MP_QSTR_has_trans: dest[0] = mp_obj_new_int_from_uint(data->has_trans); break; // converting from uint32_t;
            case MP_QSTR_skip_trans: dest[0] = mp_obj_new_int_from_uint(data->skip_trans); break; // converting from uint32_t;
            case MP_QSTR_ignore_trans: dest[0] = mp_obj_new_int_from_uint(data->ignore_trans); break; // converting from uint32_t;
            case MP_QSTR_valid_cache: dest[0] = mp_obj_new_int_from_uint(data->valid_cache); break; // converting from uint32_t;
            case MP_QSTR_ignore_cache: dest[0] = mp_obj_new_int_from_uint(data->ignore_cache); break; // converting from uint32_t;
            case MP_QSTR_radius_zero: dest[0] = mp_obj_new_int_from_uint(data->radius_zero); break; // converting from uint32_t;
            case MP_QSTR_opa_scale_cover: dest[0] = mp_obj_new_int_from_uint(data->opa_scale_cover); break; // converting from uint32_t;
            case MP_QSTR_clip_corner_off: dest[0] = mp_obj_new_int_from_uint(data->clip_corner_off); break; // converting from uint32_t;
            case MP_QSTR_transform_all_zero: dest[0] = mp_obj_new_int_from_uint(data->transform_all_zero); break; // converting from uint32_t;
            case MP_QSTR_pad_all_zero: dest[0] = mp_obj_new_int_from_uint(data->pad_all_zero); break; // converting from uint32_t;
            case MP_QSTR_margin_all_zero: dest[0] = mp_obj_new_int_from_uint(data->margin_all_zero); break; // converting from uint32_t;
            case MP_QSTR_blend_mode_all_normal: dest[0] = mp_obj_new_int_from_uint(data->blend_mode_all_normal); break; // converting from uint32_t;
            case MP_QSTR_bg_opa_transp: dest[0] = mp_obj_new_int_from_uint(data->bg_opa_transp); break; // converting from uint32_t;
            case MP_QSTR_bg_opa_cover: dest[0] = mp_obj_new_int_from_uint(data->bg_opa_cover); break; // converting from uint32_t;
            case MP_QSTR_border_width_zero: dest[0] = mp_obj_new_int_from_uint(data->border_width_zero); break; // converting from uint32_t;
            case MP_QSTR_border_side_full: dest[0] = mp_obj_new_int_from_uint(data->border_side_full); break; // converting from uint32_t;
            case MP_QSTR_border_post_off: dest[0] = mp_obj_new_int_from_uint(data->border_post_off); break; // converting from uint32_t;
            case MP_QSTR_outline_width_zero: dest[0] = mp_obj_new_int_from_uint(data->outline_width_zero); break; // converting from uint32_t;
            case MP_QSTR_pattern_img_null: dest[0] = mp_obj_new_int_from_uint(data->pattern_img_null); break; // converting from uint32_t;
            case MP_QSTR_shadow_width_zero: dest[0] = mp_obj_new_int_from_uint(data->shadow_width_zero); break; // converting from uint32_t;
            case MP_QSTR_value_txt_str: dest[0] = mp_obj_new_int_from_uint(data->value_txt_str); break; // converting from uint32_t;
            case MP_QSTR_img_recolor_opa_transp: dest[0] = mp_obj_new_int_from_uint(data->img_recolor_opa_transp); break; // converting from uint32_t;
            case MP_QSTR_text_space_zero: dest[0] = mp_obj_new_int_from_uint(data->text_space_zero); break; // converting from uint32_t;
            case MP_QSTR_text_decor_none: dest[0] = mp_obj_new_int_from_uint(data->text_decor_none); break; // converting from uint32_t;
            case MP_QSTR_text_font_normal: dest[0] = mp_obj_new_int_from_uint(data->text_font_normal); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_style_list: data->style_list = (void*)mp_to_ptr(dest[1]); break; // converting to lv_style_t **;
                case MP_QSTR_style_cnt: data->style_cnt = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_has_local: data->has_local = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_has_trans: data->has_trans = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_skip_trans: data->skip_trans = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_ignore_trans: data->ignore_trans = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_valid_cache: data->valid_cache = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_ignore_cache: data->ignore_cache = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_radius_zero: data->radius_zero = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_opa_scale_cover: data->opa_scale_cover = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_clip_corner_off: data->clip_corner_off = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_transform_all_zero: data->transform_all_zero = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_pad_all_zero: data->pad_all_zero = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_margin_all_zero: data->margin_all_zero = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_blend_mode_all_normal: data->blend_mode_all_normal = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_bg_opa_transp: data->bg_opa_transp = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_bg_opa_cover: data->bg_opa_cover = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_border_width_zero: data->border_width_zero = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_border_side_full: data->border_side_full = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_border_post_off: data->border_post_off = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_outline_width_zero: data->outline_width_zero = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_pattern_img_null: data->pattern_img_null = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_shadow_width_zero: data->shadow_width_zero = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_value_txt_str: data->value_txt_str = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_img_recolor_opa_transp: data->img_recolor_opa_transp = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_text_space_zero: data->text_space_zero = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_text_decor_none: data->text_decor_none = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_text_font_normal: data->text_font_normal = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_style_list_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_style_list_t");
}

STATIC const mp_obj_dict_t mp_lv_style_list_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_style_list_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_style_list_t,
    .print = mp_lv_style_list_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_style_list_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_style_list_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_style_list_t_type()
{
    return &mp_lv_style_list_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_style_list_t *lv_obj_get_style_list(const lv_obj_t *obj, uint8_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_style_list(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_list_t * _res = ((lv_style_list_t *(*)(const lv_obj_t *, uint8_t))lv_func_ptr)(obj, part);
    return mp_read_ptr_lv_style_list_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_style_list_obj, 2, mp_lv_obj_get_style_list, lv_obj_get_style_list);
    

/*
 * lvgl extension definition for:
 * lv_style_t *lv_obj_get_local_style(lv_obj_t *obj, uint8_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_local_style(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_t * _res = ((lv_style_t *(*)(lv_obj_t *, uint8_t))lv_func_ptr)(obj, part);
    return mp_read_ptr_lv_style_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_local_style_obj, 2, mp_lv_obj_get_local_style, lv_obj_get_local_style);
    
/* Reusing lv_obj_is_visible for lv_obj_get_hidden */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_hidden_obj, 1, mp_lv_obj_is_visible, lv_obj_get_hidden);
    
/* Reusing lv_obj_is_visible for lv_obj_get_adv_hittest */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_adv_hittest_obj, 1, mp_lv_obj_is_visible, lv_obj_get_adv_hittest);
    
/* Reusing lv_obj_is_visible for lv_obj_get_click */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_click_obj, 1, mp_lv_obj_is_visible, lv_obj_get_click);
    
/* Reusing lv_obj_is_visible for lv_obj_get_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_top_obj, 1, mp_lv_obj_is_visible, lv_obj_get_top);
    
/* Reusing lv_obj_is_visible for lv_obj_get_drag */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_drag_obj, 1, mp_lv_obj_is_visible, lv_obj_get_drag);
    

/*
 * lvgl extension definition for:
 * lv_drag_dir_t lv_obj_get_drag_dir(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_drag_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_drag_dir_t _res = ((lv_drag_dir_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_drag_dir_obj, 1, mp_lv_obj_get_drag_dir, lv_obj_get_drag_dir);
    
/* Reusing lv_obj_is_visible for lv_obj_get_drag_throw */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_drag_throw_obj, 1, mp_lv_obj_is_visible, lv_obj_get_drag_throw);
    
/* Reusing lv_obj_is_visible for lv_obj_get_drag_parent */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_drag_parent_obj, 1, mp_lv_obj_is_visible, lv_obj_get_drag_parent);
    
/* Reusing lv_obj_is_visible for lv_obj_get_focus_parent */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_focus_parent_obj, 1, mp_lv_obj_is_visible, lv_obj_get_focus_parent);
    
/* Reusing lv_obj_is_visible for lv_obj_get_parent_event */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_parent_event_obj, 1, mp_lv_obj_is_visible, lv_obj_get_parent_event);
    
/* Reusing lv_obj_is_visible for lv_obj_get_gesture_parent */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_gesture_parent_obj, 1, mp_lv_obj_is_visible, lv_obj_get_gesture_parent);
    

/*
 * lvgl extension definition for:
 * lv_bidi_dir_t lv_obj_get_base_dir(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_base_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_bidi_dir_t _res = ((lv_bidi_dir_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_base_dir_obj, 1, mp_lv_obj_get_base_dir, lv_obj_get_base_dir);
    

/*
 * lvgl extension definition for:
 * uint8_t lv_obj_get_protect(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_protect(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t _res = ((uint8_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_protect_obj, 1, mp_lv_obj_get_protect, lv_obj_get_protect);
    
/* Reusing lv_obj_get_style_clip_corner for lv_obj_is_protected */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_is_protected_obj, 2, mp_lv_obj_get_style_clip_corner, lv_obj_is_protected);
    

/*
 * lvgl extension definition for:
 * lv_state_t lv_obj_get_state(const lv_obj_t *obj, uint8_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_state(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_state_t _res = ((lv_state_t (*)(const lv_obj_t *, uint8_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_state_obj, 2, mp_lv_obj_get_state, lv_obj_get_state);
    
#define funcptr_lv_signal_cb_t NULL


/*
 * lvgl extension definition for:
 * lv_res_t lv_signal_cb_t(struct _lv_obj_t *obj, lv_signal_t sign, void *param)
 */
 
STATIC mp_obj_t mp_funcptr_lv_signal_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_signal_t sign = (uint8_t)mp_obj_get_int(mp_args[1]);
    void *param = mp_to_ptr(mp_args[2]);
    lv_res_t _res = ((lv_res_t (*)(struct _lv_obj_t *, lv_signal_t, void *))lv_func_ptr)(obj, sign, param);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_funcptr_lv_signal_cb_t_obj, 3, mp_funcptr_lv_signal_cb_t, funcptr_lv_signal_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_signal_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_signal_cb_t_obj, func, NULL, MP_QSTR_, NULL); }


/*
 * lvgl extension definition for:
 * lv_signal_cb_t lv_obj_get_signal_cb(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_signal_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_signal_cb_t _res = ((lv_signal_cb_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_lv_funcptr_lv_signal_cb_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_signal_cb_obj, 1, mp_lv_obj_get_signal_cb, lv_obj_get_signal_cb);
    
#define funcptr_lv_design_cb_t NULL


/*
 * lvgl extension definition for:
 * lv_design_res_t lv_design_cb_t(struct _lv_obj_t *obj, const lv_area_t *clip_area, lv_design_mode_t mode)
 */
 
STATIC mp_obj_t mp_funcptr_lv_design_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_area_t *clip_area = mp_write_ptr_lv_area_t(mp_args[1]);
    lv_design_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_design_res_t _res = ((lv_design_res_t (*)(struct _lv_obj_t *, const lv_area_t *, lv_design_mode_t))lv_func_ptr)(obj, clip_area, mode);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_funcptr_lv_design_cb_t_obj, 3, mp_funcptr_lv_design_cb_t, funcptr_lv_design_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_design_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_design_cb_t_obj, func, NULL, MP_QSTR_, NULL); }


/*
 * lvgl extension definition for:
 * lv_design_cb_t lv_obj_get_design_cb(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_design_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_design_cb_t _res = ((lv_design_cb_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_lv_funcptr_lv_design_cb_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_design_cb_obj, 1, mp_lv_obj_get_design_cb, lv_obj_get_design_cb);
    
#define funcptr_lv_event_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_event_cb_t(struct _lv_obj_t *obj, lv_event_t event)
 */
 
STATIC mp_obj_t mp_funcptr_lv_event_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_event_t event = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(struct _lv_obj_t *, lv_event_t))lv_func_ptr)(obj, event);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_funcptr_lv_event_cb_t_obj, 2, mp_funcptr_lv_event_cb_t, funcptr_lv_event_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_event_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_event_cb_t_obj, func, NULL, MP_QSTR_, NULL); }


/*
 * lvgl extension definition for:
 * lv_event_cb_t lv_obj_get_event_cb(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_event_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_event_cb_t _res = ((lv_event_cb_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return mp_lv_funcptr_lv_event_cb_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_event_cb_obj, 1, mp_lv_obj_get_event_cb, lv_obj_get_event_cb);
    

/*
 * Struct lv_point_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_point_t_type();

STATIC inline lv_point_t* mp_write_ptr_lv_point_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_point_t_type()));
    return (lv_point_t*)self->data;
}

#define mp_write_lv_point_t(struct_obj) *mp_write_ptr_lv_point_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_point_t(lv_point_t *field)
{
    return lv_to_mp_struct(get_mp_lv_point_t_type(), (void*)field);
}

#define mp_read_lv_point_t(field) mp_read_ptr_lv_point_t(copy_buffer(&field, sizeof(lv_point_t)))
#define mp_read_byref_lv_point_t(field) mp_read_ptr_lv_point_t(&field)

STATIC void mp_lv_point_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_point_t *data = (lv_point_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_x: dest[0] = mp_obj_new_int(data->x); break; // converting from lv_coord_t;
            case MP_QSTR_y: dest[0] = mp_obj_new_int(data->y); break; // converting from lv_coord_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_x: data->x = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_y: data->y = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_point_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_point_t");
}

STATIC const mp_obj_dict_t mp_lv_point_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_point_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_point_t,
    .print = mp_lv_point_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_point_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_point_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_point_t_type()
{
    return &mp_lv_point_t_type;
}
    

/*
 * lvgl extension definition for:
 * bool lv_obj_is_point_on_coords(lv_obj_t *obj, const lv_point_t *point)
 */
 
STATIC mp_obj_t mp_lv_obj_is_point_on_coords(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const lv_point_t *point = mp_write_ptr_lv_point_t(mp_args[1]);
    bool _res = ((bool (*)(lv_obj_t *, const lv_point_t *))lv_func_ptr)(obj, point);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_is_point_on_coords_obj, 2, mp_lv_obj_is_point_on_coords, lv_obj_is_point_on_coords);
    

/*
 * lvgl extension definition for:
 * bool lv_obj_hittest(lv_obj_t *obj, lv_point_t *point)
 */
 
STATIC mp_obj_t mp_lv_obj_hittest(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_point_t *point = mp_write_ptr_lv_point_t(mp_args[1]);
    bool _res = ((bool (*)(lv_obj_t *, lv_point_t *))lv_func_ptr)(obj, point);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_hittest_obj, 2, mp_lv_obj_hittest, lv_obj_hittest);
    

/*
 * lvgl extension definition for:
 * void *lv_obj_get_ext_attr(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_ext_attr(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    void * _res = ((void *(*)(const lv_obj_t *))lv_func_ptr)(obj);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_ext_attr_obj, 1, mp_lv_obj_get_ext_attr, lv_obj_get_ext_attr);
    

/*
 * Array convertors for char *[8]
 */

STATIC const char * *mp_arr_to_char_ptr__8__(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    //TODO check dim!
    char * *lv_arr = (char **)m_malloc(len * sizeof(char *));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (char*)convert_from_str(item);
    }
    return (const char * *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_char_ptr__8__(const char * *arr)
{
    mp_obj_t obj_arr[8];
    for (size_t i=0; i<8; i++){
        obj_arr[i] = convert_to_str(arr[i]);
    }
    return mp_obj_new_list(8, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * Struct lv_obj_type_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_obj_type_t_type();

STATIC inline lv_obj_type_t* mp_write_ptr_lv_obj_type_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_obj_type_t_type()));
    return (lv_obj_type_t*)self->data;
}

#define mp_write_lv_obj_type_t(struct_obj) *mp_write_ptr_lv_obj_type_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_obj_type_t(lv_obj_type_t *field)
{
    return lv_to_mp_struct(get_mp_lv_obj_type_t_type(), (void*)field);
}

#define mp_read_lv_obj_type_t(field) mp_read_ptr_lv_obj_type_t(copy_buffer(&field, sizeof(lv_obj_type_t)))
#define mp_read_byref_lv_obj_type_t(field) mp_read_ptr_lv_obj_type_t(&field)

STATIC void mp_lv_obj_type_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_obj_type_t *data = (lv_obj_type_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_type: dest[0] = mp_arr_from_char_ptr__8__(data->type); break; // converting from char *[8];
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_type: memcpy((void*)&data->type, mp_arr_to_char_ptr__8__(dest[1]), sizeof(const char *)*8); break; // converting to char *[8];
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_obj_type_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_obj_type_t");
}

STATIC const mp_obj_dict_t mp_lv_obj_type_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_obj_type_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_obj_type_t,
    .print = mp_lv_obj_type_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_obj_type_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_obj_type_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_obj_type_t_type()
{
    return &mp_lv_obj_type_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_obj_get_type(const lv_obj_t *obj, lv_obj_type_t *buf)
 */
 
STATIC mp_obj_t mp_lv_obj_get_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_obj_type_t *buf = mp_write_ptr_lv_obj_type_t(mp_args[1]);
    ((void (*)(const lv_obj_t *, lv_obj_type_t *))lv_func_ptr)(obj, buf);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_type_obj, 2, mp_lv_obj_get_type, lv_obj_get_type);
    

/*
 * lvgl extension definition for:
 * lv_obj_user_data_t lv_obj_get_user_data(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_obj_user_data_t _res = ((lv_obj_user_data_t (*)(const lv_obj_t *))lv_func_ptr)(obj);
    return ptr_to_mp(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_user_data_obj, 1, mp_lv_obj_get_user_data, lv_obj_get_user_data);
    

/*
 * lvgl extension definition for:
 * lv_obj_user_data_t *lv_obj_get_user_data_ptr(const lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_obj_get_user_data_ptr(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_obj_user_data_t * _res = ((lv_obj_user_data_t *(*)(const lv_obj_t *))lv_func_ptr)(obj);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_user_data_ptr_obj, 1, mp_lv_obj_get_user_data_ptr, lv_obj_get_user_data_ptr);
    

/*
 * lvgl extension definition for:
 * void lv_obj_set_user_data(lv_obj_t *obj, lv_obj_user_data_t data)
 */
 
STATIC mp_obj_t mp_lv_obj_set_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_obj_user_data_t data = mp_to_ptr(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_obj_user_data_t))lv_func_ptr)(obj, data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_set_user_data_obj, 2, mp_lv_obj_set_user_data, lv_obj_set_user_data);
    
/* Reusing lv_obj_get_ext_attr for lv_obj_get_group */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_group_obj, 1, mp_lv_obj_get_ext_attr, lv_obj_get_group);
    
/* Reusing lv_obj_is_visible for lv_obj_is_focused */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_is_focused_obj, 1, mp_lv_obj_is_visible, lv_obj_is_focused);
    
/* Reusing lv_obj_get_screen for lv_obj_get_focused_obj */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_focused_obj_obj, 1, mp_lv_obj_get_screen, lv_obj_get_focused_obj);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_obj_handle_get_type_signal(lv_obj_type_t *buf, const char *name)
 */
 
STATIC mp_obj_t mp_lv_obj_handle_get_type_signal(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_type_t *buf = mp_write_ptr_lv_obj_type_t(mp_args[0]);
    const char *name = (char*)convert_from_str(mp_args[1]);
    lv_res_t _res = ((lv_res_t (*)(lv_obj_type_t *, const char *))lv_func_ptr)(buf, name);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_handle_get_type_signal_obj, 2, mp_lv_obj_handle_get_type_signal, lv_obj_handle_get_type_signal);
    

/*
 * Struct lv_draw_rect_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_rect_dsc_t_type();

STATIC inline lv_draw_rect_dsc_t* mp_write_ptr_lv_draw_rect_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_rect_dsc_t_type()));
    return (lv_draw_rect_dsc_t*)self->data;
}

#define mp_write_lv_draw_rect_dsc_t(struct_obj) *mp_write_ptr_lv_draw_rect_dsc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_rect_dsc_t(lv_draw_rect_dsc_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_rect_dsc_t_type(), (void*)field);
}

#define mp_read_lv_draw_rect_dsc_t(field) mp_read_ptr_lv_draw_rect_dsc_t(copy_buffer(&field, sizeof(lv_draw_rect_dsc_t)))
#define mp_read_byref_lv_draw_rect_dsc_t(field) mp_read_ptr_lv_draw_rect_dsc_t(&field)

STATIC void mp_lv_draw_rect_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_rect_dsc_t *data = (lv_draw_rect_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_radius: dest[0] = mp_obj_new_int(data->radius); break; // converting from lv_style_int_t;
            case MP_QSTR_bg_color: dest[0] = mp_read_byref_lv_color32_t(data->bg_color); break; // converting from lv_color_t;
            case MP_QSTR_bg_grad_color: dest[0] = mp_read_byref_lv_color32_t(data->bg_grad_color); break; // converting from lv_color_t;
            case MP_QSTR_bg_grad_dir: dest[0] = mp_obj_new_int_from_uint(data->bg_grad_dir); break; // converting from lv_grad_dir_t;
            case MP_QSTR_bg_main_color_stop: dest[0] = mp_obj_new_int(data->bg_main_color_stop); break; // converting from lv_style_int_t;
            case MP_QSTR_bg_grad_color_stop: dest[0] = mp_obj_new_int(data->bg_grad_color_stop); break; // converting from lv_style_int_t;
            case MP_QSTR_bg_opa: dest[0] = mp_obj_new_int_from_uint(data->bg_opa); break; // converting from lv_opa_t;
            case MP_QSTR_bg_blend_mode: dest[0] = mp_obj_new_int_from_uint(data->bg_blend_mode); break; // converting from lv_blend_mode_t;
            case MP_QSTR_border_color: dest[0] = mp_read_byref_lv_color32_t(data->border_color); break; // converting from lv_color_t;
            case MP_QSTR_border_width: dest[0] = mp_obj_new_int(data->border_width); break; // converting from lv_style_int_t;
            case MP_QSTR_border_side: dest[0] = mp_obj_new_int(data->border_side); break; // converting from lv_style_int_t;
            case MP_QSTR_border_opa: dest[0] = mp_obj_new_int_from_uint(data->border_opa); break; // converting from lv_opa_t;
            case MP_QSTR_border_blend_mode: dest[0] = mp_obj_new_int_from_uint(data->border_blend_mode); break; // converting from lv_blend_mode_t;
            case MP_QSTR_border_post: dest[0] = mp_obj_new_int_from_uint(data->border_post); break; // converting from uint8_t;
            case MP_QSTR_outline_color: dest[0] = mp_read_byref_lv_color32_t(data->outline_color); break; // converting from lv_color_t;
            case MP_QSTR_outline_width: dest[0] = mp_obj_new_int(data->outline_width); break; // converting from lv_style_int_t;
            case MP_QSTR_outline_pad: dest[0] = mp_obj_new_int(data->outline_pad); break; // converting from lv_style_int_t;
            case MP_QSTR_outline_opa: dest[0] = mp_obj_new_int_from_uint(data->outline_opa); break; // converting from lv_opa_t;
            case MP_QSTR_outline_blend_mode: dest[0] = mp_obj_new_int_from_uint(data->outline_blend_mode); break; // converting from lv_blend_mode_t;
            case MP_QSTR_shadow_color: dest[0] = mp_read_byref_lv_color32_t(data->shadow_color); break; // converting from lv_color_t;
            case MP_QSTR_shadow_width: dest[0] = mp_obj_new_int(data->shadow_width); break; // converting from lv_style_int_t;
            case MP_QSTR_shadow_ofs_x: dest[0] = mp_obj_new_int(data->shadow_ofs_x); break; // converting from lv_style_int_t;
            case MP_QSTR_shadow_ofs_y: dest[0] = mp_obj_new_int(data->shadow_ofs_y); break; // converting from lv_style_int_t;
            case MP_QSTR_shadow_spread: dest[0] = mp_obj_new_int(data->shadow_spread); break; // converting from lv_style_int_t;
            case MP_QSTR_shadow_opa: dest[0] = mp_obj_new_int_from_uint(data->shadow_opa); break; // converting from lv_opa_t;
            case MP_QSTR_shadow_blend_mode: dest[0] = mp_obj_new_int_from_uint(data->shadow_blend_mode); break; // converting from lv_blend_mode_t;
            case MP_QSTR_pattern_image: dest[0] = ptr_to_mp((void*)data->pattern_image); break; // converting from void *;
            case MP_QSTR_pattern_font: dest[0] = mp_read_ptr_lv_font_t((void*)data->pattern_font); break; // converting from lv_font_t *;
            case MP_QSTR_pattern_recolor: dest[0] = mp_read_byref_lv_color32_t(data->pattern_recolor); break; // converting from lv_color_t;
            case MP_QSTR_pattern_opa: dest[0] = mp_obj_new_int_from_uint(data->pattern_opa); break; // converting from lv_opa_t;
            case MP_QSTR_pattern_recolor_opa: dest[0] = mp_obj_new_int_from_uint(data->pattern_recolor_opa); break; // converting from lv_opa_t;
            case MP_QSTR_pattern_repeat: dest[0] = mp_obj_new_int_from_uint(data->pattern_repeat); break; // converting from uint8_t;
            case MP_QSTR_pattern_blend_mode: dest[0] = mp_obj_new_int_from_uint(data->pattern_blend_mode); break; // converting from lv_blend_mode_t;
            case MP_QSTR_value_str: dest[0] = convert_to_str((void*)data->value_str); break; // converting from char *;
            case MP_QSTR_value_font: dest[0] = mp_read_ptr_lv_font_t((void*)data->value_font); break; // converting from lv_font_t *;
            case MP_QSTR_value_opa: dest[0] = mp_obj_new_int_from_uint(data->value_opa); break; // converting from lv_opa_t;
            case MP_QSTR_value_color: dest[0] = mp_read_byref_lv_color32_t(data->value_color); break; // converting from lv_color_t;
            case MP_QSTR_value_ofs_x: dest[0] = mp_obj_new_int(data->value_ofs_x); break; // converting from lv_style_int_t;
            case MP_QSTR_value_ofs_y: dest[0] = mp_obj_new_int(data->value_ofs_y); break; // converting from lv_style_int_t;
            case MP_QSTR_value_letter_space: dest[0] = mp_obj_new_int(data->value_letter_space); break; // converting from lv_style_int_t;
            case MP_QSTR_value_line_space: dest[0] = mp_obj_new_int(data->value_line_space); break; // converting from lv_style_int_t;
            case MP_QSTR_value_align: dest[0] = mp_obj_new_int_from_uint(data->value_align); break; // converting from lv_align_t;
            case MP_QSTR_value_blend_mode: dest[0] = mp_obj_new_int_from_uint(data->value_blend_mode); break; // converting from lv_blend_mode_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_radius: data->radius = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_style_int_t;
                case MP_QSTR_bg_color: data->bg_color = mp_write_lv_color32_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_bg_grad_color: data->bg_grad_color = mp_write_lv_color32_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_bg_grad_dir: data->bg_grad_dir = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_grad_dir_t;
                case MP_QSTR_bg_main_color_stop: data->bg_main_color_stop = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_style_int_t;
                case MP_QSTR_bg_grad_color_stop: data->bg_grad_color_stop = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_style_int_t;
                case MP_QSTR_bg_opa: data->bg_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_bg_blend_mode: data->bg_blend_mode = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_blend_mode_t;
                case MP_QSTR_border_color: data->border_color = mp_write_lv_color32_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_border_width: data->border_width = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_style_int_t;
                case MP_QSTR_border_side: data->border_side = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_style_int_t;
                case MP_QSTR_border_opa: data->border_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_border_blend_mode: data->border_blend_mode = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_blend_mode_t;
                case MP_QSTR_border_post: data->border_post = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_outline_color: data->outline_color = mp_write_lv_color32_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_outline_width: data->outline_width = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_style_int_t;
                case MP_QSTR_outline_pad: data->outline_pad = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_style_int_t;
                case MP_QSTR_outline_opa: data->outline_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_outline_blend_mode: data->outline_blend_mode = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_blend_mode_t;
                case MP_QSTR_shadow_color: data->shadow_color = mp_write_lv_color32_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_shadow_width: data->shadow_width = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_style_int_t;
                case MP_QSTR_shadow_ofs_x: data->shadow_ofs_x = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_style_int_t;
                case MP_QSTR_shadow_ofs_y: data->shadow_ofs_y = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_style_int_t;
                case MP_QSTR_shadow_spread: data->shadow_spread = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_style_int_t;
                case MP_QSTR_shadow_opa: data->shadow_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_shadow_blend_mode: data->shadow_blend_mode = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_blend_mode_t;
                case MP_QSTR_pattern_image: data->pattern_image = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_pattern_font: data->pattern_font = (void*)mp_write_ptr_lv_font_t(dest[1]); break; // converting to lv_font_t *;
                case MP_QSTR_pattern_recolor: data->pattern_recolor = mp_write_lv_color32_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_pattern_opa: data->pattern_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_pattern_recolor_opa: data->pattern_recolor_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_pattern_repeat: data->pattern_repeat = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_pattern_blend_mode: data->pattern_blend_mode = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_blend_mode_t;
                case MP_QSTR_value_str: data->value_str = (void*)(char*)convert_from_str(dest[1]); break; // converting to char *;
                case MP_QSTR_value_font: data->value_font = (void*)mp_write_ptr_lv_font_t(dest[1]); break; // converting to lv_font_t *;
                case MP_QSTR_value_opa: data->value_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_value_color: data->value_color = mp_write_lv_color32_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_value_ofs_x: data->value_ofs_x = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_style_int_t;
                case MP_QSTR_value_ofs_y: data->value_ofs_y = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_style_int_t;
                case MP_QSTR_value_letter_space: data->value_letter_space = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_style_int_t;
                case MP_QSTR_value_line_space: data->value_line_space = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_style_int_t;
                case MP_QSTR_value_align: data->value_align = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_align_t;
                case MP_QSTR_value_blend_mode: data->value_blend_mode = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_blend_mode_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_rect_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_rect_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_rect_dsc_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_rect_dsc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_rect_dsc_t,
    .print = mp_lv_draw_rect_dsc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_rect_dsc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_rect_dsc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_rect_dsc_t_type()
{
    return &mp_lv_draw_rect_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_obj_init_draw_rect_dsc(lv_obj_t *obj, uint8_t type, lv_draw_rect_dsc_t *draw_dsc)
 */
 
STATIC mp_obj_t mp_lv_obj_init_draw_rect_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t type = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_draw_rect_dsc_t *draw_dsc = mp_write_ptr_lv_draw_rect_dsc_t(mp_args[2]);
    ((void (*)(lv_obj_t *, uint8_t, lv_draw_rect_dsc_t *))lv_func_ptr)(obj, type, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_init_draw_rect_dsc_obj, 3, mp_lv_obj_init_draw_rect_dsc, lv_obj_init_draw_rect_dsc);
    

/*
 * Struct lv_draw_label_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_label_dsc_t_type();

STATIC inline lv_draw_label_dsc_t* mp_write_ptr_lv_draw_label_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_label_dsc_t_type()));
    return (lv_draw_label_dsc_t*)self->data;
}

#define mp_write_lv_draw_label_dsc_t(struct_obj) *mp_write_ptr_lv_draw_label_dsc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_label_dsc_t(lv_draw_label_dsc_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_label_dsc_t_type(), (void*)field);
}

#define mp_read_lv_draw_label_dsc_t(field) mp_read_ptr_lv_draw_label_dsc_t(copy_buffer(&field, sizeof(lv_draw_label_dsc_t)))
#define mp_read_byref_lv_draw_label_dsc_t(field) mp_read_ptr_lv_draw_label_dsc_t(&field)

STATIC void mp_lv_draw_label_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_label_dsc_t *data = (lv_draw_label_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color32_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_sel_color: dest[0] = mp_read_byref_lv_color32_t(data->sel_color); break; // converting from lv_color_t;
            case MP_QSTR_sel_bg_color: dest[0] = mp_read_byref_lv_color32_t(data->sel_bg_color); break; // converting from lv_color_t;
            case MP_QSTR_font: dest[0] = mp_read_ptr_lv_font_t((void*)data->font); break; // converting from lv_font_t *;
            case MP_QSTR_opa: dest[0] = mp_obj_new_int_from_uint(data->opa); break; // converting from lv_opa_t;
            case MP_QSTR_line_space: dest[0] = mp_obj_new_int(data->line_space); break; // converting from lv_style_int_t;
            case MP_QSTR_letter_space: dest[0] = mp_obj_new_int(data->letter_space); break; // converting from lv_style_int_t;
            case MP_QSTR_sel_start: dest[0] = mp_obj_new_int_from_uint(data->sel_start); break; // converting from uint32_t;
            case MP_QSTR_sel_end: dest[0] = mp_obj_new_int_from_uint(data->sel_end); break; // converting from uint32_t;
            case MP_QSTR_ofs_x: dest[0] = mp_obj_new_int(data->ofs_x); break; // converting from lv_coord_t;
            case MP_QSTR_ofs_y: dest[0] = mp_obj_new_int(data->ofs_y); break; // converting from lv_coord_t;
            case MP_QSTR_bidi_dir: dest[0] = mp_obj_new_int_from_uint(data->bidi_dir); break; // converting from lv_bidi_dir_t;
            case MP_QSTR_flag: dest[0] = mp_obj_new_int_from_uint(data->flag); break; // converting from lv_txt_flag_t;
            case MP_QSTR_decor: dest[0] = mp_obj_new_int_from_uint(data->decor); break; // converting from lv_text_decor_t;
            case MP_QSTR_blend_mode: dest[0] = mp_obj_new_int_from_uint(data->blend_mode); break; // converting from lv_blend_mode_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_color: data->color = mp_write_lv_color32_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_sel_color: data->sel_color = mp_write_lv_color32_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_sel_bg_color: data->sel_bg_color = mp_write_lv_color32_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_font: data->font = (void*)mp_write_ptr_lv_font_t(dest[1]); break; // converting to lv_font_t *;
                case MP_QSTR_opa: data->opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_line_space: data->line_space = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_style_int_t;
                case MP_QSTR_letter_space: data->letter_space = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_style_int_t;
                case MP_QSTR_sel_start: data->sel_start = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_sel_end: data->sel_end = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_ofs_x: data->ofs_x = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_ofs_y: data->ofs_y = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_bidi_dir: data->bidi_dir = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_bidi_dir_t;
                case MP_QSTR_flag: data->flag = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_txt_flag_t;
                case MP_QSTR_decor: data->decor = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_text_decor_t;
                case MP_QSTR_blend_mode: data->blend_mode = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_blend_mode_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_label_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_label_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_label_dsc_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_label_dsc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_label_dsc_t,
    .print = mp_lv_draw_label_dsc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_label_dsc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_label_dsc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_label_dsc_t_type()
{
    return &mp_lv_draw_label_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_obj_init_draw_label_dsc(lv_obj_t *obj, uint8_t type, lv_draw_label_dsc_t *draw_dsc)
 */
 
STATIC mp_obj_t mp_lv_obj_init_draw_label_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t type = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_draw_label_dsc_t *draw_dsc = mp_write_ptr_lv_draw_label_dsc_t(mp_args[2]);
    ((void (*)(lv_obj_t *, uint8_t, lv_draw_label_dsc_t *))lv_func_ptr)(obj, type, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_init_draw_label_dsc_obj, 3, mp_lv_obj_init_draw_label_dsc, lv_obj_init_draw_label_dsc);
    

/*
 * Struct lv_draw_img_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_img_dsc_t_type();

STATIC inline lv_draw_img_dsc_t* mp_write_ptr_lv_draw_img_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_img_dsc_t_type()));
    return (lv_draw_img_dsc_t*)self->data;
}

#define mp_write_lv_draw_img_dsc_t(struct_obj) *mp_write_ptr_lv_draw_img_dsc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_img_dsc_t(lv_draw_img_dsc_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_img_dsc_t_type(), (void*)field);
}

#define mp_read_lv_draw_img_dsc_t(field) mp_read_ptr_lv_draw_img_dsc_t(copy_buffer(&field, sizeof(lv_draw_img_dsc_t)))
#define mp_read_byref_lv_draw_img_dsc_t(field) mp_read_ptr_lv_draw_img_dsc_t(&field)

STATIC void mp_lv_draw_img_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_img_dsc_t *data = (lv_draw_img_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_opa: dest[0] = mp_obj_new_int_from_uint(data->opa); break; // converting from lv_opa_t;
            case MP_QSTR_angle: dest[0] = mp_obj_new_int_from_uint(data->angle); break; // converting from uint16_t;
            case MP_QSTR_pivot: dest[0] = mp_read_byref_lv_point_t(data->pivot); break; // converting from lv_point_t;
            case MP_QSTR_zoom: dest[0] = mp_obj_new_int_from_uint(data->zoom); break; // converting from uint16_t;
            case MP_QSTR_recolor_opa: dest[0] = mp_obj_new_int_from_uint(data->recolor_opa); break; // converting from lv_opa_t;
            case MP_QSTR_recolor: dest[0] = mp_read_byref_lv_color32_t(data->recolor); break; // converting from lv_color_t;
            case MP_QSTR_blend_mode: dest[0] = mp_obj_new_int_from_uint(data->blend_mode); break; // converting from lv_blend_mode_t;
            case MP_QSTR_antialias: dest[0] = mp_obj_new_int_from_uint(data->antialias); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_opa: data->opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_angle: data->angle = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_pivot: data->pivot = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_zoom: data->zoom = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_recolor_opa: data->recolor_opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_recolor: data->recolor = mp_write_lv_color32_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_blend_mode: data->blend_mode = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_blend_mode_t;
                case MP_QSTR_antialias: data->antialias = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_img_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_img_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_img_dsc_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_img_dsc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_img_dsc_t,
    .print = mp_lv_draw_img_dsc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_img_dsc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_img_dsc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_img_dsc_t_type()
{
    return &mp_lv_draw_img_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_obj_init_draw_img_dsc(lv_obj_t *obj, uint8_t part, lv_draw_img_dsc_t *draw_dsc)
 */
 
STATIC mp_obj_t mp_lv_obj_init_draw_img_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_draw_img_dsc_t *draw_dsc = mp_write_ptr_lv_draw_img_dsc_t(mp_args[2]);
    ((void (*)(lv_obj_t *, uint8_t, lv_draw_img_dsc_t *))lv_func_ptr)(obj, part, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_init_draw_img_dsc_obj, 3, mp_lv_obj_init_draw_img_dsc, lv_obj_init_draw_img_dsc);
    

/*
 * Struct lv_draw_line_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_line_dsc_t_type();

STATIC inline lv_draw_line_dsc_t* mp_write_ptr_lv_draw_line_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_line_dsc_t_type()));
    return (lv_draw_line_dsc_t*)self->data;
}

#define mp_write_lv_draw_line_dsc_t(struct_obj) *mp_write_ptr_lv_draw_line_dsc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_line_dsc_t(lv_draw_line_dsc_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_line_dsc_t_type(), (void*)field);
}

#define mp_read_lv_draw_line_dsc_t(field) mp_read_ptr_lv_draw_line_dsc_t(copy_buffer(&field, sizeof(lv_draw_line_dsc_t)))
#define mp_read_byref_lv_draw_line_dsc_t(field) mp_read_ptr_lv_draw_line_dsc_t(&field)

STATIC void mp_lv_draw_line_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_line_dsc_t *data = (lv_draw_line_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color32_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_width: dest[0] = mp_obj_new_int(data->width); break; // converting from lv_style_int_t;
            case MP_QSTR_dash_width: dest[0] = mp_obj_new_int(data->dash_width); break; // converting from lv_style_int_t;
            case MP_QSTR_dash_gap: dest[0] = mp_obj_new_int(data->dash_gap); break; // converting from lv_style_int_t;
            case MP_QSTR_opa: dest[0] = mp_obj_new_int_from_uint(data->opa); break; // converting from lv_opa_t;
            case MP_QSTR_blend_mode: dest[0] = mp_obj_new_int_from_uint(data->blend_mode); break; // converting from lv_blend_mode_t;
            case MP_QSTR_round_start: dest[0] = mp_obj_new_int_from_uint(data->round_start); break; // converting from uint8_t;
            case MP_QSTR_round_end: dest[0] = mp_obj_new_int_from_uint(data->round_end); break; // converting from uint8_t;
            case MP_QSTR_raw_end: dest[0] = mp_obj_new_int_from_uint(data->raw_end); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_color: data->color = mp_write_lv_color32_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_width: data->width = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_style_int_t;
                case MP_QSTR_dash_width: data->dash_width = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_style_int_t;
                case MP_QSTR_dash_gap: data->dash_gap = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_style_int_t;
                case MP_QSTR_opa: data->opa = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_blend_mode: data->blend_mode = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_blend_mode_t;
                case MP_QSTR_round_start: data->round_start = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_round_end: data->round_end = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_raw_end: data->raw_end = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_line_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_line_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_line_dsc_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_line_dsc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_line_dsc_t,
    .print = mp_lv_draw_line_dsc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_line_dsc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_line_dsc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_line_dsc_t_type()
{
    return &mp_lv_draw_line_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_obj_init_draw_line_dsc(lv_obj_t *obj, uint8_t part, lv_draw_line_dsc_t *draw_dsc)
 */
 
STATIC mp_obj_t mp_lv_obj_init_draw_line_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_draw_line_dsc_t *draw_dsc = mp_write_ptr_lv_draw_line_dsc_t(mp_args[2]);
    ((void (*)(lv_obj_t *, uint8_t, lv_draw_line_dsc_t *))lv_func_ptr)(obj, part, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_init_draw_line_dsc_obj, 3, mp_lv_obj_init_draw_line_dsc, lv_obj_init_draw_line_dsc);
    

/*
 * lvgl extension definition for:
 * lv_coord_t lv_obj_get_draw_rect_ext_pad_size(lv_obj_t *obj, uint8_t part)
 */
 
STATIC mp_obj_t mp_lv_obj_get_draw_rect_ext_pad_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t _res = ((lv_coord_t (*)(lv_obj_t *, uint8_t))lv_func_ptr)(obj, part);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_get_draw_rect_ext_pad_size_obj, 2, mp_lv_obj_get_draw_rect_ext_pad_size, lv_obj_get_draw_rect_ext_pad_size);
    

/*
 * lvgl extension definition for:
 * void lv_obj_fade_in(lv_obj_t *obj, uint32_t time, uint32_t delay)
 */
 
STATIC mp_obj_t mp_lv_obj_fade_in(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    uint32_t time = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t delay = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint32_t, uint32_t))lv_func_ptr)(obj, time, delay);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_fade_in_obj, 3, mp_lv_obj_fade_in, lv_obj_fade_in);
    
/* Reusing lv_obj_fade_in for lv_obj_fade_out */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_obj_fade_out_obj, 3, mp_lv_obj_fade_in, lv_obj_fade_out);
    

/*
 * lvgl obj object definitions
 */
    

STATIC const mp_rom_map_elem_t obj_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_get_style_radius), MP_ROM_PTR(&mp_lv_obj_get_style_radius_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_radius), MP_ROM_PTR(&mp_lv_obj_set_style_local_radius_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_clip_corner), MP_ROM_PTR(&mp_lv_obj_get_style_clip_corner_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_clip_corner), MP_ROM_PTR(&mp_lv_obj_set_style_local_clip_corner_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_size), MP_ROM_PTR(&mp_lv_obj_get_style_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_size), MP_ROM_PTR(&mp_lv_obj_set_style_local_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transform_width), MP_ROM_PTR(&mp_lv_obj_get_style_transform_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_transform_width), MP_ROM_PTR(&mp_lv_obj_set_style_local_transform_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transform_height), MP_ROM_PTR(&mp_lv_obj_get_style_transform_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_transform_height), MP_ROM_PTR(&mp_lv_obj_set_style_local_transform_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transform_angle), MP_ROM_PTR(&mp_lv_obj_get_style_transform_angle_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_transform_angle), MP_ROM_PTR(&mp_lv_obj_set_style_local_transform_angle_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transform_zoom), MP_ROM_PTR(&mp_lv_obj_get_style_transform_zoom_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_transform_zoom), MP_ROM_PTR(&mp_lv_obj_set_style_local_transform_zoom_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_opa_scale), MP_ROM_PTR(&mp_lv_obj_get_style_opa_scale_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_opa_scale), MP_ROM_PTR(&mp_lv_obj_set_style_local_opa_scale_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_pad_top), MP_ROM_PTR(&mp_lv_obj_get_style_pad_top_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_pad_top), MP_ROM_PTR(&mp_lv_obj_set_style_local_pad_top_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_pad_bottom), MP_ROM_PTR(&mp_lv_obj_get_style_pad_bottom_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_pad_bottom), MP_ROM_PTR(&mp_lv_obj_set_style_local_pad_bottom_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_pad_left), MP_ROM_PTR(&mp_lv_obj_get_style_pad_left_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_pad_left), MP_ROM_PTR(&mp_lv_obj_set_style_local_pad_left_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_pad_right), MP_ROM_PTR(&mp_lv_obj_get_style_pad_right_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_pad_right), MP_ROM_PTR(&mp_lv_obj_set_style_local_pad_right_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_pad_inner), MP_ROM_PTR(&mp_lv_obj_get_style_pad_inner_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_pad_inner), MP_ROM_PTR(&mp_lv_obj_set_style_local_pad_inner_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_margin_top), MP_ROM_PTR(&mp_lv_obj_get_style_margin_top_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_margin_top), MP_ROM_PTR(&mp_lv_obj_set_style_local_margin_top_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_margin_bottom), MP_ROM_PTR(&mp_lv_obj_get_style_margin_bottom_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_margin_bottom), MP_ROM_PTR(&mp_lv_obj_set_style_local_margin_bottom_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_margin_left), MP_ROM_PTR(&mp_lv_obj_get_style_margin_left_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_margin_left), MP_ROM_PTR(&mp_lv_obj_set_style_local_margin_left_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_margin_right), MP_ROM_PTR(&mp_lv_obj_get_style_margin_right_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_margin_right), MP_ROM_PTR(&mp_lv_obj_set_style_local_margin_right_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_blend_mode), MP_ROM_PTR(&mp_lv_obj_get_style_bg_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_bg_blend_mode), MP_ROM_PTR(&mp_lv_obj_set_style_local_bg_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_main_stop), MP_ROM_PTR(&mp_lv_obj_get_style_bg_main_stop_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_bg_main_stop), MP_ROM_PTR(&mp_lv_obj_set_style_local_bg_main_stop_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_grad_stop), MP_ROM_PTR(&mp_lv_obj_get_style_bg_grad_stop_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_bg_grad_stop), MP_ROM_PTR(&mp_lv_obj_set_style_local_bg_grad_stop_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_grad_dir), MP_ROM_PTR(&mp_lv_obj_get_style_bg_grad_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_bg_grad_dir), MP_ROM_PTR(&mp_lv_obj_set_style_local_bg_grad_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_color), MP_ROM_PTR(&mp_lv_obj_get_style_bg_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_bg_color), MP_ROM_PTR(&mp_lv_obj_set_style_local_bg_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_grad_color), MP_ROM_PTR(&mp_lv_obj_get_style_bg_grad_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_bg_grad_color), MP_ROM_PTR(&mp_lv_obj_set_style_local_bg_grad_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_bg_opa), MP_ROM_PTR(&mp_lv_obj_get_style_bg_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_bg_opa), MP_ROM_PTR(&mp_lv_obj_set_style_local_bg_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_border_width), MP_ROM_PTR(&mp_lv_obj_get_style_border_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_border_width), MP_ROM_PTR(&mp_lv_obj_set_style_local_border_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_border_side), MP_ROM_PTR(&mp_lv_obj_get_style_border_side_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_border_side), MP_ROM_PTR(&mp_lv_obj_set_style_local_border_side_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_border_blend_mode), MP_ROM_PTR(&mp_lv_obj_get_style_border_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_border_blend_mode), MP_ROM_PTR(&mp_lv_obj_set_style_local_border_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_border_post), MP_ROM_PTR(&mp_lv_obj_get_style_border_post_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_border_post), MP_ROM_PTR(&mp_lv_obj_set_style_local_border_post_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_border_color), MP_ROM_PTR(&mp_lv_obj_get_style_border_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_border_color), MP_ROM_PTR(&mp_lv_obj_set_style_local_border_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_border_opa), MP_ROM_PTR(&mp_lv_obj_get_style_border_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_border_opa), MP_ROM_PTR(&mp_lv_obj_set_style_local_border_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_outline_width), MP_ROM_PTR(&mp_lv_obj_get_style_outline_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_outline_width), MP_ROM_PTR(&mp_lv_obj_set_style_local_outline_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_outline_pad), MP_ROM_PTR(&mp_lv_obj_get_style_outline_pad_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_outline_pad), MP_ROM_PTR(&mp_lv_obj_set_style_local_outline_pad_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_outline_blend_mode), MP_ROM_PTR(&mp_lv_obj_get_style_outline_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_outline_blend_mode), MP_ROM_PTR(&mp_lv_obj_set_style_local_outline_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_outline_color), MP_ROM_PTR(&mp_lv_obj_get_style_outline_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_outline_color), MP_ROM_PTR(&mp_lv_obj_set_style_local_outline_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_outline_opa), MP_ROM_PTR(&mp_lv_obj_get_style_outline_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_outline_opa), MP_ROM_PTR(&mp_lv_obj_set_style_local_outline_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_shadow_width), MP_ROM_PTR(&mp_lv_obj_get_style_shadow_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_shadow_width), MP_ROM_PTR(&mp_lv_obj_set_style_local_shadow_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_shadow_ofs_x), MP_ROM_PTR(&mp_lv_obj_get_style_shadow_ofs_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_shadow_ofs_x), MP_ROM_PTR(&mp_lv_obj_set_style_local_shadow_ofs_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_shadow_ofs_y), MP_ROM_PTR(&mp_lv_obj_get_style_shadow_ofs_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_shadow_ofs_y), MP_ROM_PTR(&mp_lv_obj_set_style_local_shadow_ofs_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_shadow_spread), MP_ROM_PTR(&mp_lv_obj_get_style_shadow_spread_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_shadow_spread), MP_ROM_PTR(&mp_lv_obj_set_style_local_shadow_spread_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_shadow_blend_mode), MP_ROM_PTR(&mp_lv_obj_get_style_shadow_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_shadow_blend_mode), MP_ROM_PTR(&mp_lv_obj_set_style_local_shadow_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_shadow_color), MP_ROM_PTR(&mp_lv_obj_get_style_shadow_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_shadow_color), MP_ROM_PTR(&mp_lv_obj_set_style_local_shadow_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_shadow_opa), MP_ROM_PTR(&mp_lv_obj_get_style_shadow_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_shadow_opa), MP_ROM_PTR(&mp_lv_obj_set_style_local_shadow_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_pattern_repeat), MP_ROM_PTR(&mp_lv_obj_get_style_pattern_repeat_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_pattern_repeat), MP_ROM_PTR(&mp_lv_obj_set_style_local_pattern_repeat_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_pattern_blend_mode), MP_ROM_PTR(&mp_lv_obj_get_style_pattern_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_pattern_blend_mode), MP_ROM_PTR(&mp_lv_obj_set_style_local_pattern_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_pattern_recolor), MP_ROM_PTR(&mp_lv_obj_get_style_pattern_recolor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_pattern_recolor), MP_ROM_PTR(&mp_lv_obj_set_style_local_pattern_recolor_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_pattern_opa), MP_ROM_PTR(&mp_lv_obj_get_style_pattern_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_pattern_opa), MP_ROM_PTR(&mp_lv_obj_set_style_local_pattern_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_pattern_recolor_opa), MP_ROM_PTR(&mp_lv_obj_get_style_pattern_recolor_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_pattern_recolor_opa), MP_ROM_PTR(&mp_lv_obj_set_style_local_pattern_recolor_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_pattern_image), MP_ROM_PTR(&mp_lv_obj_get_style_pattern_image_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_pattern_image), MP_ROM_PTR(&mp_lv_obj_set_style_local_pattern_image_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_value_letter_space), MP_ROM_PTR(&mp_lv_obj_get_style_value_letter_space_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_value_letter_space), MP_ROM_PTR(&mp_lv_obj_set_style_local_value_letter_space_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_value_line_space), MP_ROM_PTR(&mp_lv_obj_get_style_value_line_space_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_value_line_space), MP_ROM_PTR(&mp_lv_obj_set_style_local_value_line_space_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_value_blend_mode), MP_ROM_PTR(&mp_lv_obj_get_style_value_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_value_blend_mode), MP_ROM_PTR(&mp_lv_obj_set_style_local_value_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_value_ofs_x), MP_ROM_PTR(&mp_lv_obj_get_style_value_ofs_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_value_ofs_x), MP_ROM_PTR(&mp_lv_obj_set_style_local_value_ofs_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_value_ofs_y), MP_ROM_PTR(&mp_lv_obj_get_style_value_ofs_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_value_ofs_y), MP_ROM_PTR(&mp_lv_obj_set_style_local_value_ofs_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_value_align), MP_ROM_PTR(&mp_lv_obj_get_style_value_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_value_align), MP_ROM_PTR(&mp_lv_obj_set_style_local_value_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_value_color), MP_ROM_PTR(&mp_lv_obj_get_style_value_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_value_color), MP_ROM_PTR(&mp_lv_obj_set_style_local_value_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_value_opa), MP_ROM_PTR(&mp_lv_obj_get_style_value_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_value_opa), MP_ROM_PTR(&mp_lv_obj_set_style_local_value_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_value_font), MP_ROM_PTR(&mp_lv_obj_get_style_value_font_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_value_font), MP_ROM_PTR(&mp_lv_obj_set_style_local_value_font_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_value_str), MP_ROM_PTR(&mp_lv_obj_get_style_value_str_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_value_str), MP_ROM_PTR(&mp_lv_obj_set_style_local_value_str_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_letter_space), MP_ROM_PTR(&mp_lv_obj_get_style_text_letter_space_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_text_letter_space), MP_ROM_PTR(&mp_lv_obj_set_style_local_text_letter_space_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_line_space), MP_ROM_PTR(&mp_lv_obj_get_style_text_line_space_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_text_line_space), MP_ROM_PTR(&mp_lv_obj_set_style_local_text_line_space_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_decor), MP_ROM_PTR(&mp_lv_obj_get_style_text_decor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_text_decor), MP_ROM_PTR(&mp_lv_obj_set_style_local_text_decor_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_blend_mode), MP_ROM_PTR(&mp_lv_obj_get_style_text_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_text_blend_mode), MP_ROM_PTR(&mp_lv_obj_set_style_local_text_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_color), MP_ROM_PTR(&mp_lv_obj_get_style_text_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_text_color), MP_ROM_PTR(&mp_lv_obj_set_style_local_text_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_sel_color), MP_ROM_PTR(&mp_lv_obj_get_style_text_sel_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_text_sel_color), MP_ROM_PTR(&mp_lv_obj_set_style_local_text_sel_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_sel_bg_color), MP_ROM_PTR(&mp_lv_obj_get_style_text_sel_bg_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_text_sel_bg_color), MP_ROM_PTR(&mp_lv_obj_set_style_local_text_sel_bg_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_opa), MP_ROM_PTR(&mp_lv_obj_get_style_text_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_text_opa), MP_ROM_PTR(&mp_lv_obj_set_style_local_text_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_text_font), MP_ROM_PTR(&mp_lv_obj_get_style_text_font_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_text_font), MP_ROM_PTR(&mp_lv_obj_set_style_local_text_font_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_line_width), MP_ROM_PTR(&mp_lv_obj_get_style_line_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_line_width), MP_ROM_PTR(&mp_lv_obj_set_style_local_line_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_line_blend_mode), MP_ROM_PTR(&mp_lv_obj_get_style_line_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_line_blend_mode), MP_ROM_PTR(&mp_lv_obj_set_style_local_line_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_line_dash_width), MP_ROM_PTR(&mp_lv_obj_get_style_line_dash_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_line_dash_width), MP_ROM_PTR(&mp_lv_obj_set_style_local_line_dash_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_line_dash_gap), MP_ROM_PTR(&mp_lv_obj_get_style_line_dash_gap_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_line_dash_gap), MP_ROM_PTR(&mp_lv_obj_set_style_local_line_dash_gap_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_line_rounded), MP_ROM_PTR(&mp_lv_obj_get_style_line_rounded_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_line_rounded), MP_ROM_PTR(&mp_lv_obj_set_style_local_line_rounded_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_line_color), MP_ROM_PTR(&mp_lv_obj_get_style_line_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_line_color), MP_ROM_PTR(&mp_lv_obj_set_style_local_line_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_line_opa), MP_ROM_PTR(&mp_lv_obj_get_style_line_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_line_opa), MP_ROM_PTR(&mp_lv_obj_set_style_local_line_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_image_blend_mode), MP_ROM_PTR(&mp_lv_obj_get_style_image_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_image_blend_mode), MP_ROM_PTR(&mp_lv_obj_set_style_local_image_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_image_recolor), MP_ROM_PTR(&mp_lv_obj_get_style_image_recolor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_image_recolor), MP_ROM_PTR(&mp_lv_obj_set_style_local_image_recolor_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_image_opa), MP_ROM_PTR(&mp_lv_obj_get_style_image_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_image_opa), MP_ROM_PTR(&mp_lv_obj_set_style_local_image_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_image_recolor_opa), MP_ROM_PTR(&mp_lv_obj_get_style_image_recolor_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_image_recolor_opa), MP_ROM_PTR(&mp_lv_obj_set_style_local_image_recolor_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transition_time), MP_ROM_PTR(&mp_lv_obj_get_style_transition_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_transition_time), MP_ROM_PTR(&mp_lv_obj_set_style_local_transition_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transition_delay), MP_ROM_PTR(&mp_lv_obj_get_style_transition_delay_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_transition_delay), MP_ROM_PTR(&mp_lv_obj_set_style_local_transition_delay_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transition_prop_1), MP_ROM_PTR(&mp_lv_obj_get_style_transition_prop_1_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_transition_prop_1), MP_ROM_PTR(&mp_lv_obj_set_style_local_transition_prop_1_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transition_prop_2), MP_ROM_PTR(&mp_lv_obj_get_style_transition_prop_2_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_transition_prop_2), MP_ROM_PTR(&mp_lv_obj_set_style_local_transition_prop_2_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transition_prop_3), MP_ROM_PTR(&mp_lv_obj_get_style_transition_prop_3_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_transition_prop_3), MP_ROM_PTR(&mp_lv_obj_set_style_local_transition_prop_3_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transition_prop_4), MP_ROM_PTR(&mp_lv_obj_get_style_transition_prop_4_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_transition_prop_4), MP_ROM_PTR(&mp_lv_obj_set_style_local_transition_prop_4_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transition_prop_5), MP_ROM_PTR(&mp_lv_obj_get_style_transition_prop_5_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_transition_prop_5), MP_ROM_PTR(&mp_lv_obj_set_style_local_transition_prop_5_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transition_prop_6), MP_ROM_PTR(&mp_lv_obj_get_style_transition_prop_6_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_transition_prop_6), MP_ROM_PTR(&mp_lv_obj_set_style_local_transition_prop_6_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_transition_path), MP_ROM_PTR(&mp_lv_obj_get_style_transition_path_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_transition_path), MP_ROM_PTR(&mp_lv_obj_set_style_local_transition_path_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_scale_width), MP_ROM_PTR(&mp_lv_obj_get_style_scale_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_scale_width), MP_ROM_PTR(&mp_lv_obj_set_style_local_scale_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_scale_border_width), MP_ROM_PTR(&mp_lv_obj_get_style_scale_border_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_scale_border_width), MP_ROM_PTR(&mp_lv_obj_set_style_local_scale_border_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_scale_end_border_width), MP_ROM_PTR(&mp_lv_obj_get_style_scale_end_border_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_scale_end_border_width), MP_ROM_PTR(&mp_lv_obj_set_style_local_scale_end_border_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_scale_end_line_width), MP_ROM_PTR(&mp_lv_obj_get_style_scale_end_line_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_scale_end_line_width), MP_ROM_PTR(&mp_lv_obj_set_style_local_scale_end_line_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_scale_grad_color), MP_ROM_PTR(&mp_lv_obj_get_style_scale_grad_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_scale_grad_color), MP_ROM_PTR(&mp_lv_obj_set_style_local_scale_grad_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_scale_end_color), MP_ROM_PTR(&mp_lv_obj_get_style_scale_end_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_scale_end_color), MP_ROM_PTR(&mp_lv_obj_set_style_local_scale_end_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_pad_all), MP_ROM_PTR(&mp_lv_obj_set_style_local_pad_all_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_pad_hor), MP_ROM_PTR(&mp_lv_obj_set_style_local_pad_hor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_pad_ver), MP_ROM_PTR(&mp_lv_obj_set_style_local_pad_ver_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_margin_all), MP_ROM_PTR(&mp_lv_obj_set_style_local_margin_all_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_margin_hor), MP_ROM_PTR(&mp_lv_obj_set_style_local_margin_hor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_style_local_margin_ver), MP_ROM_PTR(&mp_lv_obj_set_style_local_margin_ver_obj) },
    { MP_ROM_QSTR(MP_QSTR_delete), MP_ROM_PTR(&mp_lv_obj_del_obj) },
    { MP_ROM_QSTR(MP_QSTR_del_anim_ready_cb), MP_ROM_PTR(&mp_lv_obj_del_anim_ready_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_del_async), MP_ROM_PTR(&mp_lv_obj_del_async_obj) },
    { MP_ROM_QSTR(MP_QSTR_clean), MP_ROM_PTR(&mp_lv_obj_clean_obj) },
    { MP_ROM_QSTR(MP_QSTR_invalidate_area), MP_ROM_PTR(&mp_lv_obj_invalidate_area_obj) },
    { MP_ROM_QSTR(MP_QSTR_invalidate), MP_ROM_PTR(&mp_lv_obj_invalidate_obj) },
    { MP_ROM_QSTR(MP_QSTR_area_is_visible), MP_ROM_PTR(&mp_lv_obj_area_is_visible_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_visible), MP_ROM_PTR(&mp_lv_obj_is_visible_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_parent), MP_ROM_PTR(&mp_lv_obj_set_parent_obj) },
    { MP_ROM_QSTR(MP_QSTR_move_foreground), MP_ROM_PTR(&mp_lv_obj_move_foreground_obj) },
    { MP_ROM_QSTR(MP_QSTR_move_background), MP_ROM_PTR(&mp_lv_obj_move_background_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pos), MP_ROM_PTR(&mp_lv_obj_set_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_x), MP_ROM_PTR(&mp_lv_obj_set_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_y), MP_ROM_PTR(&mp_lv_obj_set_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_size), MP_ROM_PTR(&mp_lv_obj_set_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_width), MP_ROM_PTR(&mp_lv_obj_set_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_height), MP_ROM_PTR(&mp_lv_obj_set_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_width_fit), MP_ROM_PTR(&mp_lv_obj_set_width_fit_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_height_fit), MP_ROM_PTR(&mp_lv_obj_set_height_fit_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_width_margin), MP_ROM_PTR(&mp_lv_obj_set_width_margin_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_height_margin), MP_ROM_PTR(&mp_lv_obj_set_height_margin_obj) },
    { MP_ROM_QSTR(MP_QSTR_align), MP_ROM_PTR(&mp_lv_obj_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_align_x), MP_ROM_PTR(&mp_lv_obj_align_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_align_y), MP_ROM_PTR(&mp_lv_obj_align_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_align_mid), MP_ROM_PTR(&mp_lv_obj_align_mid_obj) },
    { MP_ROM_QSTR(MP_QSTR_align_mid_x), MP_ROM_PTR(&mp_lv_obj_align_mid_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_align_mid_y), MP_ROM_PTR(&mp_lv_obj_align_mid_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_realign), MP_ROM_PTR(&mp_lv_obj_realign_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_auto_realign), MP_ROM_PTR(&mp_lv_obj_set_auto_realign_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_ext_click_area), MP_ROM_PTR(&mp_lv_obj_set_ext_click_area_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_style), MP_ROM_PTR(&mp_lv_obj_add_style_obj) },
    { MP_ROM_QSTR(MP_QSTR_remove_style), MP_ROM_PTR(&mp_lv_obj_remove_style_obj) },
    { MP_ROM_QSTR(MP_QSTR_clean_style_list), MP_ROM_PTR(&mp_lv_obj_clean_style_list_obj) },
    { MP_ROM_QSTR(MP_QSTR_reset_style_list), MP_ROM_PTR(&mp_lv_obj_reset_style_list_obj) },
    { MP_ROM_QSTR(MP_QSTR_refresh_style), MP_ROM_PTR(&mp_lv_obj_refresh_style_obj) },
    { MP_ROM_QSTR(MP_QSTR_report_style_mod), MP_ROM_PTR(&mp_lv_obj_report_style_mod_obj) },
    { MP_ROM_QSTR(MP_QSTR_remove_style_local_prop), MP_ROM_PTR(&mp_lv_obj_remove_style_local_prop_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_hidden), MP_ROM_PTR(&mp_lv_obj_set_hidden_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_adv_hittest), MP_ROM_PTR(&mp_lv_obj_set_adv_hittest_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_click), MP_ROM_PTR(&mp_lv_obj_set_click_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_top), MP_ROM_PTR(&mp_lv_obj_set_top_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_drag), MP_ROM_PTR(&mp_lv_obj_set_drag_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_drag_dir), MP_ROM_PTR(&mp_lv_obj_set_drag_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_drag_throw), MP_ROM_PTR(&mp_lv_obj_set_drag_throw_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_drag_parent), MP_ROM_PTR(&mp_lv_obj_set_drag_parent_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_focus_parent), MP_ROM_PTR(&mp_lv_obj_set_focus_parent_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_gesture_parent), MP_ROM_PTR(&mp_lv_obj_set_gesture_parent_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_parent_event), MP_ROM_PTR(&mp_lv_obj_set_parent_event_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_base_dir), MP_ROM_PTR(&mp_lv_obj_set_base_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_protect), MP_ROM_PTR(&mp_lv_obj_add_protect_obj) },
    { MP_ROM_QSTR(MP_QSTR_clear_protect), MP_ROM_PTR(&mp_lv_obj_clear_protect_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_state), MP_ROM_PTR(&mp_lv_obj_set_state_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_state), MP_ROM_PTR(&mp_lv_obj_add_state_obj) },
    { MP_ROM_QSTR(MP_QSTR_clear_state), MP_ROM_PTR(&mp_lv_obj_clear_state_obj) },
    { MP_ROM_QSTR(MP_QSTR_finish_transitions), MP_ROM_PTR(&mp_lv_obj_finish_transitions_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_event_cb), MP_ROM_PTR(&mp_lv_obj_set_event_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_signal_cb), MP_ROM_PTR(&mp_lv_obj_set_signal_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_design_cb), MP_ROM_PTR(&mp_lv_obj_set_design_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_allocate_ext_attr), MP_ROM_PTR(&mp_lv_obj_allocate_ext_attr_obj) },
    { MP_ROM_QSTR(MP_QSTR_refresh_ext_draw_pad), MP_ROM_PTR(&mp_lv_obj_refresh_ext_draw_pad_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_screen), MP_ROM_PTR(&mp_lv_obj_get_screen_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_disp), MP_ROM_PTR(&mp_lv_obj_get_disp_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_parent), MP_ROM_PTR(&mp_lv_obj_get_parent_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_child), MP_ROM_PTR(&mp_lv_obj_get_child_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_child_back), MP_ROM_PTR(&mp_lv_obj_get_child_back_obj) },
    { MP_ROM_QSTR(MP_QSTR_count_children), MP_ROM_PTR(&mp_lv_obj_count_children_obj) },
    { MP_ROM_QSTR(MP_QSTR_count_children_recursive), MP_ROM_PTR(&mp_lv_obj_count_children_recursive_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_coords), MP_ROM_PTR(&mp_lv_obj_get_coords_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_inner_coords), MP_ROM_PTR(&mp_lv_obj_get_inner_coords_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_x), MP_ROM_PTR(&mp_lv_obj_get_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_y), MP_ROM_PTR(&mp_lv_obj_get_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_width), MP_ROM_PTR(&mp_lv_obj_get_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_height), MP_ROM_PTR(&mp_lv_obj_get_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_width_fit), MP_ROM_PTR(&mp_lv_obj_get_width_fit_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_height_fit), MP_ROM_PTR(&mp_lv_obj_get_height_fit_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_height_margin), MP_ROM_PTR(&mp_lv_obj_get_height_margin_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_width_margin), MP_ROM_PTR(&mp_lv_obj_get_width_margin_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_width_grid), MP_ROM_PTR(&mp_lv_obj_get_width_grid_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_height_grid), MP_ROM_PTR(&mp_lv_obj_get_height_grid_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_auto_realign), MP_ROM_PTR(&mp_lv_obj_get_auto_realign_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_ext_click_pad_left), MP_ROM_PTR(&mp_lv_obj_get_ext_click_pad_left_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_ext_click_pad_right), MP_ROM_PTR(&mp_lv_obj_get_ext_click_pad_right_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_ext_click_pad_top), MP_ROM_PTR(&mp_lv_obj_get_ext_click_pad_top_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_ext_click_pad_bottom), MP_ROM_PTR(&mp_lv_obj_get_ext_click_pad_bottom_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_ext_draw_pad), MP_ROM_PTR(&mp_lv_obj_get_ext_draw_pad_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style_list), MP_ROM_PTR(&mp_lv_obj_get_style_list_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_local_style), MP_ROM_PTR(&mp_lv_obj_get_local_style_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_hidden), MP_ROM_PTR(&mp_lv_obj_get_hidden_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_adv_hittest), MP_ROM_PTR(&mp_lv_obj_get_adv_hittest_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_click), MP_ROM_PTR(&mp_lv_obj_get_click_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_top), MP_ROM_PTR(&mp_lv_obj_get_top_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_drag), MP_ROM_PTR(&mp_lv_obj_get_drag_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_drag_dir), MP_ROM_PTR(&mp_lv_obj_get_drag_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_drag_throw), MP_ROM_PTR(&mp_lv_obj_get_drag_throw_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_drag_parent), MP_ROM_PTR(&mp_lv_obj_get_drag_parent_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_focus_parent), MP_ROM_PTR(&mp_lv_obj_get_focus_parent_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_parent_event), MP_ROM_PTR(&mp_lv_obj_get_parent_event_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_gesture_parent), MP_ROM_PTR(&mp_lv_obj_get_gesture_parent_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_base_dir), MP_ROM_PTR(&mp_lv_obj_get_base_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_protect), MP_ROM_PTR(&mp_lv_obj_get_protect_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_protected), MP_ROM_PTR(&mp_lv_obj_is_protected_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_state), MP_ROM_PTR(&mp_lv_obj_get_state_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_signal_cb), MP_ROM_PTR(&mp_lv_obj_get_signal_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_design_cb), MP_ROM_PTR(&mp_lv_obj_get_design_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_event_cb), MP_ROM_PTR(&mp_lv_obj_get_event_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_point_on_coords), MP_ROM_PTR(&mp_lv_obj_is_point_on_coords_obj) },
    { MP_ROM_QSTR(MP_QSTR_hittest), MP_ROM_PTR(&mp_lv_obj_hittest_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_ext_attr), MP_ROM_PTR(&mp_lv_obj_get_ext_attr_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_type), MP_ROM_PTR(&mp_lv_obj_get_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_user_data), MP_ROM_PTR(&mp_lv_obj_get_user_data_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_user_data_ptr), MP_ROM_PTR(&mp_lv_obj_get_user_data_ptr_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_user_data), MP_ROM_PTR(&mp_lv_obj_set_user_data_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_group), MP_ROM_PTR(&mp_lv_obj_get_group_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_focused), MP_ROM_PTR(&mp_lv_obj_is_focused_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_focused_obj), MP_ROM_PTR(&mp_lv_obj_get_focused_obj_obj) },
    { MP_ROM_QSTR(MP_QSTR_handle_get_type_signal), MP_ROM_PTR(&mp_lv_obj_handle_get_type_signal_obj) },
    { MP_ROM_QSTR(MP_QSTR_init_draw_rect_dsc), MP_ROM_PTR(&mp_lv_obj_init_draw_rect_dsc_obj) },
    { MP_ROM_QSTR(MP_QSTR_init_draw_label_dsc), MP_ROM_PTR(&mp_lv_obj_init_draw_label_dsc_obj) },
    { MP_ROM_QSTR(MP_QSTR_init_draw_img_dsc), MP_ROM_PTR(&mp_lv_obj_init_draw_img_dsc_obj) },
    { MP_ROM_QSTR(MP_QSTR_init_draw_line_dsc), MP_ROM_PTR(&mp_lv_obj_init_draw_line_dsc_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_draw_rect_ext_pad_size), MP_ROM_PTR(&mp_lv_obj_get_draw_rect_ext_pad_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_fade_in), MP_ROM_PTR(&mp_lv_obj_fade_in_obj) },
    { MP_ROM_QSTR(MP_QSTR_fade_out), MP_ROM_PTR(&mp_lv_obj_fade_out_obj) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_OBJ_PART_type) },
    { MP_ROM_QSTR(MP_QSTR___cast__), MP_ROM_PTR(&cast_obj_class_method) }
};

STATIC MP_DEFINE_CONST_DICT(obj_locals_dict, obj_locals_dict_table);

STATIC void obj_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl obj");
}


STATIC mp_obj_t obj_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_obj_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_obj_type = {
    { &mp_type_type },
    .name = MP_QSTR_obj,
    .print = obj_print,
    .make_new = obj_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&obj_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = NULL,
};
    

/*
 * lvgl extension definition for:
 * inline static void lv_cont_set_fit2(lv_obj_t *cont, lv_fit_t hor, lv_fit_t ver)
 */
 
STATIC mp_obj_t mp_lv_cont_set_fit2(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *cont = mp_to_lv(mp_args[0]);
    lv_fit_t hor = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_fit_t ver = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_fit_t, lv_fit_t))lv_func_ptr)(cont, hor, ver);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cont_set_fit2_obj, 3, mp_lv_cont_set_fit2, lv_cont_set_fit2);
    

/*
 * lvgl extension definition for:
 * inline static void lv_cont_set_fit(lv_obj_t *cont, lv_fit_t fit)
 */
 
STATIC mp_obj_t mp_lv_cont_set_fit(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *cont = mp_to_lv(mp_args[0]);
    lv_fit_t fit = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_fit_t))lv_func_ptr)(cont, fit);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cont_set_fit_obj, 2, mp_lv_cont_set_fit, lv_cont_set_fit);
    

/*
 * lvgl extension definition for:
 * void lv_cont_set_layout(lv_obj_t *cont, lv_layout_t layout)
 */
 
STATIC mp_obj_t mp_lv_cont_set_layout(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *cont = mp_to_lv(mp_args[0]);
    lv_layout_t layout = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_layout_t))lv_func_ptr)(cont, layout);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cont_set_layout_obj, 2, mp_lv_cont_set_layout, lv_cont_set_layout);
    

/*
 * lvgl extension definition for:
 * void lv_cont_set_fit4(lv_obj_t *cont, lv_fit_t left, lv_fit_t right, lv_fit_t top, lv_fit_t bottom)
 */
 
STATIC mp_obj_t mp_lv_cont_set_fit4(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *cont = mp_to_lv(mp_args[0]);
    lv_fit_t left = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_fit_t right = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_fit_t top = (uint8_t)mp_obj_get_int(mp_args[3]);
    lv_fit_t bottom = (uint8_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(lv_obj_t *, lv_fit_t, lv_fit_t, lv_fit_t, lv_fit_t))lv_func_ptr)(cont, left, right, top, bottom);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cont_set_fit4_obj, 5, mp_lv_cont_set_fit4, lv_cont_set_fit4);
    

/*
 * lvgl extension definition for:
 * lv_layout_t lv_cont_get_layout(const lv_obj_t *cont)
 */
 
STATIC mp_obj_t mp_lv_cont_get_layout(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *cont = mp_to_lv(mp_args[0]);
    lv_layout_t _res = ((lv_layout_t (*)(const lv_obj_t *))lv_func_ptr)(cont);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cont_get_layout_obj, 1, mp_lv_cont_get_layout, lv_cont_get_layout);
    

/*
 * lvgl extension definition for:
 * lv_fit_t lv_cont_get_fit_left(const lv_obj_t *cont)
 */
 
STATIC mp_obj_t mp_lv_cont_get_fit_left(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *cont = mp_to_lv(mp_args[0]);
    lv_fit_t _res = ((lv_fit_t (*)(const lv_obj_t *))lv_func_ptr)(cont);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cont_get_fit_left_obj, 1, mp_lv_cont_get_fit_left, lv_cont_get_fit_left);
    
/* Reusing lv_cont_get_fit_left for lv_cont_get_fit_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cont_get_fit_right_obj, 1, mp_lv_cont_get_fit_left, lv_cont_get_fit_right);
    
/* Reusing lv_cont_get_fit_left for lv_cont_get_fit_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cont_get_fit_top_obj, 1, mp_lv_cont_get_fit_left, lv_cont_get_fit_top);
    
/* Reusing lv_cont_get_fit_left for lv_cont_get_fit_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cont_get_fit_bottom_obj, 1, mp_lv_cont_get_fit_left, lv_cont_get_fit_bottom);
    

/*
 * lvgl cont object definitions
 */
    

STATIC const mp_rom_map_elem_t cont_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_fit2), MP_ROM_PTR(&mp_lv_cont_set_fit2_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_fit), MP_ROM_PTR(&mp_lv_cont_set_fit_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_layout), MP_ROM_PTR(&mp_lv_cont_set_layout_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_fit4), MP_ROM_PTR(&mp_lv_cont_set_fit4_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_layout), MP_ROM_PTR(&mp_lv_cont_get_layout_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_fit_left), MP_ROM_PTR(&mp_lv_cont_get_fit_left_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_fit_right), MP_ROM_PTR(&mp_lv_cont_get_fit_right_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_fit_top), MP_ROM_PTR(&mp_lv_cont_get_fit_top_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_fit_bottom), MP_ROM_PTR(&mp_lv_cont_get_fit_bottom_obj) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_CONT_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(cont_locals_dict, cont_locals_dict_table);

STATIC void cont_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl cont");
}


STATIC mp_obj_t cont_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_cont_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_cont_type = {
    { &mp_type_type },
    .name = MP_QSTR_cont,
    .print = cont_print,
    .make_new = cont_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&cont_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_cont_set_layout for lv_btn_set_layout */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btn_set_layout_obj, 2, mp_lv_cont_set_layout, lv_btn_set_layout);
    
/* Reusing lv_cont_set_fit4 for lv_btn_set_fit4 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btn_set_fit4_obj, 5, mp_lv_cont_set_fit4, lv_btn_set_fit4);
    
/* Reusing lv_cont_set_fit2 for lv_btn_set_fit2 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btn_set_fit2_obj, 3, mp_lv_cont_set_fit2, lv_btn_set_fit2);
    
/* Reusing lv_cont_set_fit for lv_btn_set_fit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btn_set_fit_obj, 2, mp_lv_cont_set_fit, lv_btn_set_fit);
    
/* Reusing lv_cont_get_layout for lv_btn_get_layout */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btn_get_layout_obj, 1, mp_lv_cont_get_layout, lv_btn_get_layout);
    
/* Reusing lv_cont_get_fit_left for lv_btn_get_fit_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btn_get_fit_left_obj, 1, mp_lv_cont_get_fit_left, lv_btn_get_fit_left);
    
/* Reusing lv_cont_get_fit_left for lv_btn_get_fit_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btn_get_fit_right_obj, 1, mp_lv_cont_get_fit_left, lv_btn_get_fit_right);
    
/* Reusing lv_cont_get_fit_left for lv_btn_get_fit_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btn_get_fit_top_obj, 1, mp_lv_cont_get_fit_left, lv_btn_get_fit_top);
    
/* Reusing lv_cont_get_fit_left for lv_btn_get_fit_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btn_get_fit_bottom_obj, 1, mp_lv_cont_get_fit_left, lv_btn_get_fit_bottom);
    
/* Reusing lv_obj_set_auto_realign for lv_btn_set_checkable */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btn_set_checkable_obj, 2, mp_lv_obj_set_auto_realign, lv_btn_set_checkable);
    

/*
 * lvgl extension definition for:
 * void lv_btn_set_state(lv_obj_t *btn, lv_btn_state_t state)
 */
 
STATIC mp_obj_t mp_lv_btn_set_state(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *btn = mp_to_lv(mp_args[0]);
    lv_btn_state_t state = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_btn_state_t))lv_func_ptr)(btn, state);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btn_set_state_obj, 2, mp_lv_btn_set_state, lv_btn_set_state);
    
/* Reusing lv_obj_clean for lv_btn_toggle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btn_toggle_obj, 1, mp_lv_obj_clean, lv_btn_toggle);
    

/*
 * lvgl extension definition for:
 * lv_btn_state_t lv_btn_get_state(const lv_obj_t *btn)
 */
 
STATIC mp_obj_t mp_lv_btn_get_state(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *btn = mp_to_lv(mp_args[0]);
    lv_btn_state_t _res = ((lv_btn_state_t (*)(const lv_obj_t *))lv_func_ptr)(btn);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btn_get_state_obj, 1, mp_lv_btn_get_state, lv_btn_get_state);
    
/* Reusing lv_obj_is_visible for lv_btn_get_checkable */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btn_get_checkable_obj, 1, mp_lv_obj_is_visible, lv_btn_get_checkable);
    

/*
 * lvgl btn object definitions
 */
    

STATIC const mp_rom_map_elem_t btn_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_layout), MP_ROM_PTR(&mp_lv_btn_set_layout_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_fit4), MP_ROM_PTR(&mp_lv_btn_set_fit4_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_fit2), MP_ROM_PTR(&mp_lv_btn_set_fit2_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_fit), MP_ROM_PTR(&mp_lv_btn_set_fit_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_layout), MP_ROM_PTR(&mp_lv_btn_get_layout_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_fit_left), MP_ROM_PTR(&mp_lv_btn_get_fit_left_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_fit_right), MP_ROM_PTR(&mp_lv_btn_get_fit_right_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_fit_top), MP_ROM_PTR(&mp_lv_btn_get_fit_top_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_fit_bottom), MP_ROM_PTR(&mp_lv_btn_get_fit_bottom_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_checkable), MP_ROM_PTR(&mp_lv_btn_set_checkable_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_state), MP_ROM_PTR(&mp_lv_btn_set_state_obj) },
    { MP_ROM_QSTR(MP_QSTR_toggle), MP_ROM_PTR(&mp_lv_btn_toggle_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_state), MP_ROM_PTR(&mp_lv_btn_get_state_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_checkable), MP_ROM_PTR(&mp_lv_btn_get_checkable_obj) },
    { MP_ROM_QSTR(MP_QSTR_STATE), MP_ROM_PTR(&mp_LV_BTN_STATE_type) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_BTN_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(btn_locals_dict, btn_locals_dict_table);

STATIC void btn_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl btn");
}


STATIC mp_obj_t btn_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_btn_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_btn_type = {
    { &mp_type_type },
    .name = MP_QSTR_btn,
    .print = btn_print,
    .make_new = btn_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&btn_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_obj_set_auto_realign for lv_imgbtn_set_checkable */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_imgbtn_set_checkable_obj, 2, mp_lv_obj_set_auto_realign, lv_imgbtn_set_checkable);
    
/* Reusing lv_btn_get_state for lv_imgbtn_get_state */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_imgbtn_get_state_obj, 1, mp_lv_btn_get_state, lv_imgbtn_get_state);
    
/* Reusing lv_obj_is_visible for lv_imgbtn_get_checkable */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_imgbtn_get_checkable_obj, 1, mp_lv_obj_is_visible, lv_imgbtn_get_checkable);
    

/*
 * lvgl extension definition for:
 * void lv_imgbtn_set_src(lv_obj_t *imgbtn, lv_btn_state_t state, const void *src)
 */
 
STATIC mp_obj_t mp_lv_imgbtn_set_src(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *imgbtn = mp_to_lv(mp_args[0]);
    lv_btn_state_t state = (uint8_t)mp_obj_get_int(mp_args[1]);
    const void *src = mp_to_ptr(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_btn_state_t, const void *))lv_func_ptr)(imgbtn, state, src);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_imgbtn_set_src_obj, 3, mp_lv_imgbtn_set_src, lv_imgbtn_set_src);
    
/* Reusing lv_btn_set_state for lv_imgbtn_set_state */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_imgbtn_set_state_obj, 2, mp_lv_btn_set_state, lv_imgbtn_set_state);
    
/* Reusing lv_obj_clean for lv_imgbtn_toggle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_imgbtn_toggle_obj, 1, mp_lv_obj_clean, lv_imgbtn_toggle);
    

/*
 * lvgl extension definition for:
 * const void *lv_imgbtn_get_src(lv_obj_t *imgbtn, lv_btn_state_t state)
 */
 
STATIC mp_obj_t mp_lv_imgbtn_get_src(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *imgbtn = mp_to_lv(mp_args[0]);
    lv_btn_state_t state = (uint8_t)mp_obj_get_int(mp_args[1]);
    const void * _res = ((const void *(*)(lv_obj_t *, lv_btn_state_t))lv_func_ptr)(imgbtn, state);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_imgbtn_get_src_obj, 2, mp_lv_imgbtn_get_src, lv_imgbtn_get_src);
    

/*
 * lvgl imgbtn object definitions
 */
    

STATIC const mp_rom_map_elem_t imgbtn_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_checkable), MP_ROM_PTR(&mp_lv_imgbtn_set_checkable_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_state), MP_ROM_PTR(&mp_lv_imgbtn_get_state_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_checkable), MP_ROM_PTR(&mp_lv_imgbtn_get_checkable_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_src), MP_ROM_PTR(&mp_lv_imgbtn_set_src_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_state), MP_ROM_PTR(&mp_lv_imgbtn_set_state_obj) },
    { MP_ROM_QSTR(MP_QSTR_toggle), MP_ROM_PTR(&mp_lv_imgbtn_toggle_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_src), MP_ROM_PTR(&mp_lv_imgbtn_get_src_obj) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_IMGBTN_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(imgbtn_locals_dict, imgbtn_locals_dict_table);

STATIC void imgbtn_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl imgbtn");
}


STATIC mp_obj_t imgbtn_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_imgbtn_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_imgbtn_type = {
    { &mp_type_type },
    .name = MP_QSTR_imgbtn,
    .print = imgbtn_print,
    .make_new = imgbtn_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&imgbtn_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * void lv_label_set_text(lv_obj_t *label, const char *text)
 */
 
STATIC mp_obj_t mp_lv_label_set_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *label = mp_to_lv(mp_args[0]);
    const char *text = (char*)convert_from_str(mp_args[1]);
    ((void (*)(lv_obj_t *, const char *))lv_func_ptr)(label, text);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_set_text_obj, 2, mp_lv_label_set_text, lv_label_set_text);
    

/*
 * Function NOT generated:
 * Cannot convert ellipsis param
 * void lv_label_set_text_fmt(lv_obj_t *label, const char *fmt, ...)
 */
    
/* Reusing lv_label_set_text for lv_label_set_text_static */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_set_text_static_obj, 2, mp_lv_label_set_text, lv_label_set_text_static);
    

/*
 * lvgl extension definition for:
 * void lv_label_set_long_mode(lv_obj_t *label, lv_label_long_mode_t long_mode)
 */
 
STATIC mp_obj_t mp_lv_label_set_long_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *label = mp_to_lv(mp_args[0]);
    lv_label_long_mode_t long_mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_label_long_mode_t))lv_func_ptr)(label, long_mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_set_long_mode_obj, 2, mp_lv_label_set_long_mode, lv_label_set_long_mode);
    

/*
 * lvgl extension definition for:
 * void lv_label_set_align(lv_obj_t *label, lv_label_align_t align)
 */
 
STATIC mp_obj_t mp_lv_label_set_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *label = mp_to_lv(mp_args[0]);
    lv_label_align_t align = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_label_align_t))lv_func_ptr)(label, align);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_set_align_obj, 2, mp_lv_label_set_align, lv_label_set_align);
    
/* Reusing lv_obj_set_auto_realign for lv_label_set_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_set_recolor_obj, 2, mp_lv_obj_set_auto_realign, lv_label_set_recolor);
    

/*
 * lvgl extension definition for:
 * void lv_label_set_anim_speed(lv_obj_t *label, uint16_t anim_speed)
 */
 
STATIC mp_obj_t mp_lv_label_set_anim_speed(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *label = mp_to_lv(mp_args[0]);
    uint16_t anim_speed = (uint16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, uint16_t))lv_func_ptr)(label, anim_speed);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_set_anim_speed_obj, 2, mp_lv_label_set_anim_speed, lv_label_set_anim_speed);
    

/*
 * lvgl extension definition for:
 * void lv_label_set_text_sel_start(lv_obj_t *label, uint32_t index)
 */
 
STATIC mp_obj_t mp_lv_label_set_text_sel_start(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *label = mp_to_lv(mp_args[0]);
    uint32_t index = (uint32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, uint32_t))lv_func_ptr)(label, index);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_set_text_sel_start_obj, 2, mp_lv_label_set_text_sel_start, lv_label_set_text_sel_start);
    
/* Reusing lv_label_set_text_sel_start for lv_label_set_text_sel_end */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_set_text_sel_end_obj, 2, mp_lv_label_set_text_sel_start, lv_label_set_text_sel_end);
    

/*
 * lvgl extension definition for:
 * char *lv_label_get_text(const lv_obj_t *label)
 */
 
STATIC mp_obj_t mp_lv_label_get_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *label = mp_to_lv(mp_args[0]);
    char * _res = ((char *(*)(const lv_obj_t *))lv_func_ptr)(label);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_get_text_obj, 1, mp_lv_label_get_text, lv_label_get_text);
    

/*
 * lvgl extension definition for:
 * lv_label_long_mode_t lv_label_get_long_mode(const lv_obj_t *label)
 */
 
STATIC mp_obj_t mp_lv_label_get_long_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *label = mp_to_lv(mp_args[0]);
    lv_label_long_mode_t _res = ((lv_label_long_mode_t (*)(const lv_obj_t *))lv_func_ptr)(label);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_get_long_mode_obj, 1, mp_lv_label_get_long_mode, lv_label_get_long_mode);
    

/*
 * lvgl extension definition for:
 * lv_label_align_t lv_label_get_align(const lv_obj_t *label)
 */
 
STATIC mp_obj_t mp_lv_label_get_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *label = mp_to_lv(mp_args[0]);
    lv_label_align_t _res = ((lv_label_align_t (*)(const lv_obj_t *))lv_func_ptr)(label);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_get_align_obj, 1, mp_lv_label_get_align, lv_label_get_align);
    
/* Reusing lv_obj_is_visible for lv_label_get_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_get_recolor_obj, 1, mp_lv_obj_is_visible, lv_label_get_recolor);
    
/* Reusing lv_obj_count_children for lv_label_get_anim_speed */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_get_anim_speed_obj, 1, mp_lv_obj_count_children, lv_label_get_anim_speed);
    

/*
 * lvgl extension definition for:
 * void lv_label_get_letter_pos(const lv_obj_t *label, uint32_t index, lv_point_t *pos)
 */
 
STATIC mp_obj_t mp_lv_label_get_letter_pos(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *label = mp_to_lv(mp_args[0]);
    uint32_t index = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_point_t *pos = mp_write_ptr_lv_point_t(mp_args[2]);
    ((void (*)(const lv_obj_t *, uint32_t, lv_point_t *))lv_func_ptr)(label, index, pos);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_get_letter_pos_obj, 3, mp_lv_label_get_letter_pos, lv_label_get_letter_pos);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_label_get_letter_on(const lv_obj_t *label, lv_point_t *pos)
 */
 
STATIC mp_obj_t mp_lv_label_get_letter_on(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *label = mp_to_lv(mp_args[0]);
    lv_point_t *pos = mp_write_ptr_lv_point_t(mp_args[1]);
    uint32_t _res = ((uint32_t (*)(const lv_obj_t *, lv_point_t *))lv_func_ptr)(label, pos);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_get_letter_on_obj, 2, mp_lv_label_get_letter_on, lv_label_get_letter_on);
    

/*
 * lvgl extension definition for:
 * bool lv_label_is_char_under_pos(const lv_obj_t *label, lv_point_t *pos)
 */
 
STATIC mp_obj_t mp_lv_label_is_char_under_pos(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *label = mp_to_lv(mp_args[0]);
    lv_point_t *pos = mp_write_ptr_lv_point_t(mp_args[1]);
    bool _res = ((bool (*)(const lv_obj_t *, lv_point_t *))lv_func_ptr)(label, pos);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_is_char_under_pos_obj, 2, mp_lv_label_is_char_under_pos, lv_label_is_char_under_pos);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_label_get_text_sel_start(const lv_obj_t *label)
 */
 
STATIC mp_obj_t mp_lv_label_get_text_sel_start(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *label = mp_to_lv(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(const lv_obj_t *))lv_func_ptr)(label);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_get_text_sel_start_obj, 1, mp_lv_label_get_text_sel_start, lv_label_get_text_sel_start);
    
/* Reusing lv_label_get_text_sel_start for lv_label_get_text_sel_end */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_get_text_sel_end_obj, 1, mp_lv_label_get_text_sel_start, lv_label_get_text_sel_end);
    

/*
 * lvgl extension definition for:
 * lv_style_list_t *lv_label_get_style(lv_obj_t *label, uint8_t type)
 */
 
STATIC mp_obj_t mp_lv_label_get_style(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *label = mp_to_lv(mp_args[0]);
    uint8_t type = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_list_t * _res = ((lv_style_list_t *(*)(lv_obj_t *, uint8_t))lv_func_ptr)(label, type);
    return mp_read_ptr_lv_style_list_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_get_style_obj, 2, mp_lv_label_get_style, lv_label_get_style);
    

/*
 * lvgl extension definition for:
 * void lv_label_ins_text(lv_obj_t *label, uint32_t pos, const char *txt)
 */
 
STATIC mp_obj_t mp_lv_label_ins_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *label = mp_to_lv(mp_args[0]);
    uint32_t pos = (uint32_t)mp_obj_get_int(mp_args[1]);
    const char *txt = (char*)convert_from_str(mp_args[2]);
    ((void (*)(lv_obj_t *, uint32_t, const char *))lv_func_ptr)(label, pos, txt);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_ins_text_obj, 3, mp_lv_label_ins_text, lv_label_ins_text);
    
/* Reusing lv_obj_fade_in for lv_label_cut_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_cut_text_obj, 3, mp_lv_obj_fade_in, lv_label_cut_text);
    
/* Reusing lv_obj_clean for lv_label_refr_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_label_refr_text_obj, 1, mp_lv_obj_clean, lv_label_refr_text);
    

/*
 * lvgl label object definitions
 */
    

STATIC const mp_rom_map_elem_t label_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_text), MP_ROM_PTR(&mp_lv_label_set_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_static), MP_ROM_PTR(&mp_lv_label_set_text_static_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_long_mode), MP_ROM_PTR(&mp_lv_label_set_long_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_align), MP_ROM_PTR(&mp_lv_label_set_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_recolor), MP_ROM_PTR(&mp_lv_label_set_recolor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_anim_speed), MP_ROM_PTR(&mp_lv_label_set_anim_speed_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_sel_start), MP_ROM_PTR(&mp_lv_label_set_text_sel_start_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_sel_end), MP_ROM_PTR(&mp_lv_label_set_text_sel_end_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_text), MP_ROM_PTR(&mp_lv_label_get_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_long_mode), MP_ROM_PTR(&mp_lv_label_get_long_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_align), MP_ROM_PTR(&mp_lv_label_get_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_recolor), MP_ROM_PTR(&mp_lv_label_get_recolor_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_anim_speed), MP_ROM_PTR(&mp_lv_label_get_anim_speed_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_letter_pos), MP_ROM_PTR(&mp_lv_label_get_letter_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_letter_on), MP_ROM_PTR(&mp_lv_label_get_letter_on_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_char_under_pos), MP_ROM_PTR(&mp_lv_label_is_char_under_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_text_sel_start), MP_ROM_PTR(&mp_lv_label_get_text_sel_start_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_text_sel_end), MP_ROM_PTR(&mp_lv_label_get_text_sel_end_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style), MP_ROM_PTR(&mp_lv_label_get_style_obj) },
    { MP_ROM_QSTR(MP_QSTR_ins_text), MP_ROM_PTR(&mp_lv_label_ins_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_cut_text), MP_ROM_PTR(&mp_lv_label_cut_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_refr_text), MP_ROM_PTR(&mp_lv_label_refr_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_LONG), MP_ROM_PTR(&mp_LV_LABEL_LONG_type) },
    { MP_ROM_QSTR(MP_QSTR_ALIGN), MP_ROM_PTR(&mp_LV_LABEL_ALIGN_type) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_LABEL_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(label_locals_dict, label_locals_dict_table);

STATIC void label_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl label");
}


STATIC mp_obj_t label_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_label_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_label_type = {
    { &mp_type_type },
    .name = MP_QSTR_label,
    .print = label_print,
    .make_new = label_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&label_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * Struct lv_img_header_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_img_header_t_type();

STATIC inline lv_img_header_t* mp_write_ptr_lv_img_header_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_img_header_t_type()));
    return (lv_img_header_t*)self->data;
}

#define mp_write_lv_img_header_t(struct_obj) *mp_write_ptr_lv_img_header_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_img_header_t(lv_img_header_t *field)
{
    return lv_to_mp_struct(get_mp_lv_img_header_t_type(), (void*)field);
}

#define mp_read_lv_img_header_t(field) mp_read_ptr_lv_img_header_t(copy_buffer(&field, sizeof(lv_img_header_t)))
#define mp_read_byref_lv_img_header_t(field) mp_read_ptr_lv_img_header_t(&field)

STATIC void mp_lv_img_header_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_img_header_t *data = (lv_img_header_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_cf: dest[0] = mp_obj_new_int_from_uint(data->cf); break; // converting from uint32_t;
            case MP_QSTR_always_zero: dest[0] = mp_obj_new_int_from_uint(data->always_zero); break; // converting from uint32_t;
            case MP_QSTR_reserved: dest[0] = mp_obj_new_int_from_uint(data->reserved); break; // converting from uint32_t;
            case MP_QSTR_w: dest[0] = mp_obj_new_int_from_uint(data->w); break; // converting from uint32_t;
            case MP_QSTR_h: dest[0] = mp_obj_new_int_from_uint(data->h); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_cf: data->cf = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_always_zero: data->always_zero = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_reserved: data->reserved = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_w: data->w = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_h: data->h = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_img_header_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_img_header_t");
}

STATIC const mp_obj_dict_t mp_lv_img_header_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_img_header_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_img_header_t,
    .print = mp_lv_img_header_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_img_header_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_img_header_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_img_header_t_type()
{
    return &mp_lv_img_header_t_type;
}
    

/*
 * Struct lv_img_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_img_dsc_t_type();

STATIC inline lv_img_dsc_t* mp_write_ptr_lv_img_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_img_dsc_t_type()));
    return (lv_img_dsc_t*)self->data;
}

#define mp_write_lv_img_dsc_t(struct_obj) *mp_write_ptr_lv_img_dsc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_img_dsc_t(lv_img_dsc_t *field)
{
    return lv_to_mp_struct(get_mp_lv_img_dsc_t_type(), (void*)field);
}

#define mp_read_lv_img_dsc_t(field) mp_read_ptr_lv_img_dsc_t(copy_buffer(&field, sizeof(lv_img_dsc_t)))
#define mp_read_byref_lv_img_dsc_t(field) mp_read_ptr_lv_img_dsc_t(&field)

STATIC void mp_lv_img_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_img_dsc_t *data = (lv_img_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_header: dest[0] = mp_read_byref_lv_img_header_t(data->header); break; // converting from lv_img_header_t;
            case MP_QSTR_data_size: dest[0] = mp_obj_new_int_from_uint(data->data_size); break; // converting from uint32_t;
            case MP_QSTR_data: dest[0] = ptr_to_mp((void*)data->data); break; // converting from uint8_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_header: data->header = mp_write_lv_img_header_t(dest[1]); break; // converting to lv_img_header_t;
                case MP_QSTR_data_size: data->data_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_data: data->data = (void*)mp_to_ptr(dest[1]); break; // converting to uint8_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_img_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_img_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_img_dsc_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_img_dsc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_img_dsc_t,
    .print = mp_lv_img_dsc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_img_dsc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_img_dsc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_img_dsc_t_type()
{
    return &mp_lv_img_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_img_dsc_t *lv_img_buf_alloc(lv_coord_t w, lv_coord_t h, lv_img_cf_t cf)
 */
 
STATIC mp_obj_t mp_lv_img_buf_alloc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_coord_t w = (int16_t)mp_obj_get_int(mp_args[0]);
    lv_coord_t h = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_img_cf_t cf = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_img_dsc_t * _res = ((lv_img_dsc_t *(*)(lv_coord_t, lv_coord_t, lv_img_cf_t))lv_func_ptr)(w, h, cf);
    return mp_read_ptr_lv_img_dsc_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_img_buf_alloc_obj, 3, mp_lv_img_buf_alloc, lv_img_buf_alloc);
    

/*
 * lvgl extension definition for:
 * lv_color_t lv_img_buf_get_px_color(lv_img_dsc_t *dsc, lv_coord_t x, lv_coord_t y, lv_color_t color)
 */
 
STATIC mp_obj_t mp_lv_img_buf_get_px_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_dsc_t *dsc = mp_write_ptr_lv_img_dsc_t(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_color_t color = mp_write_lv_color32_t(mp_args[3]);
    lv_color_t _res = ((lv_color_t (*)(lv_img_dsc_t *, lv_coord_t, lv_coord_t, lv_color_t))lv_func_ptr)(dsc, x, y, color);
    return mp_read_lv_color32_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_buf_get_px_color_obj, 4, mp_lv_img_buf_get_px_color, lv_img_buf_get_px_color);
    

/*
 * lvgl extension definition for:
 * lv_opa_t lv_img_buf_get_px_alpha(lv_img_dsc_t *dsc, lv_coord_t x, lv_coord_t y)
 */
 
STATIC mp_obj_t mp_lv_img_buf_get_px_alpha(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_dsc_t *dsc = mp_write_ptr_lv_img_dsc_t(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_opa_t _res = ((lv_opa_t (*)(lv_img_dsc_t *, lv_coord_t, lv_coord_t))lv_func_ptr)(dsc, x, y);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_buf_get_px_alpha_obj, 3, mp_lv_img_buf_get_px_alpha, lv_img_buf_get_px_alpha);
    

/*
 * lvgl extension definition for:
 * void lv_img_buf_set_px_color(lv_img_dsc_t *dsc, lv_coord_t x, lv_coord_t y, lv_color_t c)
 */
 
STATIC mp_obj_t mp_lv_img_buf_set_px_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_dsc_t *dsc = mp_write_ptr_lv_img_dsc_t(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_color_t c = mp_write_lv_color32_t(mp_args[3]);
    ((void (*)(lv_img_dsc_t *, lv_coord_t, lv_coord_t, lv_color_t))lv_func_ptr)(dsc, x, y, c);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_buf_set_px_color_obj, 4, mp_lv_img_buf_set_px_color, lv_img_buf_set_px_color);
    

/*
 * lvgl extension definition for:
 * void lv_img_buf_set_px_alpha(lv_img_dsc_t *dsc, lv_coord_t x, lv_coord_t y, lv_opa_t opa)
 */
 
STATIC mp_obj_t mp_lv_img_buf_set_px_alpha(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_dsc_t *dsc = mp_write_ptr_lv_img_dsc_t(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_opa_t opa = (uint8_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_img_dsc_t *, lv_coord_t, lv_coord_t, lv_opa_t))lv_func_ptr)(dsc, x, y, opa);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_buf_set_px_alpha_obj, 4, mp_lv_img_buf_set_px_alpha, lv_img_buf_set_px_alpha);
    

/*
 * lvgl extension definition for:
 * void lv_img_buf_set_palette(lv_img_dsc_t *dsc, uint8_t id, lv_color_t c)
 */
 
STATIC mp_obj_t mp_lv_img_buf_set_palette(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_dsc_t *dsc = mp_write_ptr_lv_img_dsc_t(mp_args[0]);
    uint8_t id = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_color_t c = mp_write_lv_color32_t(mp_args[2]);
    ((void (*)(lv_img_dsc_t *, uint8_t, lv_color_t))lv_func_ptr)(dsc, id, c);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_buf_set_palette_obj, 3, mp_lv_img_buf_set_palette, lv_img_buf_set_palette);
    

/*
 * lvgl extension definition for:
 * void lv_img_buf_free(lv_img_dsc_t *dsc)
 */
 
STATIC mp_obj_t mp_lv_img_buf_free(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_dsc_t *dsc = mp_write_ptr_lv_img_dsc_t(mp_args[0]);
    ((void (*)(lv_img_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_buf_free_obj, 1, mp_lv_img_buf_free, lv_img_buf_free);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_img_buf_get_img_size(lv_coord_t w, lv_coord_t h, lv_img_cf_t cf)
 */
 
STATIC mp_obj_t mp_lv_img_buf_get_img_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_coord_t w = (int16_t)mp_obj_get_int(mp_args[0]);
    lv_coord_t h = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_img_cf_t cf = (uint8_t)mp_obj_get_int(mp_args[2]);
    uint32_t _res = ((uint32_t (*)(lv_coord_t, lv_coord_t, lv_img_cf_t))lv_func_ptr)(w, h, cf);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_img_buf_get_img_size_obj, 3, mp_lv_img_buf_get_img_size, lv_img_buf_get_img_size);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_img_decoder_get_info(const char *src, lv_img_header_t *header)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_get_info(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const char *src = (char*)convert_from_str(mp_args[0]);
    lv_img_header_t *header = mp_write_ptr_lv_img_header_t(mp_args[1]);
    lv_res_t _res = ((lv_res_t (*)(const char *, lv_img_header_t *))lv_func_ptr)(src, header);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_img_decoder_get_info_obj, 2, mp_lv_img_decoder_get_info, lv_img_decoder_get_info);
    
#define funcptr_lv_img_decoder_info_f_t NULL


/*
 * lvgl extension definition for:
 * lv_res_t lv_img_decoder_info_f_t(struct _lv_img_decoder *decoder, const void *src, lv_img_header_t *header)
 */
 
STATIC mp_obj_t mp_funcptr_lv_img_decoder_info_f_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_img_decoder *decoder = mp_to_ptr(mp_args[0]);
    const void *src = mp_to_ptr(mp_args[1]);
    lv_img_header_t *header = mp_write_ptr_lv_img_header_t(mp_args[2]);
    lv_res_t _res = ((lv_res_t (*)(struct _lv_img_decoder *, const void *, lv_img_header_t *))lv_func_ptr)(decoder, src, header);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_img_decoder_info_f_t_obj, 3, mp_funcptr_lv_img_decoder_info_f_t, funcptr_lv_img_decoder_info_f_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_img_decoder_info_f_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_img_decoder_info_f_t_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_res_t lv_img_decoder_t_info_cb_callback(struct _lv_img_decoder *decoder, const void *src, lv_img_header_t *header);
#define funcptr_lv_img_decoder_open_f_t NULL


/*
 * lvgl extension definition for:
 * lv_res_t lv_img_decoder_open_f_t(struct _lv_img_decoder *decoder, struct _lv_img_decoder_dsc *dsc)
 */
 
STATIC mp_obj_t mp_funcptr_lv_img_decoder_open_f_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_img_decoder *decoder = mp_to_ptr(mp_args[0]);
    struct _lv_img_decoder_dsc *dsc = mp_to_ptr(mp_args[1]);
    lv_res_t _res = ((lv_res_t (*)(struct _lv_img_decoder *, struct _lv_img_decoder_dsc *))lv_func_ptr)(decoder, dsc);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_img_decoder_open_f_t_obj, 2, mp_funcptr_lv_img_decoder_open_f_t, funcptr_lv_img_decoder_open_f_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_img_decoder_open_f_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_img_decoder_open_f_t_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_res_t lv_img_decoder_t_open_cb_callback(struct _lv_img_decoder *decoder, struct _lv_img_decoder_dsc *dsc);
#define funcptr_lv_img_decoder_read_line_f_t NULL


/*
 * lvgl extension definition for:
 * lv_res_t lv_img_decoder_read_line_f_t(struct _lv_img_decoder *decoder, struct _lv_img_decoder_dsc *dsc, lv_coord_t x, lv_coord_t y, lv_coord_t len, uint8_t *buf)
 */
 
STATIC mp_obj_t mp_funcptr_lv_img_decoder_read_line_f_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_img_decoder *decoder = mp_to_ptr(mp_args[0]);
    struct _lv_img_decoder_dsc *dsc = mp_to_ptr(mp_args[1]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t len = (int16_t)mp_obj_get_int(mp_args[4]);
    uint8_t *buf = mp_to_ptr(mp_args[5]);
    lv_res_t _res = ((lv_res_t (*)(struct _lv_img_decoder *, struct _lv_img_decoder_dsc *, lv_coord_t, lv_coord_t, lv_coord_t, uint8_t *))lv_func_ptr)(decoder, dsc, x, y, len, buf);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_img_decoder_read_line_f_t_obj, 6, mp_funcptr_lv_img_decoder_read_line_f_t, funcptr_lv_img_decoder_read_line_f_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_img_decoder_read_line_f_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_img_decoder_read_line_f_t_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_res_t lv_img_decoder_t_read_line_cb_callback(struct _lv_img_decoder *decoder, struct _lv_img_decoder_dsc *dsc, lv_coord_t x, lv_coord_t y, lv_coord_t len, uint8_t *buf);
#define funcptr_lv_img_decoder_close_f_t NULL


/*
 * lvgl extension definition for:
 * void lv_img_decoder_close_f_t(struct _lv_img_decoder *decoder, struct _lv_img_decoder_dsc *dsc)
 */
 
STATIC mp_obj_t mp_funcptr_lv_img_decoder_close_f_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_img_decoder *decoder = mp_to_ptr(mp_args[0]);
    struct _lv_img_decoder_dsc *dsc = mp_to_ptr(mp_args[1]);
    ((void (*)(struct _lv_img_decoder *, struct _lv_img_decoder_dsc *))lv_func_ptr)(decoder, dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_img_decoder_close_f_t_obj, 2, mp_funcptr_lv_img_decoder_close_f_t, funcptr_lv_img_decoder_close_f_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_img_decoder_close_f_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_img_decoder_close_f_t_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_img_decoder_t_close_cb_callback(struct _lv_img_decoder *decoder, struct _lv_img_decoder_dsc *dsc);

/*
 * Struct lv_img_decoder_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_img_decoder_t_type();

STATIC inline lv_img_decoder_t* mp_write_ptr_lv_img_decoder_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_img_decoder_t_type()));
    return (lv_img_decoder_t*)self->data;
}

#define mp_write_lv_img_decoder_t(struct_obj) *mp_write_ptr_lv_img_decoder_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_img_decoder_t(lv_img_decoder_t *field)
{
    return lv_to_mp_struct(get_mp_lv_img_decoder_t_type(), (void*)field);
}

#define mp_read_lv_img_decoder_t(field) mp_read_ptr_lv_img_decoder_t(copy_buffer(&field, sizeof(lv_img_decoder_t)))
#define mp_read_byref_lv_img_decoder_t(field) mp_read_ptr_lv_img_decoder_t(&field)

STATIC void mp_lv_img_decoder_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_img_decoder_t *data = (lv_img_decoder_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_info_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_img_decoder_info_f_t_obj, data->info_cb, lv_img_decoder_t_info_cb_callback ,MP_QSTR_lv_img_decoder_t_info_cb, data->user_data); break; // converting from callback lv_img_decoder_info_f_t;
            case MP_QSTR_open_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_img_decoder_open_f_t_obj, data->open_cb, lv_img_decoder_t_open_cb_callback ,MP_QSTR_lv_img_decoder_t_open_cb, data->user_data); break; // converting from callback lv_img_decoder_open_f_t;
            case MP_QSTR_read_line_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_img_decoder_read_line_f_t_obj, data->read_line_cb, lv_img_decoder_t_read_line_cb_callback ,MP_QSTR_lv_img_decoder_t_read_line_cb, data->user_data); break; // converting from callback lv_img_decoder_read_line_f_t;
            case MP_QSTR_close_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_img_decoder_close_f_t_obj, data->close_cb, lv_img_decoder_t_close_cb_callback ,MP_QSTR_lv_img_decoder_t_close_cb, data->user_data); break; // converting from callback lv_img_decoder_close_f_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp(data->user_data); break; // converting from lv_img_decoder_user_data_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_info_cb: data->info_cb = mp_lv_callback(dest[1], lv_img_decoder_t_info_cb_callback ,MP_QSTR_lv_img_decoder_t_info_cb, &data->user_data); break; // converting to callback lv_img_decoder_info_f_t;
                case MP_QSTR_open_cb: data->open_cb = mp_lv_callback(dest[1], lv_img_decoder_t_open_cb_callback ,MP_QSTR_lv_img_decoder_t_open_cb, &data->user_data); break; // converting to callback lv_img_decoder_open_f_t;
                case MP_QSTR_read_line_cb: data->read_line_cb = mp_lv_callback(dest[1], lv_img_decoder_t_read_line_cb_callback ,MP_QSTR_lv_img_decoder_t_read_line_cb, &data->user_data); break; // converting to callback lv_img_decoder_read_line_f_t;
                case MP_QSTR_close_cb: data->close_cb = mp_lv_callback(dest[1], lv_img_decoder_t_close_cb_callback ,MP_QSTR_lv_img_decoder_t_close_cb, &data->user_data); break; // converting to callback lv_img_decoder_close_f_t;
                case MP_QSTR_user_data: data->user_data = mp_to_ptr(dest[1]); break; // converting to lv_img_decoder_user_data_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_img_decoder_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_img_decoder_t");
}

STATIC const mp_obj_dict_t mp_lv_img_decoder_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_img_decoder_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_img_decoder_t,
    .print = mp_lv_img_decoder_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_img_decoder_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_img_decoder_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_img_decoder_t_type()
{
    return &mp_lv_img_decoder_t_type;
}
    

/*
 * Struct lv_img_decoder_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_img_decoder_dsc_t_type();

STATIC inline lv_img_decoder_dsc_t* mp_write_ptr_lv_img_decoder_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_img_decoder_dsc_t_type()));
    return (lv_img_decoder_dsc_t*)self->data;
}

#define mp_write_lv_img_decoder_dsc_t(struct_obj) *mp_write_ptr_lv_img_decoder_dsc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_img_decoder_dsc_t(lv_img_decoder_dsc_t *field)
{
    return lv_to_mp_struct(get_mp_lv_img_decoder_dsc_t_type(), (void*)field);
}

#define mp_read_lv_img_decoder_dsc_t(field) mp_read_ptr_lv_img_decoder_dsc_t(copy_buffer(&field, sizeof(lv_img_decoder_dsc_t)))
#define mp_read_byref_lv_img_decoder_dsc_t(field) mp_read_ptr_lv_img_decoder_dsc_t(&field)

STATIC void mp_lv_img_decoder_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_img_decoder_dsc_t *data = (lv_img_decoder_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_decoder: dest[0] = mp_read_ptr_lv_img_decoder_t((void*)data->decoder); break; // converting from lv_img_decoder_t *;
            case MP_QSTR_src: dest[0] = ptr_to_mp((void*)data->src); break; // converting from void *;
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color32_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_src_type: dest[0] = mp_obj_new_int_from_uint(data->src_type); break; // converting from lv_img_src_t;
            case MP_QSTR_header: dest[0] = mp_read_byref_lv_img_header_t(data->header); break; // converting from lv_img_header_t;
            case MP_QSTR_img_data: dest[0] = ptr_to_mp((void*)data->img_data); break; // converting from uint8_t *;
            case MP_QSTR_time_to_open: dest[0] = mp_obj_new_int_from_uint(data->time_to_open); break; // converting from uint32_t;
            case MP_QSTR_error_msg: dest[0] = convert_to_str((void*)data->error_msg); break; // converting from char *;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_decoder: data->decoder = (void*)mp_write_ptr_lv_img_decoder_t(dest[1]); break; // converting to lv_img_decoder_t *;
                case MP_QSTR_src: data->src = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_color: data->color = mp_write_lv_color32_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_src_type: data->src_type = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_img_src_t;
                case MP_QSTR_header: data->header = mp_write_lv_img_header_t(dest[1]); break; // converting to lv_img_header_t;
                case MP_QSTR_img_data: data->img_data = (void*)mp_to_ptr(dest[1]); break; // converting to uint8_t *;
                case MP_QSTR_time_to_open: data->time_to_open = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_error_msg: data->error_msg = (void*)(char*)convert_from_str(dest[1]); break; // converting to char *;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_img_decoder_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_img_decoder_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_img_decoder_dsc_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_img_decoder_dsc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_img_decoder_dsc_t,
    .print = mp_lv_img_decoder_dsc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_img_decoder_dsc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_img_decoder_dsc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_img_decoder_dsc_t_type()
{
    return &mp_lv_img_decoder_dsc_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_img_decoder_open(lv_img_decoder_dsc_t *dsc, const void *src, lv_color_t color)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_open(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_dsc_t *dsc = mp_write_ptr_lv_img_decoder_dsc_t(mp_args[0]);
    const void *src = mp_to_ptr(mp_args[1]);
    lv_color_t color = mp_write_lv_color32_t(mp_args[2]);
    lv_res_t _res = ((lv_res_t (*)(lv_img_decoder_dsc_t *, const void *, lv_color_t))lv_func_ptr)(dsc, src, color);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_open_obj, 3, mp_lv_img_decoder_open, lv_img_decoder_open);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_img_decoder_read_line(lv_img_decoder_dsc_t *dsc, lv_coord_t x, lv_coord_t y, lv_coord_t len, uint8_t *buf)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_read_line(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_dsc_t *dsc = mp_write_ptr_lv_img_decoder_dsc_t(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t len = (int16_t)mp_obj_get_int(mp_args[3]);
    uint8_t *buf = mp_to_ptr(mp_args[4]);
    lv_res_t _res = ((lv_res_t (*)(lv_img_decoder_dsc_t *, lv_coord_t, lv_coord_t, lv_coord_t, uint8_t *))lv_func_ptr)(dsc, x, y, len, buf);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_read_line_obj, 5, mp_lv_img_decoder_read_line, lv_img_decoder_read_line);
    

/*
 * lvgl extension definition for:
 * void lv_img_decoder_close(lv_img_decoder_dsc_t *dsc)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_close(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_dsc_t *dsc = mp_write_ptr_lv_img_decoder_dsc_t(mp_args[0]);
    ((void (*)(lv_img_decoder_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_close_obj, 1, mp_lv_img_decoder_close, lv_img_decoder_close);
    

/*
 * lvgl extension definition for:
 * lv_img_decoder_t *lv_img_decoder_create(void)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_create(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_img_decoder_t * _res = ((lv_img_decoder_t *(*)(void))lv_func_ptr)();
    return mp_read_ptr_lv_img_decoder_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_img_decoder_create_obj, 0, mp_lv_img_decoder_create, lv_img_decoder_create);
    

/*
 * lvgl extension definition for:
 * void lv_img_decoder_delete(lv_img_decoder_t *decoder)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_delete(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_t *decoder = mp_write_ptr_lv_img_decoder_t(mp_args[0]);
    ((void (*)(lv_img_decoder_t *))lv_func_ptr)(decoder);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_delete_obj, 1, mp_lv_img_decoder_delete, lv_img_decoder_delete);
    

/*
 * Callback function lv_img_decoder_t_info_cb
 * lv_res_t lv_img_decoder_info_f_t(struct _lv_img_decoder *decoder, const void *src, lv_img_header_t *header)
 */

STATIC lv_res_t lv_img_decoder_t_info_cb_callback(struct _lv_img_decoder * arg0, const void * arg1, lv_img_header_t * arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_img_decoder_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = mp_read_ptr_lv_img_header_t((void*)arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_img_decoder_t_info_cb)) , 3, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * lvgl extension definition for:
 * void lv_img_decoder_set_info_cb(lv_img_decoder_t *decoder, lv_img_decoder_info_f_t info_cb)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_set_info_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_t *decoder = mp_write_ptr_lv_img_decoder_t(mp_args[0]);
    void *info_cb = mp_lv_callback(mp_args[1], &lv_img_decoder_t_info_cb_callback, MP_QSTR_lv_img_decoder_t_info_cb, &decoder->user_data);
    ((void (*)(lv_img_decoder_t *, lv_img_decoder_info_f_t))lv_func_ptr)(decoder, info_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_set_info_cb_obj, 2, mp_lv_img_decoder_set_info_cb, lv_img_decoder_set_info_cb);
    

/*
 * Callback function lv_img_decoder_t_open_cb
 * lv_res_t lv_img_decoder_open_f_t(struct _lv_img_decoder *decoder, struct _lv_img_decoder_dsc *dsc)
 */

STATIC lv_res_t lv_img_decoder_t_open_cb_callback(struct _lv_img_decoder * arg0, struct _lv_img_decoder_dsc * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_img_decoder_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_img_decoder_dsc_t((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_img_decoder_t_open_cb)) , 2, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * lvgl extension definition for:
 * void lv_img_decoder_set_open_cb(lv_img_decoder_t *decoder, lv_img_decoder_open_f_t open_cb)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_set_open_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_t *decoder = mp_write_ptr_lv_img_decoder_t(mp_args[0]);
    void *open_cb = mp_lv_callback(mp_args[1], &lv_img_decoder_t_open_cb_callback, MP_QSTR_lv_img_decoder_t_open_cb, &decoder->user_data);
    ((void (*)(lv_img_decoder_t *, lv_img_decoder_open_f_t))lv_func_ptr)(decoder, open_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_set_open_cb_obj, 2, mp_lv_img_decoder_set_open_cb, lv_img_decoder_set_open_cb);
    

/*
 * Callback function lv_img_decoder_t_read_line_cb
 * lv_res_t lv_img_decoder_read_line_f_t(struct _lv_img_decoder *decoder, struct _lv_img_decoder_dsc *dsc, lv_coord_t x, lv_coord_t y, lv_coord_t len, uint8_t *buf)
 */

STATIC lv_res_t lv_img_decoder_t_read_line_cb_callback(struct _lv_img_decoder * arg0, struct _lv_img_decoder_dsc * arg1, lv_coord_t arg2, lv_coord_t arg3, lv_coord_t arg4, uint8_t * arg5)
{
    mp_obj_t mp_args[6];
    mp_args[0] = mp_read_ptr_lv_img_decoder_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_img_decoder_dsc_t((void*)arg1);
    mp_args[2] = mp_obj_new_int(arg2);
    mp_args[3] = mp_obj_new_int(arg3);
    mp_args[4] = mp_obj_new_int(arg4);
    mp_args[5] = ptr_to_mp((void*)arg5);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_img_decoder_t_read_line_cb)) , 6, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * lvgl extension definition for:
 * void lv_img_decoder_set_read_line_cb(lv_img_decoder_t *decoder, lv_img_decoder_read_line_f_t read_line_cb)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_set_read_line_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_t *decoder = mp_write_ptr_lv_img_decoder_t(mp_args[0]);
    void *read_line_cb = mp_lv_callback(mp_args[1], &lv_img_decoder_t_read_line_cb_callback, MP_QSTR_lv_img_decoder_t_read_line_cb, &decoder->user_data);
    ((void (*)(lv_img_decoder_t *, lv_img_decoder_read_line_f_t))lv_func_ptr)(decoder, read_line_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_set_read_line_cb_obj, 2, mp_lv_img_decoder_set_read_line_cb, lv_img_decoder_set_read_line_cb);
    

/*
 * Callback function lv_img_decoder_t_close_cb
 * void lv_img_decoder_close_f_t(struct _lv_img_decoder *decoder, struct _lv_img_decoder_dsc *dsc)
 */

STATIC void lv_img_decoder_t_close_cb_callback(struct _lv_img_decoder * arg0, struct _lv_img_decoder_dsc * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_img_decoder_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_img_decoder_dsc_t((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_img_decoder_t_close_cb)) , 2, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * void lv_img_decoder_set_close_cb(lv_img_decoder_t *decoder, lv_img_decoder_close_f_t close_cb)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_set_close_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_t *decoder = mp_write_ptr_lv_img_decoder_t(mp_args[0]);
    void *close_cb = mp_lv_callback(mp_args[1], &lv_img_decoder_t_close_cb_callback, MP_QSTR_lv_img_decoder_t_close_cb, &decoder->user_data);
    ((void (*)(lv_img_decoder_t *, lv_img_decoder_close_f_t))lv_func_ptr)(decoder, close_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_set_close_cb_obj, 2, mp_lv_img_decoder_set_close_cb, lv_img_decoder_set_close_cb);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_img_decoder_built_in_info(lv_img_decoder_t *decoder, const void *src, lv_img_header_t *header)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_built_in_info(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_t *decoder = mp_write_ptr_lv_img_decoder_t(mp_args[0]);
    const void *src = mp_to_ptr(mp_args[1]);
    lv_img_header_t *header = mp_write_ptr_lv_img_header_t(mp_args[2]);
    lv_res_t _res = ((lv_res_t (*)(lv_img_decoder_t *, const void *, lv_img_header_t *))lv_func_ptr)(decoder, src, header);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_built_in_info_obj, 3, mp_lv_img_decoder_built_in_info, lv_img_decoder_built_in_info);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_img_decoder_built_in_open(lv_img_decoder_t *decoder, lv_img_decoder_dsc_t *dsc)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_built_in_open(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_t *decoder = mp_write_ptr_lv_img_decoder_t(mp_args[0]);
    lv_img_decoder_dsc_t *dsc = mp_write_ptr_lv_img_decoder_dsc_t(mp_args[1]);
    lv_res_t _res = ((lv_res_t (*)(lv_img_decoder_t *, lv_img_decoder_dsc_t *))lv_func_ptr)(decoder, dsc);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_built_in_open_obj, 2, mp_lv_img_decoder_built_in_open, lv_img_decoder_built_in_open);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_img_decoder_built_in_read_line(lv_img_decoder_t *decoder, lv_img_decoder_dsc_t *dsc, lv_coord_t x, lv_coord_t y, lv_coord_t len, uint8_t *buf)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_built_in_read_line(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_t *decoder = mp_write_ptr_lv_img_decoder_t(mp_args[0]);
    lv_img_decoder_dsc_t *dsc = mp_write_ptr_lv_img_decoder_dsc_t(mp_args[1]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t len = (int16_t)mp_obj_get_int(mp_args[4]);
    uint8_t *buf = mp_to_ptr(mp_args[5]);
    lv_res_t _res = ((lv_res_t (*)(lv_img_decoder_t *, lv_img_decoder_dsc_t *, lv_coord_t, lv_coord_t, lv_coord_t, uint8_t *))lv_func_ptr)(decoder, dsc, x, y, len, buf);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_built_in_read_line_obj, 6, mp_lv_img_decoder_built_in_read_line, lv_img_decoder_built_in_read_line);
    

/*
 * lvgl extension definition for:
 * void lv_img_decoder_built_in_close(lv_img_decoder_t *decoder, lv_img_decoder_dsc_t *dsc)
 */
 
STATIC mp_obj_t mp_lv_img_decoder_built_in_close(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_decoder_t *decoder = mp_write_ptr_lv_img_decoder_t(mp_args[0]);
    lv_img_decoder_dsc_t *dsc = mp_write_ptr_lv_img_decoder_dsc_t(mp_args[1]);
    ((void (*)(lv_img_decoder_t *, lv_img_decoder_dsc_t *))lv_func_ptr)(decoder, dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_decoder_built_in_close_obj, 2, mp_lv_img_decoder_built_in_close, lv_img_decoder_built_in_close);
    

/*
 * lvgl extension definition for:
 * lv_img_src_t lv_img_src_get_type(const void *src)
 */
 
STATIC mp_obj_t mp_lv_img_src_get_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const void *src = mp_to_ptr(mp_args[0]);
    lv_img_src_t _res = ((lv_img_src_t (*)(const void *))lv_func_ptr)(src);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_img_src_get_type_obj, 1, mp_lv_img_src_get_type, lv_img_src_get_type);
    

/*
 * lvgl extension definition for:
 * uint8_t lv_img_cf_get_px_size(lv_img_cf_t cf)
 */
 
STATIC mp_obj_t mp_lv_img_cf_get_px_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_cf_t cf = (uint8_t)mp_obj_get_int(mp_args[0]);
    uint8_t _res = ((uint8_t (*)(lv_img_cf_t))lv_func_ptr)(cf);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_img_cf_get_px_size_obj, 1, mp_lv_img_cf_get_px_size, lv_img_cf_get_px_size);
    

/*
 * lvgl extension definition for:
 * bool lv_img_cf_is_chroma_keyed(lv_img_cf_t cf)
 */
 
STATIC mp_obj_t mp_lv_img_cf_is_chroma_keyed(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_img_cf_t cf = (uint8_t)mp_obj_get_int(mp_args[0]);
    bool _res = ((bool (*)(lv_img_cf_t))lv_func_ptr)(cf);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_img_cf_is_chroma_keyed_obj, 1, mp_lv_img_cf_is_chroma_keyed, lv_img_cf_is_chroma_keyed);
    
/* Reusing lv_img_cf_is_chroma_keyed for lv_img_cf_has_alpha */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_img_cf_has_alpha_obj, 1, mp_lv_img_cf_is_chroma_keyed, lv_img_cf_has_alpha);
    

/*
 * lvgl extension definition for:
 * void lv_img_set_src(lv_obj_t *img, const void *src_img)
 */
 
STATIC mp_obj_t mp_lv_img_set_src(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *img = mp_to_lv(mp_args[0]);
    const void *src_img = mp_to_ptr(mp_args[1]);
    ((void (*)(lv_obj_t *, const void *))lv_func_ptr)(img, src_img);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_set_src_obj, 2, mp_lv_img_set_src, lv_img_set_src);
    
/* Reusing lv_obj_set_auto_realign for lv_img_set_auto_size */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_set_auto_size_obj, 2, mp_lv_obj_set_auto_realign, lv_img_set_auto_size);
    
/* Reusing lv_obj_set_x for lv_img_set_offset_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_set_offset_x_obj, 2, mp_lv_obj_set_x, lv_img_set_offset_x);
    
/* Reusing lv_obj_set_x for lv_img_set_offset_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_set_offset_y_obj, 2, mp_lv_obj_set_x, lv_img_set_offset_y);
    
/* Reusing lv_obj_set_pos for lv_img_set_pivot */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_set_pivot_obj, 3, mp_lv_obj_set_pos, lv_img_set_pivot);
    

/*
 * lvgl extension definition for:
 * void lv_img_set_angle(lv_obj_t *img, int16_t angle)
 */
 
STATIC mp_obj_t mp_lv_img_set_angle(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *img = mp_to_lv(mp_args[0]);
    int16_t angle = (int16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, int16_t))lv_func_ptr)(img, angle);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_set_angle_obj, 2, mp_lv_img_set_angle, lv_img_set_angle);
    
/* Reusing lv_label_set_anim_speed for lv_img_set_zoom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_set_zoom_obj, 2, mp_lv_label_set_anim_speed, lv_img_set_zoom);
    
/* Reusing lv_obj_set_auto_realign for lv_img_set_antialias */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_set_antialias_obj, 2, mp_lv_obj_set_auto_realign, lv_img_set_antialias);
    

/*
 * lvgl extension definition for:
 * const void *lv_img_get_src(lv_obj_t *img)
 */
 
STATIC mp_obj_t mp_lv_img_get_src(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *img = mp_to_lv(mp_args[0]);
    const void * _res = ((const void *(*)(lv_obj_t *))lv_func_ptr)(img);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_get_src_obj, 1, mp_lv_img_get_src, lv_img_get_src);
    

/*
 * lvgl extension definition for:
 * const char *lv_img_get_file_name(const lv_obj_t *img)
 */
 
STATIC mp_obj_t mp_lv_img_get_file_name(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *img = mp_to_lv(mp_args[0]);
    const char * _res = ((const char *(*)(const lv_obj_t *))lv_func_ptr)(img);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_get_file_name_obj, 1, mp_lv_img_get_file_name, lv_img_get_file_name);
    
/* Reusing lv_obj_is_visible for lv_img_get_auto_size */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_get_auto_size_obj, 1, mp_lv_obj_is_visible, lv_img_get_auto_size);
    
/* Reusing lv_obj_get_height_margin for lv_img_get_offset_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_get_offset_x_obj, 1, mp_lv_obj_get_height_margin, lv_img_get_offset_x);
    
/* Reusing lv_obj_get_height_margin for lv_img_get_offset_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_get_offset_y_obj, 1, mp_lv_obj_get_height_margin, lv_img_get_offset_y);
    

/*
 * lvgl extension definition for:
 * uint16_t lv_img_get_angle(lv_obj_t *img)
 */
 
STATIC mp_obj_t mp_lv_img_get_angle(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *img = mp_to_lv(mp_args[0]);
    uint16_t _res = ((uint16_t (*)(lv_obj_t *))lv_func_ptr)(img);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_get_angle_obj, 1, mp_lv_img_get_angle, lv_img_get_angle);
    

/*
 * lvgl extension definition for:
 * void lv_img_get_pivot(lv_obj_t *img, lv_point_t *center)
 */
 
STATIC mp_obj_t mp_lv_img_get_pivot(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *img = mp_to_lv(mp_args[0]);
    lv_point_t *center = mp_write_ptr_lv_point_t(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_point_t *))lv_func_ptr)(img, center);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_get_pivot_obj, 2, mp_lv_img_get_pivot, lv_img_get_pivot);
    
/* Reusing lv_img_get_angle for lv_img_get_zoom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_get_zoom_obj, 1, mp_lv_img_get_angle, lv_img_get_zoom);
    

/*
 * lvgl extension definition for:
 * bool lv_img_get_antialias(lv_obj_t *img)
 */
 
STATIC mp_obj_t mp_lv_img_get_antialias(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *img = mp_to_lv(mp_args[0]);
    bool _res = ((bool (*)(lv_obj_t *))lv_func_ptr)(img);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_img_get_antialias_obj, 1, mp_lv_img_get_antialias, lv_img_get_antialias);
    

/*
 * lvgl extension definition for:
 * void lv_img_cache_set_size(uint16_t new_slot_num)
 */
 
STATIC mp_obj_t mp_lv_img_cache_set_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint16_t new_slot_num = (uint16_t)mp_obj_get_int(mp_args[0]);
    ((void (*)(uint16_t))lv_func_ptr)(new_slot_num);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_img_cache_set_size_obj, 1, mp_lv_img_cache_set_size, lv_img_cache_set_size);
    

/*
 * lvgl extension definition for:
 * void lv_img_cache_invalidate_src(const void *src)
 */
 
STATIC mp_obj_t mp_lv_img_cache_invalidate_src(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const void *src = mp_to_ptr(mp_args[0]);
    ((void (*)(const void *))lv_func_ptr)(src);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_img_cache_invalidate_src_obj, 1, mp_lv_img_cache_invalidate_src, lv_img_cache_invalidate_src);
    

/*
 * lvgl img object definitions
 */
    

STATIC const mp_rom_map_elem_t img_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_buf_alloc), MP_ROM_PTR(&mp_lv_img_buf_alloc_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_get_px_color), MP_ROM_PTR(&mp_lv_img_buf_get_px_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_get_px_alpha), MP_ROM_PTR(&mp_lv_img_buf_get_px_alpha_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_set_px_color), MP_ROM_PTR(&mp_lv_img_buf_set_px_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_set_px_alpha), MP_ROM_PTR(&mp_lv_img_buf_set_px_alpha_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_set_palette), MP_ROM_PTR(&mp_lv_img_buf_set_palette_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_free), MP_ROM_PTR(&mp_lv_img_buf_free_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_get_img_size), MP_ROM_PTR(&mp_lv_img_buf_get_img_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_get_info), MP_ROM_PTR(&mp_lv_img_decoder_get_info_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_open), MP_ROM_PTR(&mp_lv_img_decoder_open_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_read_line), MP_ROM_PTR(&mp_lv_img_decoder_read_line_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_close), MP_ROM_PTR(&mp_lv_img_decoder_close_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_create), MP_ROM_PTR(&mp_lv_img_decoder_create_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_delete), MP_ROM_PTR(&mp_lv_img_decoder_delete_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_set_info_cb), MP_ROM_PTR(&mp_lv_img_decoder_set_info_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_set_open_cb), MP_ROM_PTR(&mp_lv_img_decoder_set_open_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_set_read_line_cb), MP_ROM_PTR(&mp_lv_img_decoder_set_read_line_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_set_close_cb), MP_ROM_PTR(&mp_lv_img_decoder_set_close_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_built_in_info), MP_ROM_PTR(&mp_lv_img_decoder_built_in_info_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_built_in_open), MP_ROM_PTR(&mp_lv_img_decoder_built_in_open_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_built_in_read_line), MP_ROM_PTR(&mp_lv_img_decoder_built_in_read_line_obj) },
    { MP_ROM_QSTR(MP_QSTR_decoder_built_in_close), MP_ROM_PTR(&mp_lv_img_decoder_built_in_close_obj) },
    { MP_ROM_QSTR(MP_QSTR_src_get_type), MP_ROM_PTR(&mp_lv_img_src_get_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_cf_get_px_size), MP_ROM_PTR(&mp_lv_img_cf_get_px_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_cf_is_chroma_keyed), MP_ROM_PTR(&mp_lv_img_cf_is_chroma_keyed_obj) },
    { MP_ROM_QSTR(MP_QSTR_cf_has_alpha), MP_ROM_PTR(&mp_lv_img_cf_has_alpha_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_src), MP_ROM_PTR(&mp_lv_img_set_src_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_auto_size), MP_ROM_PTR(&mp_lv_img_set_auto_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_offset_x), MP_ROM_PTR(&mp_lv_img_set_offset_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_offset_y), MP_ROM_PTR(&mp_lv_img_set_offset_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pivot), MP_ROM_PTR(&mp_lv_img_set_pivot_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_angle), MP_ROM_PTR(&mp_lv_img_set_angle_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_zoom), MP_ROM_PTR(&mp_lv_img_set_zoom_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_antialias), MP_ROM_PTR(&mp_lv_img_set_antialias_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_src), MP_ROM_PTR(&mp_lv_img_get_src_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_file_name), MP_ROM_PTR(&mp_lv_img_get_file_name_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_auto_size), MP_ROM_PTR(&mp_lv_img_get_auto_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_offset_x), MP_ROM_PTR(&mp_lv_img_get_offset_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_offset_y), MP_ROM_PTR(&mp_lv_img_get_offset_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_angle), MP_ROM_PTR(&mp_lv_img_get_angle_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_pivot), MP_ROM_PTR(&mp_lv_img_get_pivot_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_zoom), MP_ROM_PTR(&mp_lv_img_get_zoom_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_antialias), MP_ROM_PTR(&mp_lv_img_get_antialias_obj) },
    { MP_ROM_QSTR(MP_QSTR_cache_set_size), MP_ROM_PTR(&mp_lv_img_cache_set_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_cache_invalidate_src), MP_ROM_PTR(&mp_lv_img_cache_invalidate_src_obj) },
    { MP_ROM_QSTR(MP_QSTR_CF), MP_ROM_PTR(&mp_LV_IMG_CF_type) },
    { MP_ROM_QSTR(MP_QSTR_SRC), MP_ROM_PTR(&mp_LV_IMG_SRC_type) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_IMG_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(img_locals_dict, img_locals_dict_table);

STATIC void img_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl img");
}


STATIC mp_obj_t img_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_img_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_img_type = {
    { &mp_type_type },
    .name = MP_QSTR_img,
    .print = img_print,
    .make_new = img_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&img_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * Array convertors for lv_point_t []
 */

STATIC const lv_point_t *mp_arr_to_lv_point_t_____(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    
    lv_point_t *lv_arr = (lv_point_t*)m_malloc(len * sizeof(lv_point_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = mp_write_lv_point_t(item);
    }
    return (const lv_point_t *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_lv_point_t_____(const lv_point_t *arr)
{
    mp_obj_t obj_arr[1];
    for (size_t i=0; i<1; i++){
        obj_arr[i] = mp_read_lv_point_t(arr[i]);
    }
    return mp_obj_new_list(1, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * lvgl extension definition for:
 * void lv_line_set_points(lv_obj_t *line, const lv_point_t point_a[], uint16_t point_num)
 */
 
STATIC mp_obj_t mp_lv_line_set_points(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *line = mp_to_lv(mp_args[0]);
    const lv_point_t *point_a = mp_arr_to_lv_point_t_____(mp_args[1]);
    uint16_t point_num = (uint16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const lv_point_t [], uint16_t))lv_func_ptr)(line, point_a, point_num);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_line_set_points_obj, 3, mp_lv_line_set_points, lv_line_set_points);
    
/* Reusing lv_obj_set_auto_realign for lv_line_set_auto_size */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_line_set_auto_size_obj, 2, mp_lv_obj_set_auto_realign, lv_line_set_auto_size);
    
/* Reusing lv_obj_set_auto_realign for lv_line_set_y_invert */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_line_set_y_invert_obj, 2, mp_lv_obj_set_auto_realign, lv_line_set_y_invert);
    
/* Reusing lv_obj_is_visible for lv_line_get_auto_size */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_line_get_auto_size_obj, 1, mp_lv_obj_is_visible, lv_line_get_auto_size);
    
/* Reusing lv_obj_is_visible for lv_line_get_y_invert */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_line_get_y_invert_obj, 1, mp_lv_obj_is_visible, lv_line_get_y_invert);
    

/*
 * lvgl line object definitions
 */
    

STATIC const mp_rom_map_elem_t line_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_points), MP_ROM_PTR(&mp_lv_line_set_points_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_auto_size), MP_ROM_PTR(&mp_lv_line_set_auto_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_y_invert), MP_ROM_PTR(&mp_lv_line_set_y_invert_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_auto_size), MP_ROM_PTR(&mp_lv_line_get_auto_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_y_invert), MP_ROM_PTR(&mp_lv_line_get_y_invert_obj) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_LINE_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(line_locals_dict, line_locals_dict_table);

STATIC void line_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl line");
}


STATIC mp_obj_t line_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_line_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_line_type = {
    { &mp_type_type },
    .name = MP_QSTR_line,
    .print = line_print,
    .make_new = line_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&line_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_cont_set_fit4 for lv_page_set_scrollable_fit4 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_set_scrollable_fit4_obj, 5, mp_lv_cont_set_fit4, lv_page_set_scrollable_fit4);
    
/* Reusing lv_cont_set_fit2 for lv_page_set_scrollable_fit2 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_set_scrollable_fit2_obj, 3, mp_lv_cont_set_fit2, lv_page_set_scrollable_fit2);
    
/* Reusing lv_cont_set_fit for lv_page_set_scrollable_fit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_set_scrollable_fit_obj, 2, mp_lv_cont_set_fit, lv_page_set_scrollable_fit);
    
/* Reusing lv_obj_set_x for lv_page_set_scrl_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_set_scrl_width_obj, 2, mp_lv_obj_set_x, lv_page_set_scrl_width);
    
/* Reusing lv_obj_set_x for lv_page_set_scrl_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_set_scrl_height_obj, 2, mp_lv_obj_set_x, lv_page_set_scrl_height);
    
/* Reusing lv_cont_set_layout for lv_page_set_scrl_layout */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_set_scrl_layout_obj, 2, mp_lv_cont_set_layout, lv_page_set_scrl_layout);
    
/* Reusing lv_obj_get_x for lv_page_get_scrl_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_get_scrl_width_obj, 1, mp_lv_obj_get_x, lv_page_get_scrl_width);
    
/* Reusing lv_obj_get_x for lv_page_get_scrl_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_get_scrl_height_obj, 1, mp_lv_obj_get_x, lv_page_get_scrl_height);
    
/* Reusing lv_cont_get_layout for lv_page_get_scrl_layout */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_get_scrl_layout_obj, 1, mp_lv_cont_get_layout, lv_page_get_scrl_layout);
    
/* Reusing lv_cont_get_fit_left for lv_page_get_scrl_fit_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_get_scrl_fit_left_obj, 1, mp_lv_cont_get_fit_left, lv_page_get_scrl_fit_left);
    
/* Reusing lv_cont_get_fit_left for lv_page_get_scrl_fit_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_get_scrl_fit_right_obj, 1, mp_lv_cont_get_fit_left, lv_page_get_scrl_fit_right);
    
/* Reusing lv_cont_get_fit_left for lv_page_get_scrl_fit_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_get_scrl_fit_top_obj, 1, mp_lv_cont_get_fit_left, lv_page_get_scrl_fit_top);
    
/* Reusing lv_cont_get_fit_left for lv_page_get_scrl_fit_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_get_scrl_fit_bottom_obj, 1, mp_lv_cont_get_fit_left, lv_page_get_scrl_fit_bottom);
    
/* Reusing lv_obj_clean for lv_page_clean */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_clean_obj, 1, mp_lv_obj_clean, lv_page_clean);
    
/* Reusing lv_obj_get_screen for lv_page_get_scrollable */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_get_scrollable_obj, 1, mp_lv_obj_get_screen, lv_page_get_scrollable);
    
/* Reusing lv_obj_count_children for lv_page_get_anim_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_get_anim_time_obj, 1, mp_lv_obj_count_children, lv_page_get_anim_time);
    

/*
 * lvgl extension definition for:
 * void lv_page_set_scrollbar_mode(lv_obj_t *page, lv_scrollbar_mode_t sb_mode)
 */
 
STATIC mp_obj_t mp_lv_page_set_scrollbar_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *page = mp_to_lv(mp_args[0]);
    lv_scrollbar_mode_t sb_mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_scrollbar_mode_t))lv_func_ptr)(page, sb_mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_set_scrollbar_mode_obj, 2, mp_lv_page_set_scrollbar_mode, lv_page_set_scrollbar_mode);
    
/* Reusing lv_label_set_anim_speed for lv_page_set_anim_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_set_anim_time_obj, 2, mp_lv_label_set_anim_speed, lv_page_set_anim_time);
    
/* Reusing lv_obj_set_auto_realign for lv_page_set_scroll_propagation */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_set_scroll_propagation_obj, 2, mp_lv_obj_set_auto_realign, lv_page_set_scroll_propagation);
    
/* Reusing lv_obj_set_auto_realign for lv_page_set_edge_flash */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_set_edge_flash_obj, 2, mp_lv_obj_set_auto_realign, lv_page_set_edge_flash);
    

/*
 * lvgl extension definition for:
 * lv_scrollbar_mode_t lv_page_get_scrollbar_mode(const lv_obj_t *page)
 */
 
STATIC mp_obj_t mp_lv_page_get_scrollbar_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *page = mp_to_lv(mp_args[0]);
    lv_scrollbar_mode_t _res = ((lv_scrollbar_mode_t (*)(const lv_obj_t *))lv_func_ptr)(page);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_get_scrollbar_mode_obj, 1, mp_lv_page_get_scrollbar_mode, lv_page_get_scrollbar_mode);
    
/* Reusing lv_img_get_antialias for lv_page_get_scroll_propagation */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_get_scroll_propagation_obj, 1, mp_lv_img_get_antialias, lv_page_get_scroll_propagation);
    
/* Reusing lv_img_get_antialias for lv_page_get_edge_flash */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_get_edge_flash_obj, 1, mp_lv_img_get_antialias, lv_page_get_edge_flash);
    
/* Reusing lv_obj_get_height_margin for lv_page_get_width_fit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_get_width_fit_obj, 1, mp_lv_obj_get_height_margin, lv_page_get_width_fit);
    
/* Reusing lv_obj_get_height_margin for lv_page_get_height_fit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_get_height_fit_obj, 1, mp_lv_obj_get_height_margin, lv_page_get_height_fit);
    
/* Reusing lv_obj_get_width_grid for lv_page_get_width_grid */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_get_width_grid_obj, 3, mp_lv_obj_get_width_grid, lv_page_get_width_grid);
    
/* Reusing lv_obj_get_width_grid for lv_page_get_height_grid */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_get_height_grid_obj, 3, mp_lv_obj_get_width_grid, lv_page_get_height_grid);
    

/*
 * lvgl extension definition for:
 * bool lv_page_on_edge(lv_obj_t *page, lv_page_edge_t edge)
 */
 
STATIC mp_obj_t mp_lv_page_on_edge(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *page = mp_to_lv(mp_args[0]);
    lv_page_edge_t edge = (uint8_t)mp_obj_get_int(mp_args[1]);
    bool _res = ((bool (*)(lv_obj_t *, lv_page_edge_t))lv_func_ptr)(page, edge);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_on_edge_obj, 2, mp_lv_page_on_edge, lv_page_on_edge);
    
/* Reusing lv_obj_set_auto_realign for lv_page_glue_obj */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_glue_obj_obj, 2, mp_lv_obj_set_auto_realign, lv_page_glue_obj);
    

/*
 * lvgl extension definition for:
 * void lv_page_focus(lv_obj_t *page, const lv_obj_t *obj, lv_anim_enable_t anim_en)
 */
 
STATIC mp_obj_t mp_lv_page_focus(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *page = mp_to_lv(mp_args[0]);
    const lv_obj_t *obj = mp_to_lv(mp_args[1]);
    lv_anim_enable_t anim_en = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const lv_obj_t *, lv_anim_enable_t))lv_func_ptr)(page, obj, anim_en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_focus_obj, 3, mp_lv_page_focus, lv_page_focus);
    
/* Reusing lv_obj_set_x for lv_page_scroll_hor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_scroll_hor_obj, 2, mp_lv_obj_set_x, lv_page_scroll_hor);
    
/* Reusing lv_obj_set_x for lv_page_scroll_ver */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_scroll_ver_obj, 2, mp_lv_obj_set_x, lv_page_scroll_ver);
    

/*
 * lvgl extension definition for:
 * void lv_page_start_edge_flash(lv_obj_t *page, lv_page_edge_t edge)
 */
 
STATIC mp_obj_t mp_lv_page_start_edge_flash(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *page = mp_to_lv(mp_args[0]);
    lv_page_edge_t edge = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_page_edge_t))lv_func_ptr)(page, edge);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_page_start_edge_flash_obj, 2, mp_lv_page_start_edge_flash, lv_page_start_edge_flash);
    

/*
 * lvgl page object definitions
 */
    

STATIC const mp_rom_map_elem_t page_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_scrollable_fit4), MP_ROM_PTR(&mp_lv_page_set_scrollable_fit4_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scrollable_fit2), MP_ROM_PTR(&mp_lv_page_set_scrollable_fit2_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scrollable_fit), MP_ROM_PTR(&mp_lv_page_set_scrollable_fit_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scrl_width), MP_ROM_PTR(&mp_lv_page_set_scrl_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scrl_height), MP_ROM_PTR(&mp_lv_page_set_scrl_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scrl_layout), MP_ROM_PTR(&mp_lv_page_set_scrl_layout_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scrl_width), MP_ROM_PTR(&mp_lv_page_get_scrl_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scrl_height), MP_ROM_PTR(&mp_lv_page_get_scrl_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scrl_layout), MP_ROM_PTR(&mp_lv_page_get_scrl_layout_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scrl_fit_left), MP_ROM_PTR(&mp_lv_page_get_scrl_fit_left_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scrl_fit_right), MP_ROM_PTR(&mp_lv_page_get_scrl_fit_right_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scrl_fit_top), MP_ROM_PTR(&mp_lv_page_get_scrl_fit_top_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scrl_fit_bottom), MP_ROM_PTR(&mp_lv_page_get_scrl_fit_bottom_obj) },
    { MP_ROM_QSTR(MP_QSTR_clean), MP_ROM_PTR(&mp_lv_page_clean_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scrollable), MP_ROM_PTR(&mp_lv_page_get_scrollable_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_anim_time), MP_ROM_PTR(&mp_lv_page_get_anim_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scrollbar_mode), MP_ROM_PTR(&mp_lv_page_set_scrollbar_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_anim_time), MP_ROM_PTR(&mp_lv_page_set_anim_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scroll_propagation), MP_ROM_PTR(&mp_lv_page_set_scroll_propagation_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_edge_flash), MP_ROM_PTR(&mp_lv_page_set_edge_flash_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scrollbar_mode), MP_ROM_PTR(&mp_lv_page_get_scrollbar_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_propagation), MP_ROM_PTR(&mp_lv_page_get_scroll_propagation_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_edge_flash), MP_ROM_PTR(&mp_lv_page_get_edge_flash_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_width_fit), MP_ROM_PTR(&mp_lv_page_get_width_fit_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_height_fit), MP_ROM_PTR(&mp_lv_page_get_height_fit_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_width_grid), MP_ROM_PTR(&mp_lv_page_get_width_grid_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_height_grid), MP_ROM_PTR(&mp_lv_page_get_height_grid_obj) },
    { MP_ROM_QSTR(MP_QSTR_on_edge), MP_ROM_PTR(&mp_lv_page_on_edge_obj) },
    { MP_ROM_QSTR(MP_QSTR_glue_obj), MP_ROM_PTR(&mp_lv_page_glue_obj_obj) },
    { MP_ROM_QSTR(MP_QSTR_focus), MP_ROM_PTR(&mp_lv_page_focus_obj) },
    { MP_ROM_QSTR(MP_QSTR_scroll_hor), MP_ROM_PTR(&mp_lv_page_scroll_hor_obj) },
    { MP_ROM_QSTR(MP_QSTR_scroll_ver), MP_ROM_PTR(&mp_lv_page_scroll_ver_obj) },
    { MP_ROM_QSTR(MP_QSTR_start_edge_flash), MP_ROM_PTR(&mp_lv_page_start_edge_flash_obj) },
    { MP_ROM_QSTR(MP_QSTR_EDGE), MP_ROM_PTR(&mp_LV_PAGE_EDGE_type) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_PAGE_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(page_locals_dict, page_locals_dict_table);

STATIC void page_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl page");
}


STATIC mp_obj_t page_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_page_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_page_type = {
    { &mp_type_type },
    .name = MP_QSTR_page,
    .print = page_print,
    .make_new = page_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&page_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_page_set_scrollbar_mode for lv_list_set_scrollbar_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_set_scrollbar_mode_obj, 2, mp_lv_page_set_scrollbar_mode, lv_list_set_scrollbar_mode);
    
/* Reusing lv_obj_set_auto_realign for lv_list_set_scroll_propagation */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_set_scroll_propagation_obj, 2, mp_lv_obj_set_auto_realign, lv_list_set_scroll_propagation);
    
/* Reusing lv_obj_set_auto_realign for lv_list_set_edge_flash */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_set_edge_flash_obj, 2, mp_lv_obj_set_auto_realign, lv_list_set_edge_flash);
    
/* Reusing lv_label_set_anim_speed for lv_list_set_anim_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_set_anim_time_obj, 2, mp_lv_label_set_anim_speed, lv_list_set_anim_time);
    
/* Reusing lv_page_get_scrollbar_mode for lv_list_get_scrollbar_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_get_scrollbar_mode_obj, 1, mp_lv_page_get_scrollbar_mode, lv_list_get_scrollbar_mode);
    
/* Reusing lv_img_get_antialias for lv_list_get_scroll_propagation */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_get_scroll_propagation_obj, 1, mp_lv_img_get_antialias, lv_list_get_scroll_propagation);
    
/* Reusing lv_img_get_antialias for lv_list_get_edge_flash */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_get_edge_flash_obj, 1, mp_lv_img_get_antialias, lv_list_get_edge_flash);
    
/* Reusing lv_obj_count_children for lv_list_get_anim_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_get_anim_time_obj, 1, mp_lv_obj_count_children, lv_list_get_anim_time);
    
/* Reusing lv_obj_clean for lv_list_clean */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_clean_obj, 1, mp_lv_obj_clean, lv_list_clean);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_list_add_btn(lv_obj_t *list, const void *img_src, const char *txt)
 */
 
STATIC mp_obj_t mp_lv_list_add_btn(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *list = mp_to_lv(mp_args[0]);
    const void *img_src = mp_to_ptr(mp_args[1]);
    const char *txt = (char*)convert_from_str(mp_args[2]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *, const void *, const char *))lv_func_ptr)(list, img_src, txt);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_add_btn_obj, 3, mp_lv_list_add_btn, lv_list_add_btn);
    

/*
 * lvgl extension definition for:
 * bool lv_list_remove(const lv_obj_t *list, uint16_t index)
 */
 
STATIC mp_obj_t mp_lv_list_remove(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *list = mp_to_lv(mp_args[0]);
    uint16_t index = (uint16_t)mp_obj_get_int(mp_args[1]);
    bool _res = ((bool (*)(const lv_obj_t *, uint16_t))lv_func_ptr)(list, index);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_remove_obj, 2, mp_lv_list_remove, lv_list_remove);
    
/* Reusing lv_obj_set_parent for lv_list_focus_btn */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_focus_btn_obj, 2, mp_lv_obj_set_parent, lv_list_focus_btn);
    
/* Reusing lv_cont_set_layout for lv_list_set_layout */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_set_layout_obj, 2, mp_lv_cont_set_layout, lv_list_set_layout);
    
/* Reusing lv_img_get_file_name for lv_list_get_btn_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_get_btn_text_obj, 1, mp_lv_img_get_file_name, lv_list_get_btn_text);
    
/* Reusing lv_obj_get_screen for lv_list_get_btn_label */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_get_btn_label_obj, 1, mp_lv_obj_get_screen, lv_list_get_btn_label);
    
/* Reusing lv_obj_get_screen for lv_list_get_btn_img */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_get_btn_img_obj, 1, mp_lv_obj_get_screen, lv_list_get_btn_img);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_list_get_prev_btn(const lv_obj_t *list, lv_obj_t *prev_btn)
 */
 
STATIC mp_obj_t mp_lv_list_get_prev_btn(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *list = mp_to_lv(mp_args[0]);
    lv_obj_t *prev_btn = mp_to_lv(mp_args[1]);
    lv_obj_t * _res = ((lv_obj_t *(*)(const lv_obj_t *, lv_obj_t *))lv_func_ptr)(list, prev_btn);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_get_prev_btn_obj, 2, mp_lv_list_get_prev_btn, lv_list_get_prev_btn);
    
/* Reusing lv_list_get_prev_btn for lv_list_get_next_btn */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_get_next_btn_obj, 2, mp_lv_list_get_prev_btn, lv_list_get_next_btn);
    

/*
 * lvgl extension definition for:
 * int32_t lv_list_get_btn_index(const lv_obj_t *list, const lv_obj_t *btn)
 */
 
STATIC mp_obj_t mp_lv_list_get_btn_index(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *list = mp_to_lv(mp_args[0]);
    const lv_obj_t *btn = mp_to_lv(mp_args[1]);
    int32_t _res = ((int32_t (*)(const lv_obj_t *, const lv_obj_t *))lv_func_ptr)(list, btn);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_get_btn_index_obj, 2, mp_lv_list_get_btn_index, lv_list_get_btn_index);
    
/* Reusing lv_obj_count_children for lv_list_get_size */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_get_size_obj, 1, mp_lv_obj_count_children, lv_list_get_size);
    
/* Reusing lv_obj_get_screen for lv_list_get_btn_selected */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_get_btn_selected_obj, 1, mp_lv_obj_get_screen, lv_list_get_btn_selected);
    

/*
 * lvgl extension definition for:
 * lv_layout_t lv_list_get_layout(lv_obj_t *list)
 */
 
STATIC mp_obj_t mp_lv_list_get_layout(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *list = mp_to_lv(mp_args[0]);
    lv_layout_t _res = ((lv_layout_t (*)(lv_obj_t *))lv_func_ptr)(list);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_get_layout_obj, 1, mp_lv_list_get_layout, lv_list_get_layout);
    
/* Reusing lv_obj_invalidate for lv_list_up */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_up_obj, 1, mp_lv_obj_invalidate, lv_list_up);
    
/* Reusing lv_obj_invalidate for lv_list_down */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_down_obj, 1, mp_lv_obj_invalidate, lv_list_down);
    

/*
 * lvgl extension definition for:
 * void lv_list_focus(const lv_obj_t *btn, lv_anim_enable_t anim)
 */
 
STATIC mp_obj_t mp_lv_list_focus(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *btn = mp_to_lv(mp_args[0]);
    lv_anim_enable_t anim = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(const lv_obj_t *, lv_anim_enable_t))lv_func_ptr)(btn, anim);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_list_focus_obj, 2, mp_lv_list_focus, lv_list_focus);
    

/*
 * lvgl list object definitions
 */
    

STATIC const mp_rom_map_elem_t list_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_scrollbar_mode), MP_ROM_PTR(&mp_lv_list_set_scrollbar_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scroll_propagation), MP_ROM_PTR(&mp_lv_list_set_scroll_propagation_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_edge_flash), MP_ROM_PTR(&mp_lv_list_set_edge_flash_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_anim_time), MP_ROM_PTR(&mp_lv_list_set_anim_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scrollbar_mode), MP_ROM_PTR(&mp_lv_list_get_scrollbar_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_propagation), MP_ROM_PTR(&mp_lv_list_get_scroll_propagation_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_edge_flash), MP_ROM_PTR(&mp_lv_list_get_edge_flash_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_anim_time), MP_ROM_PTR(&mp_lv_list_get_anim_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_clean), MP_ROM_PTR(&mp_lv_list_clean_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_btn), MP_ROM_PTR(&mp_lv_list_add_btn_obj) },
    { MP_ROM_QSTR(MP_QSTR_remove), MP_ROM_PTR(&mp_lv_list_remove_obj) },
    { MP_ROM_QSTR(MP_QSTR_focus_btn), MP_ROM_PTR(&mp_lv_list_focus_btn_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_layout), MP_ROM_PTR(&mp_lv_list_set_layout_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_btn_text), MP_ROM_PTR(&mp_lv_list_get_btn_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_btn_label), MP_ROM_PTR(&mp_lv_list_get_btn_label_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_btn_img), MP_ROM_PTR(&mp_lv_list_get_btn_img_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_prev_btn), MP_ROM_PTR(&mp_lv_list_get_prev_btn_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_next_btn), MP_ROM_PTR(&mp_lv_list_get_next_btn_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_btn_index), MP_ROM_PTR(&mp_lv_list_get_btn_index_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_size), MP_ROM_PTR(&mp_lv_list_get_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_btn_selected), MP_ROM_PTR(&mp_lv_list_get_btn_selected_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_layout), MP_ROM_PTR(&mp_lv_list_get_layout_obj) },
    { MP_ROM_QSTR(MP_QSTR_up), MP_ROM_PTR(&mp_lv_list_up_obj) },
    { MP_ROM_QSTR(MP_QSTR_down), MP_ROM_PTR(&mp_lv_list_down_obj) },
    { MP_ROM_QSTR(MP_QSTR_focus), MP_ROM_PTR(&mp_lv_list_focus_obj) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_LIST_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(list_locals_dict, list_locals_dict_table);

STATIC void list_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl list");
}


STATIC mp_obj_t list_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_list_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_list_type = {
    { &mp_type_type },
    .name = MP_QSTR_list,
    .print = list_print,
    .make_new = list_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&list_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * Struct lv_chart_series_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_chart_series_t_type();

STATIC inline lv_chart_series_t* mp_write_ptr_lv_chart_series_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_chart_series_t_type()));
    return (lv_chart_series_t*)self->data;
}

#define mp_write_lv_chart_series_t(struct_obj) *mp_write_ptr_lv_chart_series_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_chart_series_t(lv_chart_series_t *field)
{
    return lv_to_mp_struct(get_mp_lv_chart_series_t_type(), (void*)field);
}

#define mp_read_lv_chart_series_t(field) mp_read_ptr_lv_chart_series_t(copy_buffer(&field, sizeof(lv_chart_series_t)))
#define mp_read_byref_lv_chart_series_t(field) mp_read_ptr_lv_chart_series_t(&field)

STATIC void mp_lv_chart_series_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_chart_series_t *data = (lv_chart_series_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_points: dest[0] = ptr_to_mp((void*)data->points); break; // converting from lv_coord_t *;
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color32_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_start_point: dest[0] = mp_obj_new_int_from_uint(data->start_point); break; // converting from uint16_t;
            case MP_QSTR_ext_buf_assigned: dest[0] = mp_obj_new_int_from_uint(data->ext_buf_assigned); break; // converting from uint8_t;
            case MP_QSTR_hidden: dest[0] = mp_obj_new_int_from_uint(data->hidden); break; // converting from uint8_t;
            case MP_QSTR_y_axis: dest[0] = mp_obj_new_int_from_uint(data->y_axis); break; // converting from lv_chart_axis_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_points: data->points = (void*)mp_to_ptr(dest[1]); break; // converting to lv_coord_t *;
                case MP_QSTR_color: data->color = mp_write_lv_color32_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_start_point: data->start_point = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_ext_buf_assigned: data->ext_buf_assigned = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_hidden: data->hidden = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_y_axis: data->y_axis = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_chart_axis_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_chart_series_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_chart_series_t");
}

STATIC const mp_obj_dict_t mp_lv_chart_series_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_chart_series_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_chart_series_t,
    .print = mp_lv_chart_series_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_chart_series_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_chart_series_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_chart_series_t_type()
{
    return &mp_lv_chart_series_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_chart_series_t *lv_chart_add_series(lv_obj_t *chart, lv_color_t color)
 */
 
STATIC mp_obj_t mp_lv_chart_add_series(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_color_t color = mp_write_lv_color32_t(mp_args[1]);
    lv_chart_series_t * _res = ((lv_chart_series_t *(*)(lv_obj_t *, lv_color_t))lv_func_ptr)(chart, color);
    return mp_read_ptr_lv_chart_series_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_add_series_obj, 2, mp_lv_chart_add_series, lv_chart_add_series);
    

/*
 * lvgl extension definition for:
 * void lv_chart_remove_series(lv_obj_t *chart, lv_chart_series_t *series)
 */
 
STATIC mp_obj_t mp_lv_chart_remove_series(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_series_t *series = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *))lv_func_ptr)(chart, series);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_remove_series_obj, 2, mp_lv_chart_remove_series, lv_chart_remove_series);
    

/*
 * Struct lv_chart_cursor_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_chart_cursor_t_type();

STATIC inline lv_chart_cursor_t* mp_write_ptr_lv_chart_cursor_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_chart_cursor_t_type()));
    return (lv_chart_cursor_t*)self->data;
}

#define mp_write_lv_chart_cursor_t(struct_obj) *mp_write_ptr_lv_chart_cursor_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_chart_cursor_t(lv_chart_cursor_t *field)
{
    return lv_to_mp_struct(get_mp_lv_chart_cursor_t_type(), (void*)field);
}

#define mp_read_lv_chart_cursor_t(field) mp_read_ptr_lv_chart_cursor_t(copy_buffer(&field, sizeof(lv_chart_cursor_t)))
#define mp_read_byref_lv_chart_cursor_t(field) mp_read_ptr_lv_chart_cursor_t(&field)

STATIC void mp_lv_chart_cursor_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_chart_cursor_t *data = (lv_chart_cursor_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_point: dest[0] = mp_read_byref_lv_point_t(data->point); break; // converting from lv_point_t;
            case MP_QSTR_color: dest[0] = mp_read_byref_lv_color32_t(data->color); break; // converting from lv_color_t;
            case MP_QSTR_axes: dest[0] = mp_obj_new_int_from_uint(data->axes); break; // converting from lv_cursor_direction_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_point: data->point = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_color: data->color = mp_write_lv_color32_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_axes: data->axes = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_cursor_direction_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_chart_cursor_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_chart_cursor_t");
}

STATIC const mp_obj_dict_t mp_lv_chart_cursor_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_chart_cursor_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_chart_cursor_t,
    .print = mp_lv_chart_cursor_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_chart_cursor_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_chart_cursor_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_chart_cursor_t_type()
{
    return &mp_lv_chart_cursor_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_chart_cursor_t *lv_chart_add_cursor(lv_obj_t *chart, lv_color_t color, lv_cursor_direction_t dir)
 */
 
STATIC mp_obj_t mp_lv_chart_add_cursor(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_color_t color = mp_write_lv_color32_t(mp_args[1]);
    lv_cursor_direction_t dir = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_chart_cursor_t * _res = ((lv_chart_cursor_t *(*)(lv_obj_t *, lv_color_t, lv_cursor_direction_t))lv_func_ptr)(chart, color, dir);
    return mp_read_ptr_lv_chart_cursor_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_add_cursor_obj, 3, mp_lv_chart_add_cursor, lv_chart_add_cursor);
    
/* Reusing lv_chart_remove_series for lv_chart_clear_series */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_clear_series_obj, 2, mp_lv_chart_remove_series, lv_chart_clear_series);
    

/*
 * lvgl extension definition for:
 * void lv_chart_hide_series(lv_obj_t *chart, lv_chart_series_t *series, bool hide)
 */
 
STATIC mp_obj_t mp_lv_chart_hide_series(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_series_t *series = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    bool hide = mp_obj_is_true(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, bool))lv_func_ptr)(chart, series, hide);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_hide_series_obj, 3, mp_lv_chart_hide_series, lv_chart_hide_series);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_div_line_count(lv_obj_t *chart, uint8_t hdiv, uint8_t vdiv)
 */
 
STATIC mp_obj_t mp_lv_chart_set_div_line_count(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    uint8_t hdiv = (uint8_t)mp_obj_get_int(mp_args[1]);
    uint8_t vdiv = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint8_t, uint8_t))lv_func_ptr)(chart, hdiv, vdiv);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_div_line_count_obj, 3, mp_lv_chart_set_div_line_count, lv_chart_set_div_line_count);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_y_range(lv_obj_t *chart, lv_chart_axis_t axis, lv_coord_t ymin, lv_coord_t ymax)
 */
 
STATIC mp_obj_t mp_lv_chart_set_y_range(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_axis_t axis = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t ymin = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t ymax = (int16_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_chart_axis_t, lv_coord_t, lv_coord_t))lv_func_ptr)(chart, axis, ymin, ymax);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_y_range_obj, 4, mp_lv_chart_set_y_range, lv_chart_set_y_range);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_type(lv_obj_t *chart, lv_chart_type_t type)
 */
 
STATIC mp_obj_t mp_lv_chart_set_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_type_t type = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_chart_type_t))lv_func_ptr)(chart, type);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_type_obj, 2, mp_lv_chart_set_type, lv_chart_set_type);
    
/* Reusing lv_label_set_anim_speed for lv_chart_set_point_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_point_count_obj, 2, mp_lv_label_set_anim_speed, lv_chart_set_point_count);
    

/*
 * lvgl extension definition for:
 * void lv_chart_init_points(lv_obj_t *chart, lv_chart_series_t *ser, lv_coord_t y)
 */
 
STATIC mp_obj_t mp_lv_chart_init_points(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, lv_coord_t))lv_func_ptr)(chart, ser, y);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_init_points_obj, 3, mp_lv_chart_init_points, lv_chart_init_points);
    

/*
 * Array convertors for lv_coord_t []
 */

STATIC lv_coord_t *mp_arr_to_lv_coord_t_____(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    
    lv_coord_t *lv_arr = (lv_coord_t*)m_malloc(len * sizeof(lv_coord_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (int16_t)mp_obj_get_int(item);
    }
    return (lv_coord_t *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_lv_coord_t_____(lv_coord_t *arr)
{
    mp_obj_t obj_arr[1];
    for (size_t i=0; i<1; i++){
        obj_arr[i] = mp_obj_new_int(arr[i]);
    }
    return mp_obj_new_list(1, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_points(lv_obj_t *chart, lv_chart_series_t *ser, lv_coord_t y_array[])
 */
 
STATIC mp_obj_t mp_lv_chart_set_points(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    lv_coord_t *y_array = mp_arr_to_lv_coord_t_____(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, lv_coord_t []))lv_func_ptr)(chart, ser, y_array);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_points_obj, 3, mp_lv_chart_set_points, lv_chart_set_points);
    
/* Reusing lv_chart_init_points for lv_chart_set_next */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_next_obj, 3, mp_lv_chart_init_points, lv_chart_set_next);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_update_mode(lv_obj_t *chart, lv_chart_update_mode_t update_mode)
 */
 
STATIC mp_obj_t mp_lv_chart_set_update_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_update_mode_t update_mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_chart_update_mode_t))lv_func_ptr)(chart, update_mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_update_mode_obj, 2, mp_lv_chart_set_update_mode, lv_chart_set_update_mode);
    
/* Reusing lv_chart_set_div_line_count for lv_chart_set_x_tick_length */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_x_tick_length_obj, 3, mp_lv_chart_set_div_line_count, lv_chart_set_x_tick_length);
    
/* Reusing lv_chart_set_div_line_count for lv_chart_set_y_tick_length */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_y_tick_length_obj, 3, mp_lv_chart_set_div_line_count, lv_chart_set_y_tick_length);
    
/* Reusing lv_chart_set_div_line_count for lv_chart_set_secondary_y_tick_length */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_secondary_y_tick_length_obj, 3, mp_lv_chart_set_div_line_count, lv_chart_set_secondary_y_tick_length);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_x_tick_texts(lv_obj_t *chart, const char *list_of_values, uint8_t num_tick_marks, lv_chart_axis_options_t options)
 */
 
STATIC mp_obj_t mp_lv_chart_set_x_tick_texts(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    const char *list_of_values = (char*)convert_from_str(mp_args[1]);
    uint8_t num_tick_marks = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_chart_axis_options_t options = (uint8_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, const char *, uint8_t, lv_chart_axis_options_t))lv_func_ptr)(chart, list_of_values, num_tick_marks, options);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_x_tick_texts_obj, 4, mp_lv_chart_set_x_tick_texts, lv_chart_set_x_tick_texts);
    
/* Reusing lv_chart_set_x_tick_texts for lv_chart_set_secondary_y_tick_texts */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_secondary_y_tick_texts_obj, 4, mp_lv_chart_set_x_tick_texts, lv_chart_set_secondary_y_tick_texts);
    
/* Reusing lv_chart_set_x_tick_texts for lv_chart_set_y_tick_texts */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_y_tick_texts_obj, 4, mp_lv_chart_set_x_tick_texts, lv_chart_set_y_tick_texts);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_x_start_point(lv_obj_t *chart, lv_chart_series_t *ser, uint16_t id)
 */
 
STATIC mp_obj_t mp_lv_chart_set_x_start_point(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    uint16_t id = (uint16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, uint16_t))lv_func_ptr)(chart, ser, id);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_x_start_point_obj, 3, mp_lv_chart_set_x_start_point, lv_chart_set_x_start_point);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_ext_array(lv_obj_t *chart, lv_chart_series_t *ser, lv_coord_t array[], uint16_t point_cnt)
 */
 
STATIC mp_obj_t mp_lv_chart_set_ext_array(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    lv_coord_t *array = mp_arr_to_lv_coord_t_____(mp_args[2]);
    uint16_t point_cnt = (uint16_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, lv_coord_t [], uint16_t))lv_func_ptr)(chart, ser, array, point_cnt);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_ext_array_obj, 4, mp_lv_chart_set_ext_array, lv_chart_set_ext_array);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_point_id(lv_obj_t *chart, lv_chart_series_t *ser, lv_coord_t value, uint16_t id)
 */
 
STATIC mp_obj_t mp_lv_chart_set_point_id(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    lv_coord_t value = (int16_t)mp_obj_get_int(mp_args[2]);
    uint16_t id = (uint16_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, lv_coord_t, uint16_t))lv_func_ptr)(chart, ser, value, id);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_point_id_obj, 4, mp_lv_chart_set_point_id, lv_chart_set_point_id);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_series_axis(lv_obj_t *chart, lv_chart_series_t *ser, lv_chart_axis_t axis)
 */
 
STATIC mp_obj_t mp_lv_chart_set_series_axis(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    lv_chart_axis_t axis = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_chart_series_t *, lv_chart_axis_t))lv_func_ptr)(chart, ser, axis);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_series_axis_obj, 3, mp_lv_chart_set_series_axis, lv_chart_set_series_axis);
    

/*
 * lvgl extension definition for:
 * void lv_chart_set_cursor_point(lv_obj_t *chart, lv_chart_cursor_t *cursor, lv_point_t *point)
 */
 
STATIC mp_obj_t mp_lv_chart_set_cursor_point(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_cursor_t *cursor = mp_write_ptr_lv_chart_cursor_t(mp_args[1]);
    lv_point_t *point = mp_write_ptr_lv_point_t(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_chart_cursor_t *, lv_point_t *))lv_func_ptr)(chart, cursor, point);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_set_cursor_point_obj, 3, mp_lv_chart_set_cursor_point, lv_chart_set_cursor_point);
    

/*
 * lvgl extension definition for:
 * lv_chart_type_t lv_chart_get_type(const lv_obj_t *chart)
 */
 
STATIC mp_obj_t mp_lv_chart_get_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_type_t _res = ((lv_chart_type_t (*)(const lv_obj_t *))lv_func_ptr)(chart);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_type_obj, 1, mp_lv_chart_get_type, lv_chart_get_type);
    
/* Reusing lv_obj_count_children for lv_chart_get_point_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_point_count_obj, 1, mp_lv_obj_count_children, lv_chart_get_point_count);
    

/*
 * lvgl extension definition for:
 * uint16_t lv_chart_get_x_start_point(lv_chart_series_t *ser)
 */
 
STATIC mp_obj_t mp_lv_chart_get_x_start_point(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[0]);
    uint16_t _res = ((uint16_t (*)(lv_chart_series_t *))lv_func_ptr)(ser);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_x_start_point_obj, 1, mp_lv_chart_get_x_start_point, lv_chart_get_x_start_point);
    

/*
 * lvgl extension definition for:
 * lv_coord_t lv_chart_get_point_id(lv_obj_t *chart, lv_chart_series_t *ser, uint16_t id)
 */
 
STATIC mp_obj_t mp_lv_chart_get_point_id(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    uint16_t id = (uint16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t _res = ((lv_coord_t (*)(lv_obj_t *, lv_chart_series_t *, uint16_t))lv_func_ptr)(chart, ser, id);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_point_id_obj, 3, mp_lv_chart_get_point_id, lv_chart_get_point_id);
    

/*
 * lvgl extension definition for:
 * lv_chart_axis_t lv_chart_get_series_axis(lv_obj_t *chart, lv_chart_series_t *ser)
 */
 
STATIC mp_obj_t mp_lv_chart_get_series_axis(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_series_t *ser = mp_write_ptr_lv_chart_series_t(mp_args[1]);
    lv_chart_axis_t _res = ((lv_chart_axis_t (*)(lv_obj_t *, lv_chart_series_t *))lv_func_ptr)(chart, ser);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_series_axis_obj, 2, mp_lv_chart_get_series_axis, lv_chart_get_series_axis);
    

/*
 * lvgl extension definition for:
 * void lv_chart_get_series_area(lv_obj_t *chart, lv_area_t *series_area)
 */
 
STATIC mp_obj_t mp_lv_chart_get_series_area(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_area_t *series_area = mp_write_ptr_lv_area_t(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_area_t *))lv_func_ptr)(chart, series_area);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_series_area_obj, 2, mp_lv_chart_get_series_area, lv_chart_get_series_area);
    

/*
 * lvgl extension definition for:
 * lv_point_t lv_chart_get_cursor_point(lv_obj_t *chart, lv_chart_cursor_t *cursor)
 */
 
STATIC mp_obj_t mp_lv_chart_get_cursor_point(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_chart_cursor_t *cursor = mp_write_ptr_lv_chart_cursor_t(mp_args[1]);
    lv_point_t _res = ((lv_point_t (*)(lv_obj_t *, lv_chart_cursor_t *))lv_func_ptr)(chart, cursor);
    return mp_read_lv_point_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_cursor_point_obj, 2, mp_lv_chart_get_cursor_point, lv_chart_get_cursor_point);
    

/*
 * lvgl extension definition for:
 * uint16_t lv_chart_get_nearest_index_from_coord(lv_obj_t *chart, lv_coord_t x)
 */
 
STATIC mp_obj_t mp_lv_chart_get_nearest_index_from_coord(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *chart = mp_to_lv(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    uint16_t _res = ((uint16_t (*)(lv_obj_t *, lv_coord_t))lv_func_ptr)(chart, x);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_nearest_index_from_coord_obj, 2, mp_lv_chart_get_nearest_index_from_coord, lv_chart_get_nearest_index_from_coord);
    
/* Reusing lv_chart_get_point_id for lv_chart_get_x_from_index */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_x_from_index_obj, 3, mp_lv_chart_get_point_id, lv_chart_get_x_from_index);
    
/* Reusing lv_chart_get_point_id for lv_chart_get_y_from_index */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_get_y_from_index_obj, 3, mp_lv_chart_get_point_id, lv_chart_get_y_from_index);
    
/* Reusing lv_obj_clean for lv_chart_refresh */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_chart_refresh_obj, 1, mp_lv_obj_clean, lv_chart_refresh);
    

/*
 * lvgl chart object definitions
 */
    

STATIC const mp_rom_map_elem_t chart_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_add_series), MP_ROM_PTR(&mp_lv_chart_add_series_obj) },
    { MP_ROM_QSTR(MP_QSTR_remove_series), MP_ROM_PTR(&mp_lv_chart_remove_series_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_cursor), MP_ROM_PTR(&mp_lv_chart_add_cursor_obj) },
    { MP_ROM_QSTR(MP_QSTR_clear_series), MP_ROM_PTR(&mp_lv_chart_clear_series_obj) },
    { MP_ROM_QSTR(MP_QSTR_hide_series), MP_ROM_PTR(&mp_lv_chart_hide_series_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_div_line_count), MP_ROM_PTR(&mp_lv_chart_set_div_line_count_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_y_range), MP_ROM_PTR(&mp_lv_chart_set_y_range_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_type), MP_ROM_PTR(&mp_lv_chart_set_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_point_count), MP_ROM_PTR(&mp_lv_chart_set_point_count_obj) },
    { MP_ROM_QSTR(MP_QSTR_init_points), MP_ROM_PTR(&mp_lv_chart_init_points_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_points), MP_ROM_PTR(&mp_lv_chart_set_points_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_next), MP_ROM_PTR(&mp_lv_chart_set_next_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_update_mode), MP_ROM_PTR(&mp_lv_chart_set_update_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_x_tick_length), MP_ROM_PTR(&mp_lv_chart_set_x_tick_length_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_y_tick_length), MP_ROM_PTR(&mp_lv_chart_set_y_tick_length_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_secondary_y_tick_length), MP_ROM_PTR(&mp_lv_chart_set_secondary_y_tick_length_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_x_tick_texts), MP_ROM_PTR(&mp_lv_chart_set_x_tick_texts_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_secondary_y_tick_texts), MP_ROM_PTR(&mp_lv_chart_set_secondary_y_tick_texts_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_y_tick_texts), MP_ROM_PTR(&mp_lv_chart_set_y_tick_texts_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_x_start_point), MP_ROM_PTR(&mp_lv_chart_set_x_start_point_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_ext_array), MP_ROM_PTR(&mp_lv_chart_set_ext_array_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_point_id), MP_ROM_PTR(&mp_lv_chart_set_point_id_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_series_axis), MP_ROM_PTR(&mp_lv_chart_set_series_axis_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_cursor_point), MP_ROM_PTR(&mp_lv_chart_set_cursor_point_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_type), MP_ROM_PTR(&mp_lv_chart_get_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_point_count), MP_ROM_PTR(&mp_lv_chart_get_point_count_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_x_start_point), MP_ROM_PTR(&mp_lv_chart_get_x_start_point_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_point_id), MP_ROM_PTR(&mp_lv_chart_get_point_id_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_series_axis), MP_ROM_PTR(&mp_lv_chart_get_series_axis_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_series_area), MP_ROM_PTR(&mp_lv_chart_get_series_area_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_cursor_point), MP_ROM_PTR(&mp_lv_chart_get_cursor_point_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_nearest_index_from_coord), MP_ROM_PTR(&mp_lv_chart_get_nearest_index_from_coord_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_x_from_index), MP_ROM_PTR(&mp_lv_chart_get_x_from_index_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_y_from_index), MP_ROM_PTR(&mp_lv_chart_get_y_from_index_obj) },
    { MP_ROM_QSTR(MP_QSTR_refresh), MP_ROM_PTR(&mp_lv_chart_refresh_obj) },
    { MP_ROM_QSTR(MP_QSTR_TYPE), MP_ROM_PTR(&mp_LV_CHART_TYPE_type) },
    { MP_ROM_QSTR(MP_QSTR_UPDATE_MODE), MP_ROM_PTR(&mp_LV_CHART_UPDATE_MODE_type) },
    { MP_ROM_QSTR(MP_QSTR_AXIS), MP_ROM_PTR(&mp_LV_CHART_AXIS_type) },
    { MP_ROM_QSTR(MP_QSTR_CURSOR), MP_ROM_PTR(&mp_LV_CHART_CURSOR_type) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_CHART_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(chart_locals_dict, chart_locals_dict_table);

STATIC void chart_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl chart");
}


STATIC mp_obj_t chart_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_chart_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_chart_type = {
    { &mp_type_type },
    .name = MP_QSTR_chart,
    .print = chart_print,
    .make_new = chart_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&chart_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * void lv_table_set_cell_value(lv_obj_t *table, uint16_t row, uint16_t col, const char *txt)
 */
 
STATIC mp_obj_t mp_lv_table_set_cell_value(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *table = mp_to_lv(mp_args[0]);
    uint16_t row = (uint16_t)mp_obj_get_int(mp_args[1]);
    uint16_t col = (uint16_t)mp_obj_get_int(mp_args[2]);
    const char *txt = (char*)convert_from_str(mp_args[3]);
    ((void (*)(lv_obj_t *, uint16_t, uint16_t, const char *))lv_func_ptr)(table, row, col, txt);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_set_cell_value_obj, 4, mp_lv_table_set_cell_value, lv_table_set_cell_value);
    

/*
 * Function NOT generated:
 * Cannot convert ellipsis param
 * void lv_table_set_cell_value_fmt(lv_obj_t *table, uint16_t row, uint16_t col, const char *fmt, ...)
 */
    
/* Reusing lv_label_set_anim_speed for lv_table_set_row_cnt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_set_row_cnt_obj, 2, mp_lv_label_set_anim_speed, lv_table_set_row_cnt);
    
/* Reusing lv_label_set_anim_speed for lv_table_set_col_cnt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_set_col_cnt_obj, 2, mp_lv_label_set_anim_speed, lv_table_set_col_cnt);
    

/*
 * lvgl extension definition for:
 * void lv_table_set_col_width(lv_obj_t *table, uint16_t col_id, lv_coord_t w)
 */
 
STATIC mp_obj_t mp_lv_table_set_col_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *table = mp_to_lv(mp_args[0]);
    uint16_t col_id = (uint16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t w = (int16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint16_t, lv_coord_t))lv_func_ptr)(table, col_id, w);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_set_col_width_obj, 3, mp_lv_table_set_col_width, lv_table_set_col_width);
    

/*
 * lvgl extension definition for:
 * void lv_table_set_cell_align(lv_obj_t *table, uint16_t row, uint16_t col, lv_label_align_t align)
 */
 
STATIC mp_obj_t mp_lv_table_set_cell_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *table = mp_to_lv(mp_args[0]);
    uint16_t row = (uint16_t)mp_obj_get_int(mp_args[1]);
    uint16_t col = (uint16_t)mp_obj_get_int(mp_args[2]);
    lv_label_align_t align = (uint8_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, uint16_t, uint16_t, lv_label_align_t))lv_func_ptr)(table, row, col, align);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_set_cell_align_obj, 4, mp_lv_table_set_cell_align, lv_table_set_cell_align);
    

/*
 * lvgl extension definition for:
 * void lv_table_set_cell_type(lv_obj_t *table, uint16_t row, uint16_t col, uint8_t type)
 */
 
STATIC mp_obj_t mp_lv_table_set_cell_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *table = mp_to_lv(mp_args[0]);
    uint16_t row = (uint16_t)mp_obj_get_int(mp_args[1]);
    uint16_t col = (uint16_t)mp_obj_get_int(mp_args[2]);
    uint8_t type = (uint8_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, uint16_t, uint16_t, uint8_t))lv_func_ptr)(table, row, col, type);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_set_cell_type_obj, 4, mp_lv_table_set_cell_type, lv_table_set_cell_type);
    

/*
 * lvgl extension definition for:
 * void lv_table_set_cell_crop(lv_obj_t *table, uint16_t row, uint16_t col, bool crop)
 */
 
STATIC mp_obj_t mp_lv_table_set_cell_crop(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *table = mp_to_lv(mp_args[0]);
    uint16_t row = (uint16_t)mp_obj_get_int(mp_args[1]);
    uint16_t col = (uint16_t)mp_obj_get_int(mp_args[2]);
    bool crop = mp_obj_is_true(mp_args[3]);
    ((void (*)(lv_obj_t *, uint16_t, uint16_t, bool))lv_func_ptr)(table, row, col, crop);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_set_cell_crop_obj, 4, mp_lv_table_set_cell_crop, lv_table_set_cell_crop);
    
/* Reusing lv_table_set_cell_crop for lv_table_set_cell_merge_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_set_cell_merge_right_obj, 4, mp_lv_table_set_cell_crop, lv_table_set_cell_merge_right);
    

/*
 * lvgl extension definition for:
 * const char *lv_table_get_cell_value(lv_obj_t *table, uint16_t row, uint16_t col)
 */
 
STATIC mp_obj_t mp_lv_table_get_cell_value(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *table = mp_to_lv(mp_args[0]);
    uint16_t row = (uint16_t)mp_obj_get_int(mp_args[1]);
    uint16_t col = (uint16_t)mp_obj_get_int(mp_args[2]);
    const char * _res = ((const char *(*)(lv_obj_t *, uint16_t, uint16_t))lv_func_ptr)(table, row, col);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_get_cell_value_obj, 3, mp_lv_table_get_cell_value, lv_table_get_cell_value);
    
/* Reusing lv_img_get_angle for lv_table_get_row_cnt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_get_row_cnt_obj, 1, mp_lv_img_get_angle, lv_table_get_row_cnt);
    
/* Reusing lv_img_get_angle for lv_table_get_col_cnt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_get_col_cnt_obj, 1, mp_lv_img_get_angle, lv_table_get_col_cnt);
    

/*
 * lvgl extension definition for:
 * lv_coord_t lv_table_get_col_width(lv_obj_t *table, uint16_t col_id)
 */
 
STATIC mp_obj_t mp_lv_table_get_col_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *table = mp_to_lv(mp_args[0]);
    uint16_t col_id = (uint16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t _res = ((lv_coord_t (*)(lv_obj_t *, uint16_t))lv_func_ptr)(table, col_id);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_get_col_width_obj, 2, mp_lv_table_get_col_width, lv_table_get_col_width);
    

/*
 * lvgl extension definition for:
 * lv_label_align_t lv_table_get_cell_align(lv_obj_t *table, uint16_t row, uint16_t col)
 */
 
STATIC mp_obj_t mp_lv_table_get_cell_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *table = mp_to_lv(mp_args[0]);
    uint16_t row = (uint16_t)mp_obj_get_int(mp_args[1]);
    uint16_t col = (uint16_t)mp_obj_get_int(mp_args[2]);
    lv_label_align_t _res = ((lv_label_align_t (*)(lv_obj_t *, uint16_t, uint16_t))lv_func_ptr)(table, row, col);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_get_cell_align_obj, 3, mp_lv_table_get_cell_align, lv_table_get_cell_align);
    
/* Reusing lv_table_get_cell_align for lv_table_get_cell_type */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_get_cell_type_obj, 3, mp_lv_table_get_cell_align, lv_table_get_cell_type);
    
/* Reusing lv_table_get_cell_align for lv_table_get_cell_crop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_get_cell_crop_obj, 3, mp_lv_table_get_cell_align, lv_table_get_cell_crop);
    

/*
 * lvgl extension definition for:
 * bool lv_table_get_cell_merge_right(lv_obj_t *table, uint16_t row, uint16_t col)
 */
 
STATIC mp_obj_t mp_lv_table_get_cell_merge_right(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *table = mp_to_lv(mp_args[0]);
    uint16_t row = (uint16_t)mp_obj_get_int(mp_args[1]);
    uint16_t col = (uint16_t)mp_obj_get_int(mp_args[2]);
    bool _res = ((bool (*)(lv_obj_t *, uint16_t, uint16_t))lv_func_ptr)(table, row, col);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_get_cell_merge_right_obj, 3, mp_lv_table_get_cell_merge_right, lv_table_get_cell_merge_right);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_table_get_pressed_cell(lv_obj_t *table, uint16_t *row, uint16_t *col)
 */
 
STATIC mp_obj_t mp_lv_table_get_pressed_cell(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *table = mp_to_lv(mp_args[0]);
    uint16_t *row = mp_to_ptr(mp_args[1]);
    uint16_t *col = mp_to_ptr(mp_args[2]);
    lv_res_t _res = ((lv_res_t (*)(lv_obj_t *, uint16_t *, uint16_t *))lv_func_ptr)(table, row, col);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_table_get_pressed_cell_obj, 3, mp_lv_table_get_pressed_cell, lv_table_get_pressed_cell);
    

/*
 * lvgl table object definitions
 */
    

STATIC const mp_rom_map_elem_t table_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_cell_value), MP_ROM_PTR(&mp_lv_table_set_cell_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_row_cnt), MP_ROM_PTR(&mp_lv_table_set_row_cnt_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_col_cnt), MP_ROM_PTR(&mp_lv_table_set_col_cnt_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_col_width), MP_ROM_PTR(&mp_lv_table_set_col_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_cell_align), MP_ROM_PTR(&mp_lv_table_set_cell_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_cell_type), MP_ROM_PTR(&mp_lv_table_set_cell_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_cell_crop), MP_ROM_PTR(&mp_lv_table_set_cell_crop_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_cell_merge_right), MP_ROM_PTR(&mp_lv_table_set_cell_merge_right_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_cell_value), MP_ROM_PTR(&mp_lv_table_get_cell_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_row_cnt), MP_ROM_PTR(&mp_lv_table_get_row_cnt_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_col_cnt), MP_ROM_PTR(&mp_lv_table_get_col_cnt_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_col_width), MP_ROM_PTR(&mp_lv_table_get_col_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_cell_align), MP_ROM_PTR(&mp_lv_table_get_cell_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_cell_type), MP_ROM_PTR(&mp_lv_table_get_cell_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_cell_crop), MP_ROM_PTR(&mp_lv_table_get_cell_crop_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_cell_merge_right), MP_ROM_PTR(&mp_lv_table_get_cell_merge_right_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_pressed_cell), MP_ROM_PTR(&mp_lv_table_get_pressed_cell_obj) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_TABLE_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(table_locals_dict, table_locals_dict_table);

STATIC void table_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl table");
}


STATIC mp_obj_t table_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_table_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_table_type = {
    { &mp_type_type },
    .name = MP_QSTR_table,
    .print = table_print,
    .make_new = table_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&table_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_obj_is_visible for lv_checkbox_is_checked */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_checkbox_is_checked_obj, 1, mp_lv_obj_is_visible, lv_checkbox_is_checked);
    
/* Reusing lv_obj_is_visible for lv_checkbox_is_inactive */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_checkbox_is_inactive_obj, 1, mp_lv_obj_is_visible, lv_checkbox_is_inactive);
    
/* Reusing lv_btn_get_state for lv_checkbox_get_state */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_checkbox_get_state_obj, 1, mp_lv_btn_get_state, lv_checkbox_get_state);
    
/* Reusing lv_label_set_text for lv_checkbox_set_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_checkbox_set_text_obj, 2, mp_lv_label_set_text, lv_checkbox_set_text);
    
/* Reusing lv_label_set_text for lv_checkbox_set_text_static */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_checkbox_set_text_static_obj, 2, mp_lv_label_set_text, lv_checkbox_set_text_static);
    
/* Reusing lv_obj_set_auto_realign for lv_checkbox_set_checked */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_checkbox_set_checked_obj, 2, mp_lv_obj_set_auto_realign, lv_checkbox_set_checked);
    
/* Reusing lv_obj_clean for lv_checkbox_set_disabled */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_checkbox_set_disabled_obj, 1, mp_lv_obj_clean, lv_checkbox_set_disabled);
    
/* Reusing lv_btn_set_state for lv_checkbox_set_state */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_checkbox_set_state_obj, 2, mp_lv_btn_set_state, lv_checkbox_set_state);
    
/* Reusing lv_img_get_file_name for lv_checkbox_get_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_checkbox_get_text_obj, 1, mp_lv_img_get_file_name, lv_checkbox_get_text);
    

/*
 * lvgl checkbox object definitions
 */
    

STATIC const mp_rom_map_elem_t checkbox_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_is_checked), MP_ROM_PTR(&mp_lv_checkbox_is_checked_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_inactive), MP_ROM_PTR(&mp_lv_checkbox_is_inactive_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_state), MP_ROM_PTR(&mp_lv_checkbox_get_state_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text), MP_ROM_PTR(&mp_lv_checkbox_set_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_static), MP_ROM_PTR(&mp_lv_checkbox_set_text_static_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_checked), MP_ROM_PTR(&mp_lv_checkbox_set_checked_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_disabled), MP_ROM_PTR(&mp_lv_checkbox_set_disabled_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_state), MP_ROM_PTR(&mp_lv_checkbox_set_state_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_text), MP_ROM_PTR(&mp_lv_checkbox_get_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_CHECKBOX_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(checkbox_locals_dict, checkbox_locals_dict_table);

STATIC void checkbox_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl checkbox");
}


STATIC mp_obj_t checkbox_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_checkbox_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_checkbox_type = {
    { &mp_type_type },
    .name = MP_QSTR_checkbox,
    .print = checkbox_print,
    .make_new = checkbox_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&checkbox_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * void lv_cpicker_set_type(lv_obj_t *cpicker, lv_cpicker_type_t type)
 */
 
STATIC mp_obj_t mp_lv_cpicker_set_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *cpicker = mp_to_lv(mp_args[0]);
    lv_cpicker_type_t type = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_cpicker_type_t))lv_func_ptr)(cpicker, type);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cpicker_set_type_obj, 2, mp_lv_cpicker_set_type, lv_cpicker_set_type);
    

/*
 * lvgl extension definition for:
 * bool lv_cpicker_set_hue(lv_obj_t *cpicker, uint16_t hue)
 */
 
STATIC mp_obj_t mp_lv_cpicker_set_hue(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *cpicker = mp_to_lv(mp_args[0]);
    uint16_t hue = (uint16_t)mp_obj_get_int(mp_args[1]);
    bool _res = ((bool (*)(lv_obj_t *, uint16_t))lv_func_ptr)(cpicker, hue);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cpicker_set_hue_obj, 2, mp_lv_cpicker_set_hue, lv_cpicker_set_hue);
    

/*
 * lvgl extension definition for:
 * bool lv_cpicker_set_saturation(lv_obj_t *cpicker, uint8_t saturation)
 */
 
STATIC mp_obj_t mp_lv_cpicker_set_saturation(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *cpicker = mp_to_lv(mp_args[0]);
    uint8_t saturation = (uint8_t)mp_obj_get_int(mp_args[1]);
    bool _res = ((bool (*)(lv_obj_t *, uint8_t))lv_func_ptr)(cpicker, saturation);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cpicker_set_saturation_obj, 2, mp_lv_cpicker_set_saturation, lv_cpicker_set_saturation);
    
/* Reusing lv_cpicker_set_saturation for lv_cpicker_set_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cpicker_set_value_obj, 2, mp_lv_cpicker_set_saturation, lv_cpicker_set_value);
    

/*
 * Struct lv_color_hsv_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_color_hsv_t_type();

STATIC inline lv_color_hsv_t* mp_write_ptr_lv_color_hsv_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_color_hsv_t_type()));
    return (lv_color_hsv_t*)self->data;
}

#define mp_write_lv_color_hsv_t(struct_obj) *mp_write_ptr_lv_color_hsv_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_color_hsv_t(lv_color_hsv_t *field)
{
    return lv_to_mp_struct(get_mp_lv_color_hsv_t_type(), (void*)field);
}

#define mp_read_lv_color_hsv_t(field) mp_read_ptr_lv_color_hsv_t(copy_buffer(&field, sizeof(lv_color_hsv_t)))
#define mp_read_byref_lv_color_hsv_t(field) mp_read_ptr_lv_color_hsv_t(&field)

STATIC void mp_lv_color_hsv_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_color_hsv_t *data = (lv_color_hsv_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_h: dest[0] = mp_obj_new_int_from_uint(data->h); break; // converting from uint16_t;
            case MP_QSTR_s: dest[0] = mp_obj_new_int_from_uint(data->s); break; // converting from uint8_t;
            case MP_QSTR_v: dest[0] = mp_obj_new_int_from_uint(data->v); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_h: data->h = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_s: data->s = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_v: data->v = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_color_hsv_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_color_hsv_t");
}

STATIC const mp_obj_dict_t mp_lv_color_hsv_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_color_hsv_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_color_hsv_t,
    .print = mp_lv_color_hsv_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_color_hsv_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_color_hsv_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_color_hsv_t_type()
{
    return &mp_lv_color_hsv_t_type;
}
    

/*
 * lvgl extension definition for:
 * bool lv_cpicker_set_hsv(lv_obj_t *cpicker, lv_color_hsv_t hsv)
 */
 
STATIC mp_obj_t mp_lv_cpicker_set_hsv(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *cpicker = mp_to_lv(mp_args[0]);
    lv_color_hsv_t hsv = mp_write_lv_color_hsv_t(mp_args[1]);
    bool _res = ((bool (*)(lv_obj_t *, lv_color_hsv_t))lv_func_ptr)(cpicker, hsv);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cpicker_set_hsv_obj, 2, mp_lv_cpicker_set_hsv, lv_cpicker_set_hsv);
    

/*
 * lvgl extension definition for:
 * bool lv_cpicker_set_color(lv_obj_t *cpicker, lv_color_t color)
 */
 
STATIC mp_obj_t mp_lv_cpicker_set_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *cpicker = mp_to_lv(mp_args[0]);
    lv_color_t color = mp_write_lv_color32_t(mp_args[1]);
    bool _res = ((bool (*)(lv_obj_t *, lv_color_t))lv_func_ptr)(cpicker, color);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cpicker_set_color_obj, 2, mp_lv_cpicker_set_color, lv_cpicker_set_color);
    

/*
 * lvgl extension definition for:
 * void lv_cpicker_set_color_mode(lv_obj_t *cpicker, lv_cpicker_color_mode_t mode)
 */
 
STATIC mp_obj_t mp_lv_cpicker_set_color_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *cpicker = mp_to_lv(mp_args[0]);
    lv_cpicker_color_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_cpicker_color_mode_t))lv_func_ptr)(cpicker, mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cpicker_set_color_mode_obj, 2, mp_lv_cpicker_set_color_mode, lv_cpicker_set_color_mode);
    
/* Reusing lv_obj_set_auto_realign for lv_cpicker_set_color_mode_fixed */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cpicker_set_color_mode_fixed_obj, 2, mp_lv_obj_set_auto_realign, lv_cpicker_set_color_mode_fixed);
    
/* Reusing lv_obj_set_auto_realign for lv_cpicker_set_knob_colored */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cpicker_set_knob_colored_obj, 2, mp_lv_obj_set_auto_realign, lv_cpicker_set_knob_colored);
    

/*
 * lvgl extension definition for:
 * lv_cpicker_color_mode_t lv_cpicker_get_color_mode(lv_obj_t *cpicker)
 */
 
STATIC mp_obj_t mp_lv_cpicker_get_color_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *cpicker = mp_to_lv(mp_args[0]);
    lv_cpicker_color_mode_t _res = ((lv_cpicker_color_mode_t (*)(lv_obj_t *))lv_func_ptr)(cpicker);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cpicker_get_color_mode_obj, 1, mp_lv_cpicker_get_color_mode, lv_cpicker_get_color_mode);
    
/* Reusing lv_img_get_antialias for lv_cpicker_get_color_mode_fixed */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cpicker_get_color_mode_fixed_obj, 1, mp_lv_img_get_antialias, lv_cpicker_get_color_mode_fixed);
    
/* Reusing lv_img_get_angle for lv_cpicker_get_hue */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cpicker_get_hue_obj, 1, mp_lv_img_get_angle, lv_cpicker_get_hue);
    

/*
 * lvgl extension definition for:
 * uint8_t lv_cpicker_get_saturation(lv_obj_t *cpicker)
 */
 
STATIC mp_obj_t mp_lv_cpicker_get_saturation(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *cpicker = mp_to_lv(mp_args[0]);
    uint8_t _res = ((uint8_t (*)(lv_obj_t *))lv_func_ptr)(cpicker);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cpicker_get_saturation_obj, 1, mp_lv_cpicker_get_saturation, lv_cpicker_get_saturation);
    
/* Reusing lv_cpicker_get_saturation for lv_cpicker_get_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cpicker_get_value_obj, 1, mp_lv_cpicker_get_saturation, lv_cpicker_get_value);
    

/*
 * lvgl extension definition for:
 * lv_color_hsv_t lv_cpicker_get_hsv(lv_obj_t *cpicker)
 */
 
STATIC mp_obj_t mp_lv_cpicker_get_hsv(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *cpicker = mp_to_lv(mp_args[0]);
    lv_color_hsv_t _res = ((lv_color_hsv_t (*)(lv_obj_t *))lv_func_ptr)(cpicker);
    return mp_read_lv_color_hsv_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cpicker_get_hsv_obj, 1, mp_lv_cpicker_get_hsv, lv_cpicker_get_hsv);
    

/*
 * lvgl extension definition for:
 * lv_color_t lv_cpicker_get_color(lv_obj_t *cpicker)
 */
 
STATIC mp_obj_t mp_lv_cpicker_get_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *cpicker = mp_to_lv(mp_args[0]);
    lv_color_t _res = ((lv_color_t (*)(lv_obj_t *))lv_func_ptr)(cpicker);
    return mp_read_lv_color32_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cpicker_get_color_obj, 1, mp_lv_cpicker_get_color, lv_cpicker_get_color);
    
/* Reusing lv_img_get_antialias for lv_cpicker_get_knob_colored */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_cpicker_get_knob_colored_obj, 1, mp_lv_img_get_antialias, lv_cpicker_get_knob_colored);
    

/*
 * lvgl cpicker object definitions
 */
    

STATIC const mp_rom_map_elem_t cpicker_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_type), MP_ROM_PTR(&mp_lv_cpicker_set_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_hue), MP_ROM_PTR(&mp_lv_cpicker_set_hue_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_saturation), MP_ROM_PTR(&mp_lv_cpicker_set_saturation_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_value), MP_ROM_PTR(&mp_lv_cpicker_set_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_hsv), MP_ROM_PTR(&mp_lv_cpicker_set_hsv_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_color), MP_ROM_PTR(&mp_lv_cpicker_set_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_color_mode), MP_ROM_PTR(&mp_lv_cpicker_set_color_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_color_mode_fixed), MP_ROM_PTR(&mp_lv_cpicker_set_color_mode_fixed_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_knob_colored), MP_ROM_PTR(&mp_lv_cpicker_set_knob_colored_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_color_mode), MP_ROM_PTR(&mp_lv_cpicker_get_color_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_color_mode_fixed), MP_ROM_PTR(&mp_lv_cpicker_get_color_mode_fixed_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_hue), MP_ROM_PTR(&mp_lv_cpicker_get_hue_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_saturation), MP_ROM_PTR(&mp_lv_cpicker_get_saturation_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_value), MP_ROM_PTR(&mp_lv_cpicker_get_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_hsv), MP_ROM_PTR(&mp_lv_cpicker_get_hsv_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_color), MP_ROM_PTR(&mp_lv_cpicker_get_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_knob_colored), MP_ROM_PTR(&mp_lv_cpicker_get_knob_colored_obj) },
    { MP_ROM_QSTR(MP_QSTR_TYPE), MP_ROM_PTR(&mp_LV_CPICKER_TYPE_type) },
    { MP_ROM_QSTR(MP_QSTR_COLOR_MODE), MP_ROM_PTR(&mp_LV_CPICKER_COLOR_MODE_type) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_CPICKER_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(cpicker_locals_dict, cpicker_locals_dict_table);

STATIC void cpicker_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl cpicker");
}


STATIC mp_obj_t cpicker_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_cpicker_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_cpicker_type = {
    { &mp_type_type },
    .name = MP_QSTR_cpicker,
    .print = cpicker_print,
    .make_new = cpicker_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&cpicker_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * void lv_bar_set_value(lv_obj_t *bar, int16_t value, lv_anim_enable_t anim)
 */
 
STATIC mp_obj_t mp_lv_bar_set_value(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *bar = mp_to_lv(mp_args[0]);
    int16_t value = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_anim_enable_t anim = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, int16_t, lv_anim_enable_t))lv_func_ptr)(bar, value, anim);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_set_value_obj, 3, mp_lv_bar_set_value, lv_bar_set_value);
    
/* Reusing lv_bar_set_value for lv_bar_set_start_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_set_start_value_obj, 3, mp_lv_bar_set_value, lv_bar_set_start_value);
    

/*
 * lvgl extension definition for:
 * void lv_bar_set_range(lv_obj_t *bar, int16_t min, int16_t max)
 */
 
STATIC mp_obj_t mp_lv_bar_set_range(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *bar = mp_to_lv(mp_args[0]);
    int16_t min = (int16_t)mp_obj_get_int(mp_args[1]);
    int16_t max = (int16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, int16_t, int16_t))lv_func_ptr)(bar, min, max);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_set_range_obj, 3, mp_lv_bar_set_range, lv_bar_set_range);
    

/*
 * lvgl extension definition for:
 * void lv_bar_set_type(lv_obj_t *bar, lv_bar_type_t type)
 */
 
STATIC mp_obj_t mp_lv_bar_set_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *bar = mp_to_lv(mp_args[0]);
    lv_bar_type_t type = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_bar_type_t))lv_func_ptr)(bar, type);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_set_type_obj, 2, mp_lv_bar_set_type, lv_bar_set_type);
    
/* Reusing lv_label_set_anim_speed for lv_bar_set_anim_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_set_anim_time_obj, 2, mp_lv_label_set_anim_speed, lv_bar_set_anim_time);
    

/*
 * lvgl extension definition for:
 * int16_t lv_bar_get_value(const lv_obj_t *bar)
 */
 
STATIC mp_obj_t mp_lv_bar_get_value(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *bar = mp_to_lv(mp_args[0]);
    int16_t _res = ((int16_t (*)(const lv_obj_t *))lv_func_ptr)(bar);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_get_value_obj, 1, mp_lv_bar_get_value, lv_bar_get_value);
    
/* Reusing lv_bar_get_value for lv_bar_get_start_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_get_start_value_obj, 1, mp_lv_bar_get_value, lv_bar_get_start_value);
    
/* Reusing lv_bar_get_value for lv_bar_get_min_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_get_min_value_obj, 1, mp_lv_bar_get_value, lv_bar_get_min_value);
    
/* Reusing lv_bar_get_value for lv_bar_get_max_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_get_max_value_obj, 1, mp_lv_bar_get_value, lv_bar_get_max_value);
    

/*
 * lvgl extension definition for:
 * lv_bar_type_t lv_bar_get_type(lv_obj_t *bar)
 */
 
STATIC mp_obj_t mp_lv_bar_get_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *bar = mp_to_lv(mp_args[0]);
    lv_bar_type_t _res = ((lv_bar_type_t (*)(lv_obj_t *))lv_func_ptr)(bar);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_get_type_obj, 1, mp_lv_bar_get_type, lv_bar_get_type);
    
/* Reusing lv_obj_count_children for lv_bar_get_anim_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_bar_get_anim_time_obj, 1, mp_lv_obj_count_children, lv_bar_get_anim_time);
    

/*
 * lvgl bar object definitions
 */
    

STATIC const mp_rom_map_elem_t bar_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_value), MP_ROM_PTR(&mp_lv_bar_set_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_start_value), MP_ROM_PTR(&mp_lv_bar_set_start_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_range), MP_ROM_PTR(&mp_lv_bar_set_range_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_type), MP_ROM_PTR(&mp_lv_bar_set_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_anim_time), MP_ROM_PTR(&mp_lv_bar_set_anim_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_value), MP_ROM_PTR(&mp_lv_bar_get_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_start_value), MP_ROM_PTR(&mp_lv_bar_get_start_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_min_value), MP_ROM_PTR(&mp_lv_bar_get_min_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_max_value), MP_ROM_PTR(&mp_lv_bar_get_max_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_type), MP_ROM_PTR(&mp_lv_bar_get_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_anim_time), MP_ROM_PTR(&mp_lv_bar_get_anim_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_TYPE), MP_ROM_PTR(&mp_LV_BAR_TYPE_type) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_BAR_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(bar_locals_dict, bar_locals_dict_table);

STATIC void bar_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl bar");
}


STATIC mp_obj_t bar_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_bar_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_bar_type = {
    { &mp_type_type },
    .name = MP_QSTR_bar,
    .print = bar_print,
    .make_new = bar_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&bar_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_bar_set_value for lv_slider_set_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_set_value_obj, 3, mp_lv_bar_set_value, lv_slider_set_value);
    
/* Reusing lv_bar_set_value for lv_slider_set_left_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_set_left_value_obj, 3, mp_lv_bar_set_value, lv_slider_set_left_value);
    
/* Reusing lv_bar_set_range for lv_slider_set_range */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_set_range_obj, 3, mp_lv_bar_set_range, lv_slider_set_range);
    
/* Reusing lv_label_set_anim_speed for lv_slider_set_anim_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_set_anim_time_obj, 2, mp_lv_label_set_anim_speed, lv_slider_set_anim_time);
    

/*
 * lvgl extension definition for:
 * inline static void lv_slider_set_type(lv_obj_t *slider, lv_slider_type_t type)
 */
 
STATIC mp_obj_t mp_lv_slider_set_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *slider = mp_to_lv(mp_args[0]);
    lv_slider_type_t type = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_slider_type_t))lv_func_ptr)(slider, type);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_set_type_obj, 2, mp_lv_slider_set_type, lv_slider_set_type);
    
/* Reusing lv_bar_get_value for lv_slider_get_left_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_get_left_value_obj, 1, mp_lv_bar_get_value, lv_slider_get_left_value);
    
/* Reusing lv_bar_get_value for lv_slider_get_min_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_get_min_value_obj, 1, mp_lv_bar_get_value, lv_slider_get_min_value);
    
/* Reusing lv_bar_get_value for lv_slider_get_max_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_get_max_value_obj, 1, mp_lv_bar_get_value, lv_slider_get_max_value);
    
/* Reusing lv_img_get_angle for lv_slider_get_anim_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_get_anim_time_obj, 1, mp_lv_img_get_angle, lv_slider_get_anim_time);
    

/*
 * lvgl extension definition for:
 * inline static lv_slider_type_t lv_slider_get_type(lv_obj_t *slider)
 */
 
STATIC mp_obj_t mp_lv_slider_get_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *slider = mp_to_lv(mp_args[0]);
    lv_slider_type_t _res = ((lv_slider_type_t (*)(lv_obj_t *))lv_func_ptr)(slider);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_get_type_obj, 1, mp_lv_slider_get_type, lv_slider_get_type);
    
/* Reusing lv_bar_get_value for lv_slider_get_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_get_value_obj, 1, mp_lv_bar_get_value, lv_slider_get_value);
    
/* Reusing lv_obj_is_visible for lv_slider_is_dragged */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_slider_is_dragged_obj, 1, mp_lv_obj_is_visible, lv_slider_is_dragged);
    

/*
 * lvgl slider object definitions
 */
    

STATIC const mp_rom_map_elem_t slider_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_value), MP_ROM_PTR(&mp_lv_slider_set_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_left_value), MP_ROM_PTR(&mp_lv_slider_set_left_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_range), MP_ROM_PTR(&mp_lv_slider_set_range_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_anim_time), MP_ROM_PTR(&mp_lv_slider_set_anim_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_type), MP_ROM_PTR(&mp_lv_slider_set_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_left_value), MP_ROM_PTR(&mp_lv_slider_get_left_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_min_value), MP_ROM_PTR(&mp_lv_slider_get_min_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_max_value), MP_ROM_PTR(&mp_lv_slider_get_max_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_anim_time), MP_ROM_PTR(&mp_lv_slider_get_anim_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_type), MP_ROM_PTR(&mp_lv_slider_get_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_value), MP_ROM_PTR(&mp_lv_slider_get_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_dragged), MP_ROM_PTR(&mp_lv_slider_is_dragged_obj) },
    { MP_ROM_QSTR(MP_QSTR_TYPE), MP_ROM_PTR(&mp_LV_SLIDER_TYPE_type) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_SLIDER_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(slider_locals_dict, slider_locals_dict_table);

STATIC void slider_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl slider");
}


STATIC mp_obj_t slider_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_slider_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_slider_type = {
    { &mp_type_type },
    .name = MP_QSTR_slider,
    .print = slider_print,
    .make_new = slider_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&slider_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_obj_clean_style_list for lv_led_set_bright */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_led_set_bright_obj, 2, mp_lv_obj_clean_style_list, lv_led_set_bright);
    
/* Reusing lv_obj_clean for lv_led_on */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_led_on_obj, 1, mp_lv_obj_clean, lv_led_on);
    
/* Reusing lv_obj_clean for lv_led_off */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_led_off_obj, 1, mp_lv_obj_clean, lv_led_off);
    
/* Reusing lv_obj_clean for lv_led_toggle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_led_toggle_obj, 1, mp_lv_obj_clean, lv_led_toggle);
    
/* Reusing lv_obj_get_protect for lv_led_get_bright */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_led_get_bright_obj, 1, mp_lv_obj_get_protect, lv_led_get_bright);
    

/*
 * lvgl led object definitions
 */
    

STATIC const mp_rom_map_elem_t led_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_bright), MP_ROM_PTR(&mp_lv_led_set_bright_obj) },
    { MP_ROM_QSTR(MP_QSTR_on), MP_ROM_PTR(&mp_lv_led_on_obj) },
    { MP_ROM_QSTR(MP_QSTR_off), MP_ROM_PTR(&mp_lv_led_off_obj) },
    { MP_ROM_QSTR(MP_QSTR_toggle), MP_ROM_PTR(&mp_lv_led_toggle_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_bright), MP_ROM_PTR(&mp_lv_led_get_bright_obj) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_LED_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(led_locals_dict, led_locals_dict_table);

STATIC void led_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl led");
}


STATIC mp_obj_t led_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_led_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_led_type = {
    { &mp_type_type },
    .name = MP_QSTR_led,
    .print = led_print,
    .make_new = led_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&led_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * Array convertors for char *[]
 */

STATIC const char * *mp_arr_to_char_ptr____(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    
    char * *lv_arr = (char **)m_malloc(len * sizeof(char *));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (char*)convert_from_str(item);
    }
    return (const char * *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_char_ptr____(const char * *arr)
{
    mp_obj_t obj_arr[1];
    for (size_t i=0; i<1; i++){
        obj_arr[i] = convert_to_str(arr[i]);
    }
    return mp_obj_new_list(1, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * lvgl extension definition for:
 * void lv_btnmatrix_set_map(lv_obj_t *btnm, const char *map[])
 */
 
STATIC mp_obj_t mp_lv_btnmatrix_set_map(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *btnm = mp_to_lv(mp_args[0]);
    const char **map = mp_arr_to_char_ptr____(mp_args[1]);
    ((void (*)(lv_obj_t *, const char *[]))lv_func_ptr)(btnm, map);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_set_map_obj, 2, mp_lv_btnmatrix_set_map, lv_btnmatrix_set_map);
    

/*
 * Array convertors for lv_btnmatrix_ctrl_t []
 */

STATIC const lv_btnmatrix_ctrl_t *mp_arr_to_lv_btnmatrix_ctrl_t_____(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    
    lv_btnmatrix_ctrl_t *lv_arr = (lv_btnmatrix_ctrl_t*)m_malloc(len * sizeof(lv_btnmatrix_ctrl_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = (uint16_t)mp_obj_get_int(item);
    }
    return (const lv_btnmatrix_ctrl_t *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_lv_btnmatrix_ctrl_t_____(const lv_btnmatrix_ctrl_t *arr)
{
    mp_obj_t obj_arr[1];
    for (size_t i=0; i<1; i++){
        obj_arr[i] = mp_obj_new_int_from_uint(arr[i]);
    }
    return mp_obj_new_list(1, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * lvgl extension definition for:
 * void lv_btnmatrix_set_ctrl_map(lv_obj_t *btnm, const lv_btnmatrix_ctrl_t ctrl_map[])
 */
 
STATIC mp_obj_t mp_lv_btnmatrix_set_ctrl_map(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *btnm = mp_to_lv(mp_args[0]);
    const lv_btnmatrix_ctrl_t *ctrl_map = mp_arr_to_lv_btnmatrix_ctrl_t_____(mp_args[1]);
    ((void (*)(lv_obj_t *, const lv_btnmatrix_ctrl_t []))lv_func_ptr)(btnm, ctrl_map);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_set_ctrl_map_obj, 2, mp_lv_btnmatrix_set_ctrl_map, lv_btnmatrix_set_ctrl_map);
    
/* Reusing lv_label_set_anim_speed for lv_btnmatrix_set_focused_btn */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_set_focused_btn_obj, 2, mp_lv_label_set_anim_speed, lv_btnmatrix_set_focused_btn);
    

/*
 * lvgl extension definition for:
 * void lv_btnmatrix_set_recolor(const lv_obj_t *btnm, bool en)
 */
 
STATIC mp_obj_t mp_lv_btnmatrix_set_recolor(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *btnm = mp_to_lv(mp_args[0]);
    bool en = mp_obj_is_true(mp_args[1]);
    ((void (*)(const lv_obj_t *, bool))lv_func_ptr)(btnm, en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_set_recolor_obj, 2, mp_lv_btnmatrix_set_recolor, lv_btnmatrix_set_recolor);
    

/*
 * lvgl extension definition for:
 * void lv_btnmatrix_set_btn_ctrl(lv_obj_t *btnm, uint16_t btn_id, lv_btnmatrix_ctrl_t ctrl)
 */
 
STATIC mp_obj_t mp_lv_btnmatrix_set_btn_ctrl(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *btnm = mp_to_lv(mp_args[0]);
    uint16_t btn_id = (uint16_t)mp_obj_get_int(mp_args[1]);
    lv_btnmatrix_ctrl_t ctrl = (uint16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint16_t, lv_btnmatrix_ctrl_t))lv_func_ptr)(btnm, btn_id, ctrl);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_set_btn_ctrl_obj, 3, mp_lv_btnmatrix_set_btn_ctrl, lv_btnmatrix_set_btn_ctrl);
    

/*
 * lvgl extension definition for:
 * void lv_btnmatrix_clear_btn_ctrl(const lv_obj_t *btnm, uint16_t btn_id, lv_btnmatrix_ctrl_t ctrl)
 */
 
STATIC mp_obj_t mp_lv_btnmatrix_clear_btn_ctrl(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *btnm = mp_to_lv(mp_args[0]);
    uint16_t btn_id = (uint16_t)mp_obj_get_int(mp_args[1]);
    lv_btnmatrix_ctrl_t ctrl = (uint16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(const lv_obj_t *, uint16_t, lv_btnmatrix_ctrl_t))lv_func_ptr)(btnm, btn_id, ctrl);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_clear_btn_ctrl_obj, 3, mp_lv_btnmatrix_clear_btn_ctrl, lv_btnmatrix_clear_btn_ctrl);
    

/*
 * lvgl extension definition for:
 * void lv_btnmatrix_set_btn_ctrl_all(lv_obj_t *btnm, lv_btnmatrix_ctrl_t ctrl)
 */
 
STATIC mp_obj_t mp_lv_btnmatrix_set_btn_ctrl_all(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *btnm = mp_to_lv(mp_args[0]);
    lv_btnmatrix_ctrl_t ctrl = (uint16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_btnmatrix_ctrl_t))lv_func_ptr)(btnm, ctrl);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_set_btn_ctrl_all_obj, 2, mp_lv_btnmatrix_set_btn_ctrl_all, lv_btnmatrix_set_btn_ctrl_all);
    
/* Reusing lv_btnmatrix_set_btn_ctrl_all for lv_btnmatrix_clear_btn_ctrl_all */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_clear_btn_ctrl_all_obj, 2, mp_lv_btnmatrix_set_btn_ctrl_all, lv_btnmatrix_clear_btn_ctrl_all);
    

/*
 * lvgl extension definition for:
 * void lv_btnmatrix_set_btn_width(lv_obj_t *btnm, uint16_t btn_id, uint8_t width)
 */
 
STATIC mp_obj_t mp_lv_btnmatrix_set_btn_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *btnm = mp_to_lv(mp_args[0]);
    uint16_t btn_id = (uint16_t)mp_obj_get_int(mp_args[1]);
    uint8_t width = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint16_t, uint8_t))lv_func_ptr)(btnm, btn_id, width);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_set_btn_width_obj, 3, mp_lv_btnmatrix_set_btn_width, lv_btnmatrix_set_btn_width);
    
/* Reusing lv_obj_set_auto_realign for lv_btnmatrix_set_one_check */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_set_one_check_obj, 2, mp_lv_obj_set_auto_realign, lv_btnmatrix_set_one_check);
    
/* Reusing lv_label_set_align for lv_btnmatrix_set_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_set_align_obj, 2, mp_lv_label_set_align, lv_btnmatrix_set_align);
    

/*
 * lvgl extension definition for:
 * const char **lv_btnmatrix_get_map_array(const lv_obj_t *btnm)
 */
 
STATIC mp_obj_t mp_lv_btnmatrix_get_map_array(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *btnm = mp_to_lv(mp_args[0]);
    const char ** _res = ((const char **(*)(const lv_obj_t *))lv_func_ptr)(btnm);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_get_map_array_obj, 1, mp_lv_btnmatrix_get_map_array, lv_btnmatrix_get_map_array);
    
/* Reusing lv_obj_is_visible for lv_btnmatrix_get_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_get_recolor_obj, 1, mp_lv_obj_is_visible, lv_btnmatrix_get_recolor);
    
/* Reusing lv_obj_count_children for lv_btnmatrix_get_active_btn */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_get_active_btn_obj, 1, mp_lv_obj_count_children, lv_btnmatrix_get_active_btn);
    
/* Reusing lv_img_get_file_name for lv_btnmatrix_get_active_btn_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_get_active_btn_text_obj, 1, mp_lv_img_get_file_name, lv_btnmatrix_get_active_btn_text);
    
/* Reusing lv_obj_count_children for lv_btnmatrix_get_focused_btn */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_get_focused_btn_obj, 1, mp_lv_obj_count_children, lv_btnmatrix_get_focused_btn);
    

/*
 * lvgl extension definition for:
 * const char *lv_btnmatrix_get_btn_text(const lv_obj_t *btnm, uint16_t btn_id)
 */
 
STATIC mp_obj_t mp_lv_btnmatrix_get_btn_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *btnm = mp_to_lv(mp_args[0]);
    uint16_t btn_id = (uint16_t)mp_obj_get_int(mp_args[1]);
    const char * _res = ((const char *(*)(const lv_obj_t *, uint16_t))lv_func_ptr)(btnm, btn_id);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_get_btn_text_obj, 2, mp_lv_btnmatrix_get_btn_text, lv_btnmatrix_get_btn_text);
    

/*
 * lvgl extension definition for:
 * bool lv_btnmatrix_get_btn_ctrl(lv_obj_t *btnm, uint16_t btn_id, lv_btnmatrix_ctrl_t ctrl)
 */
 
STATIC mp_obj_t mp_lv_btnmatrix_get_btn_ctrl(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *btnm = mp_to_lv(mp_args[0]);
    uint16_t btn_id = (uint16_t)mp_obj_get_int(mp_args[1]);
    lv_btnmatrix_ctrl_t ctrl = (uint16_t)mp_obj_get_int(mp_args[2]);
    bool _res = ((bool (*)(lv_obj_t *, uint16_t, lv_btnmatrix_ctrl_t))lv_func_ptr)(btnm, btn_id, ctrl);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_get_btn_ctrl_obj, 3, mp_lv_btnmatrix_get_btn_ctrl, lv_btnmatrix_get_btn_ctrl);
    
/* Reusing lv_obj_is_visible for lv_btnmatrix_get_one_check */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_get_one_check_obj, 1, mp_lv_obj_is_visible, lv_btnmatrix_get_one_check);
    
/* Reusing lv_label_get_align for lv_btnmatrix_get_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_btnmatrix_get_align_obj, 1, mp_lv_label_get_align, lv_btnmatrix_get_align);
    

/*
 * lvgl btnmatrix object definitions
 */
    

STATIC const mp_rom_map_elem_t btnmatrix_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_map), MP_ROM_PTR(&mp_lv_btnmatrix_set_map_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_ctrl_map), MP_ROM_PTR(&mp_lv_btnmatrix_set_ctrl_map_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_focused_btn), MP_ROM_PTR(&mp_lv_btnmatrix_set_focused_btn_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_recolor), MP_ROM_PTR(&mp_lv_btnmatrix_set_recolor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_btn_ctrl), MP_ROM_PTR(&mp_lv_btnmatrix_set_btn_ctrl_obj) },
    { MP_ROM_QSTR(MP_QSTR_clear_btn_ctrl), MP_ROM_PTR(&mp_lv_btnmatrix_clear_btn_ctrl_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_btn_ctrl_all), MP_ROM_PTR(&mp_lv_btnmatrix_set_btn_ctrl_all_obj) },
    { MP_ROM_QSTR(MP_QSTR_clear_btn_ctrl_all), MP_ROM_PTR(&mp_lv_btnmatrix_clear_btn_ctrl_all_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_btn_width), MP_ROM_PTR(&mp_lv_btnmatrix_set_btn_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_one_check), MP_ROM_PTR(&mp_lv_btnmatrix_set_one_check_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_align), MP_ROM_PTR(&mp_lv_btnmatrix_set_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_map_array), MP_ROM_PTR(&mp_lv_btnmatrix_get_map_array_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_recolor), MP_ROM_PTR(&mp_lv_btnmatrix_get_recolor_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_active_btn), MP_ROM_PTR(&mp_lv_btnmatrix_get_active_btn_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_active_btn_text), MP_ROM_PTR(&mp_lv_btnmatrix_get_active_btn_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_focused_btn), MP_ROM_PTR(&mp_lv_btnmatrix_get_focused_btn_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_btn_text), MP_ROM_PTR(&mp_lv_btnmatrix_get_btn_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_btn_ctrl), MP_ROM_PTR(&mp_lv_btnmatrix_get_btn_ctrl_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_one_check), MP_ROM_PTR(&mp_lv_btnmatrix_get_one_check_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_align), MP_ROM_PTR(&mp_lv_btnmatrix_get_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_CTRL), MP_ROM_PTR(&mp_LV_BTNMATRIX_CTRL_type) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_BTNMATRIX_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(btnmatrix_locals_dict, btnmatrix_locals_dict_table);

STATIC void btnmatrix_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl btnmatrix");
}


STATIC mp_obj_t btnmatrix_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_btnmatrix_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_btnmatrix_type = {
    { &mp_type_type },
    .name = MP_QSTR_btnmatrix,
    .print = btnmatrix_print,
    .make_new = btnmatrix_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&btnmatrix_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_btnmatrix_get_map_array for lv_keyboard_get_map_array */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_get_map_array_obj, 1, mp_lv_btnmatrix_get_map_array, lv_keyboard_get_map_array);
    
/* Reusing lv_obj_set_parent for lv_keyboard_set_textarea */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_set_textarea_obj, 2, mp_lv_obj_set_parent, lv_keyboard_set_textarea);
    

/*
 * lvgl extension definition for:
 * void lv_keyboard_set_mode(lv_obj_t *kb, lv_keyboard_mode_t mode)
 */
 
STATIC mp_obj_t mp_lv_keyboard_set_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *kb = mp_to_lv(mp_args[0]);
    lv_keyboard_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_keyboard_mode_t))lv_func_ptr)(kb, mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_set_mode_obj, 2, mp_lv_keyboard_set_mode, lv_keyboard_set_mode);
    
/* Reusing lv_obj_set_auto_realign for lv_keyboard_set_cursor_manage */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_set_cursor_manage_obj, 2, mp_lv_obj_set_auto_realign, lv_keyboard_set_cursor_manage);
    

/*
 * lvgl extension definition for:
 * void lv_keyboard_set_map(lv_obj_t *kb, lv_keyboard_mode_t mode, const char *map[])
 */
 
STATIC mp_obj_t mp_lv_keyboard_set_map(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *kb = mp_to_lv(mp_args[0]);
    lv_keyboard_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    const char **map = mp_arr_to_char_ptr____(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_keyboard_mode_t, const char *[]))lv_func_ptr)(kb, mode, map);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_set_map_obj, 3, mp_lv_keyboard_set_map, lv_keyboard_set_map);
    

/*
 * lvgl extension definition for:
 * void lv_keyboard_set_ctrl_map(lv_obj_t *kb, lv_keyboard_mode_t mode, const lv_btnmatrix_ctrl_t ctrl_map[])
 */
 
STATIC mp_obj_t mp_lv_keyboard_set_ctrl_map(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *kb = mp_to_lv(mp_args[0]);
    lv_keyboard_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[1]);
    const lv_btnmatrix_ctrl_t *ctrl_map = mp_arr_to_lv_btnmatrix_ctrl_t_____(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_keyboard_mode_t, const lv_btnmatrix_ctrl_t []))lv_func_ptr)(kb, mode, ctrl_map);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_set_ctrl_map_obj, 3, mp_lv_keyboard_set_ctrl_map, lv_keyboard_set_ctrl_map);
    
/* Reusing lv_obj_get_screen for lv_keyboard_get_textarea */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_get_textarea_obj, 1, mp_lv_obj_get_screen, lv_keyboard_get_textarea);
    

/*
 * lvgl extension definition for:
 * lv_keyboard_mode_t lv_keyboard_get_mode(const lv_obj_t *kb)
 */
 
STATIC mp_obj_t mp_lv_keyboard_get_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *kb = mp_to_lv(mp_args[0]);
    lv_keyboard_mode_t _res = ((lv_keyboard_mode_t (*)(const lv_obj_t *))lv_func_ptr)(kb);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_get_mode_obj, 1, mp_lv_keyboard_get_mode, lv_keyboard_get_mode);
    
/* Reusing lv_obj_is_visible for lv_keyboard_get_cursor_manage */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_get_cursor_manage_obj, 1, mp_lv_obj_is_visible, lv_keyboard_get_cursor_manage);
    

/*
 * lvgl extension definition for:
 * void lv_keyboard_def_event_cb(lv_obj_t *kb, lv_event_t event)
 */
 
STATIC mp_obj_t mp_lv_keyboard_def_event_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *kb = mp_to_lv(mp_args[0]);
    lv_event_t event = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_event_t))lv_func_ptr)(kb, event);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_keyboard_def_event_cb_obj, 2, mp_lv_keyboard_def_event_cb, lv_keyboard_def_event_cb);
    

/*
 * lvgl keyboard object definitions
 */
    

STATIC const mp_rom_map_elem_t keyboard_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_get_map_array), MP_ROM_PTR(&mp_lv_keyboard_get_map_array_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_textarea), MP_ROM_PTR(&mp_lv_keyboard_set_textarea_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_mode), MP_ROM_PTR(&mp_lv_keyboard_set_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_cursor_manage), MP_ROM_PTR(&mp_lv_keyboard_set_cursor_manage_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_map), MP_ROM_PTR(&mp_lv_keyboard_set_map_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_ctrl_map), MP_ROM_PTR(&mp_lv_keyboard_set_ctrl_map_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_textarea), MP_ROM_PTR(&mp_lv_keyboard_get_textarea_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_mode), MP_ROM_PTR(&mp_lv_keyboard_get_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_cursor_manage), MP_ROM_PTR(&mp_lv_keyboard_get_cursor_manage_obj) },
    { MP_ROM_QSTR(MP_QSTR_def_event_cb), MP_ROM_PTR(&mp_lv_keyboard_def_event_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_MODE), MP_ROM_PTR(&mp_LV_KEYBOARD_MODE_type) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_KEYBOARD_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(keyboard_locals_dict, keyboard_locals_dict_table);

STATIC void keyboard_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl keyboard");
}


STATIC mp_obj_t keyboard_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_keyboard_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_keyboard_type = {
    { &mp_type_type },
    .name = MP_QSTR_keyboard,
    .print = keyboard_print,
    .make_new = keyboard_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&keyboard_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_label_set_text for lv_dropdown_set_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_set_text_obj, 2, mp_lv_label_set_text, lv_dropdown_set_text);
    
/* Reusing lv_obj_clean for lv_dropdown_clear_options */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_clear_options_obj, 1, mp_lv_obj_clean, lv_dropdown_clear_options);
    
/* Reusing lv_label_set_text for lv_dropdown_set_options */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_set_options_obj, 2, mp_lv_label_set_text, lv_dropdown_set_options);
    
/* Reusing lv_label_set_text for lv_dropdown_set_options_static */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_set_options_static_obj, 2, mp_lv_label_set_text, lv_dropdown_set_options_static);
    

/*
 * lvgl extension definition for:
 * void lv_dropdown_add_option(lv_obj_t *ddlist, const char *option, uint32_t pos)
 */
 
STATIC mp_obj_t mp_lv_dropdown_add_option(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *ddlist = mp_to_lv(mp_args[0]);
    const char *option = (char*)convert_from_str(mp_args[1]);
    uint32_t pos = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const char *, uint32_t))lv_func_ptr)(ddlist, option, pos);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_add_option_obj, 3, mp_lv_dropdown_add_option, lv_dropdown_add_option);
    
/* Reusing lv_label_set_anim_speed for lv_dropdown_set_selected */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_set_selected_obj, 2, mp_lv_label_set_anim_speed, lv_dropdown_set_selected);
    

/*
 * lvgl extension definition for:
 * void lv_dropdown_set_dir(lv_obj_t *ddlist, lv_dropdown_dir_t dir)
 */
 
STATIC mp_obj_t mp_lv_dropdown_set_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *ddlist = mp_to_lv(mp_args[0]);
    lv_dropdown_dir_t dir = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_dropdown_dir_t))lv_func_ptr)(ddlist, dir);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_set_dir_obj, 2, mp_lv_dropdown_set_dir, lv_dropdown_set_dir);
    
/* Reusing lv_obj_set_x for lv_dropdown_set_max_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_set_max_height_obj, 2, mp_lv_obj_set_x, lv_dropdown_set_max_height);
    
/* Reusing lv_label_set_text for lv_dropdown_set_symbol */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_set_symbol_obj, 2, mp_lv_label_set_text, lv_dropdown_set_symbol);
    
/* Reusing lv_obj_set_auto_realign for lv_dropdown_set_show_selected */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_set_show_selected_obj, 2, mp_lv_obj_set_auto_realign, lv_dropdown_set_show_selected);
    

/*
 * lvgl extension definition for:
 * const char *lv_dropdown_get_text(lv_obj_t *ddlist)
 */
 
STATIC mp_obj_t mp_lv_dropdown_get_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *ddlist = mp_to_lv(mp_args[0]);
    const char * _res = ((const char *(*)(lv_obj_t *))lv_func_ptr)(ddlist);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_text_obj, 1, mp_lv_dropdown_get_text, lv_dropdown_get_text);
    
/* Reusing lv_img_get_file_name for lv_dropdown_get_options */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_options_obj, 1, mp_lv_img_get_file_name, lv_dropdown_get_options);
    
/* Reusing lv_obj_count_children for lv_dropdown_get_selected */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_selected_obj, 1, mp_lv_obj_count_children, lv_dropdown_get_selected);
    
/* Reusing lv_obj_count_children for lv_dropdown_get_option_cnt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_option_cnt_obj, 1, mp_lv_obj_count_children, lv_dropdown_get_option_cnt);
    

/*
 * lvgl extension definition for:
 * void lv_dropdown_get_selected_str(const lv_obj_t *ddlist, char *buf, uint32_t buf_size)
 */
 
STATIC mp_obj_t mp_lv_dropdown_get_selected_str(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *ddlist = mp_to_lv(mp_args[0]);
    char *buf = (char*)convert_from_str(mp_args[1]);
    uint32_t buf_size = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(const lv_obj_t *, char *, uint32_t))lv_func_ptr)(ddlist, buf, buf_size);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_selected_str_obj, 3, mp_lv_dropdown_get_selected_str, lv_dropdown_get_selected_str);
    
/* Reusing lv_obj_get_x for lv_dropdown_get_max_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_max_height_obj, 1, mp_lv_obj_get_x, lv_dropdown_get_max_height);
    
/* Reusing lv_dropdown_get_text for lv_dropdown_get_symbol */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_symbol_obj, 1, mp_lv_dropdown_get_text, lv_dropdown_get_symbol);
    

/*
 * lvgl extension definition for:
 * lv_dropdown_dir_t lv_dropdown_get_dir(const lv_obj_t *ddlist)
 */
 
STATIC mp_obj_t mp_lv_dropdown_get_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *ddlist = mp_to_lv(mp_args[0]);
    lv_dropdown_dir_t _res = ((lv_dropdown_dir_t (*)(const lv_obj_t *))lv_func_ptr)(ddlist);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_dir_obj, 1, mp_lv_dropdown_get_dir, lv_dropdown_get_dir);
    
/* Reusing lv_img_get_antialias for lv_dropdown_get_show_selected */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_get_show_selected_obj, 1, mp_lv_img_get_antialias, lv_dropdown_get_show_selected);
    
/* Reusing lv_obj_clean for lv_dropdown_open */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_open_obj, 1, mp_lv_obj_clean, lv_dropdown_open);
    
/* Reusing lv_obj_clean for lv_dropdown_close */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_dropdown_close_obj, 1, mp_lv_obj_clean, lv_dropdown_close);
    

/*
 * lvgl dropdown object definitions
 */
    

STATIC const mp_rom_map_elem_t dropdown_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_text), MP_ROM_PTR(&mp_lv_dropdown_set_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_clear_options), MP_ROM_PTR(&mp_lv_dropdown_clear_options_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_options), MP_ROM_PTR(&mp_lv_dropdown_set_options_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_options_static), MP_ROM_PTR(&mp_lv_dropdown_set_options_static_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_option), MP_ROM_PTR(&mp_lv_dropdown_add_option_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_selected), MP_ROM_PTR(&mp_lv_dropdown_set_selected_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_dir), MP_ROM_PTR(&mp_lv_dropdown_set_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_max_height), MP_ROM_PTR(&mp_lv_dropdown_set_max_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_symbol), MP_ROM_PTR(&mp_lv_dropdown_set_symbol_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_show_selected), MP_ROM_PTR(&mp_lv_dropdown_set_show_selected_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_text), MP_ROM_PTR(&mp_lv_dropdown_get_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_options), MP_ROM_PTR(&mp_lv_dropdown_get_options_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_selected), MP_ROM_PTR(&mp_lv_dropdown_get_selected_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_option_cnt), MP_ROM_PTR(&mp_lv_dropdown_get_option_cnt_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_selected_str), MP_ROM_PTR(&mp_lv_dropdown_get_selected_str_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_max_height), MP_ROM_PTR(&mp_lv_dropdown_get_max_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_symbol), MP_ROM_PTR(&mp_lv_dropdown_get_symbol_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_dir), MP_ROM_PTR(&mp_lv_dropdown_get_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_show_selected), MP_ROM_PTR(&mp_lv_dropdown_get_show_selected_obj) },
    { MP_ROM_QSTR(MP_QSTR_open), MP_ROM_PTR(&mp_lv_dropdown_open_obj) },
    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_lv_dropdown_close_obj) },
    { MP_ROM_QSTR(MP_QSTR_DIR), MP_ROM_PTR(&mp_LV_DROPDOWN_DIR_type) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_DROPDOWN_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(dropdown_locals_dict, dropdown_locals_dict_table);

STATIC void dropdown_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl dropdown");
}


STATIC mp_obj_t dropdown_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_dropdown_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_dropdown_type = {
    { &mp_type_type },
    .name = MP_QSTR_dropdown,
    .print = dropdown_print,
    .make_new = dropdown_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&dropdown_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_label_set_anim_speed for lv_roller_set_anim_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_set_anim_time_obj, 2, mp_lv_label_set_anim_speed, lv_roller_set_anim_time);
    
/* Reusing lv_obj_count_children for lv_roller_get_anim_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_get_anim_time_obj, 1, mp_lv_obj_count_children, lv_roller_get_anim_time);
    

/*
 * lvgl extension definition for:
 * void lv_roller_set_options(lv_obj_t *roller, const char *options, lv_roller_mode_t mode)
 */
 
STATIC mp_obj_t mp_lv_roller_set_options(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *roller = mp_to_lv(mp_args[0]);
    const char *options = (char*)convert_from_str(mp_args[1]);
    lv_roller_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const char *, lv_roller_mode_t))lv_func_ptr)(roller, options, mode);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_set_options_obj, 3, mp_lv_roller_set_options, lv_roller_set_options);
    
/* Reusing lv_label_set_align for lv_roller_set_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_set_align_obj, 2, mp_lv_label_set_align, lv_roller_set_align);
    

/*
 * lvgl extension definition for:
 * void lv_roller_set_selected(lv_obj_t *roller, uint16_t sel_opt, lv_anim_enable_t anim)
 */
 
STATIC mp_obj_t mp_lv_roller_set_selected(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *roller = mp_to_lv(mp_args[0]);
    uint16_t sel_opt = (uint16_t)mp_obj_get_int(mp_args[1]);
    lv_anim_enable_t anim = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint16_t, lv_anim_enable_t))lv_func_ptr)(roller, sel_opt, anim);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_set_selected_obj, 3, mp_lv_roller_set_selected, lv_roller_set_selected);
    
/* Reusing lv_obj_clean_style_list for lv_roller_set_visible_row_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_set_visible_row_count_obj, 2, mp_lv_obj_clean_style_list, lv_roller_set_visible_row_count);
    
/* Reusing lv_obj_set_auto_realign for lv_roller_set_auto_fit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_set_auto_fit_obj, 2, mp_lv_obj_set_auto_realign, lv_roller_set_auto_fit);
    
/* Reusing lv_obj_count_children for lv_roller_get_selected */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_get_selected_obj, 1, mp_lv_obj_count_children, lv_roller_get_selected);
    
/* Reusing lv_obj_count_children for lv_roller_get_option_cnt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_get_option_cnt_obj, 1, mp_lv_obj_count_children, lv_roller_get_option_cnt);
    
/* Reusing lv_dropdown_get_selected_str for lv_roller_get_selected_str */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_get_selected_str_obj, 3, mp_lv_dropdown_get_selected_str, lv_roller_get_selected_str);
    
/* Reusing lv_label_get_align for lv_roller_get_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_get_align_obj, 1, mp_lv_label_get_align, lv_roller_get_align);
    
/* Reusing lv_img_get_antialias for lv_roller_get_auto_fit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_get_auto_fit_obj, 1, mp_lv_img_get_antialias, lv_roller_get_auto_fit);
    
/* Reusing lv_img_get_file_name for lv_roller_get_options */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_roller_get_options_obj, 1, mp_lv_img_get_file_name, lv_roller_get_options);
    

/*
 * lvgl roller object definitions
 */
    

STATIC const mp_rom_map_elem_t roller_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_anim_time), MP_ROM_PTR(&mp_lv_roller_set_anim_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_anim_time), MP_ROM_PTR(&mp_lv_roller_get_anim_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_options), MP_ROM_PTR(&mp_lv_roller_set_options_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_align), MP_ROM_PTR(&mp_lv_roller_set_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_selected), MP_ROM_PTR(&mp_lv_roller_set_selected_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_visible_row_count), MP_ROM_PTR(&mp_lv_roller_set_visible_row_count_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_auto_fit), MP_ROM_PTR(&mp_lv_roller_set_auto_fit_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_selected), MP_ROM_PTR(&mp_lv_roller_get_selected_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_option_cnt), MP_ROM_PTR(&mp_lv_roller_get_option_cnt_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_selected_str), MP_ROM_PTR(&mp_lv_roller_get_selected_str_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_align), MP_ROM_PTR(&mp_lv_roller_get_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_auto_fit), MP_ROM_PTR(&mp_lv_roller_get_auto_fit_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_options), MP_ROM_PTR(&mp_lv_roller_get_options_obj) },
    { MP_ROM_QSTR(MP_QSTR_MODE), MP_ROM_PTR(&mp_LV_ROLLER_MODE_type) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_ROLLER_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(roller_locals_dict, roller_locals_dict_table);

STATIC void roller_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl roller");
}


STATIC mp_obj_t roller_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_roller_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_roller_type = {
    { &mp_type_type },
    .name = MP_QSTR_roller,
    .print = roller_print,
    .make_new = roller_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&roller_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_page_set_scrollbar_mode for lv_textarea_set_scrollbar_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_scrollbar_mode_obj, 2, mp_lv_page_set_scrollbar_mode, lv_textarea_set_scrollbar_mode);
    
/* Reusing lv_obj_set_auto_realign for lv_textarea_set_scroll_propagation */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_scroll_propagation_obj, 2, mp_lv_obj_set_auto_realign, lv_textarea_set_scroll_propagation);
    
/* Reusing lv_obj_set_auto_realign for lv_textarea_set_edge_flash */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_edge_flash_obj, 2, mp_lv_obj_set_auto_realign, lv_textarea_set_edge_flash);
    
/* Reusing lv_page_get_scrollbar_mode for lv_textarea_get_scrollbar_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_scrollbar_mode_obj, 1, mp_lv_page_get_scrollbar_mode, lv_textarea_get_scrollbar_mode);
    
/* Reusing lv_img_get_antialias for lv_textarea_get_scroll_propagation */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_scroll_propagation_obj, 1, mp_lv_img_get_antialias, lv_textarea_get_scroll_propagation);
    
/* Reusing lv_img_get_antialias for lv_textarea_get_edge_flash */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_edge_flash_obj, 1, mp_lv_img_get_antialias, lv_textarea_get_edge_flash);
    
/* Reusing lv_label_set_text_sel_start for lv_textarea_add_char */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_add_char_obj, 2, mp_lv_label_set_text_sel_start, lv_textarea_add_char);
    
/* Reusing lv_label_set_text for lv_textarea_add_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_add_text_obj, 2, mp_lv_label_set_text, lv_textarea_add_text);
    
/* Reusing lv_obj_clean for lv_textarea_del_char */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_del_char_obj, 1, mp_lv_obj_clean, lv_textarea_del_char);
    
/* Reusing lv_obj_clean for lv_textarea_del_char_forward */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_del_char_forward_obj, 1, mp_lv_obj_clean, lv_textarea_del_char_forward);
    
/* Reusing lv_label_set_text for lv_textarea_set_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_text_obj, 2, mp_lv_label_set_text, lv_textarea_set_text);
    
/* Reusing lv_label_set_text for lv_textarea_set_placeholder_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_placeholder_text_obj, 2, mp_lv_label_set_text, lv_textarea_set_placeholder_text);
    

/*
 * lvgl extension definition for:
 * void lv_textarea_set_cursor_pos(lv_obj_t *ta, int32_t pos)
 */
 
STATIC mp_obj_t mp_lv_textarea_set_cursor_pos(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *ta = mp_to_lv(mp_args[0]);
    int32_t pos = (int32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, int32_t))lv_func_ptr)(ta, pos);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_cursor_pos_obj, 2, mp_lv_textarea_set_cursor_pos, lv_textarea_set_cursor_pos);
    
/* Reusing lv_obj_set_auto_realign for lv_textarea_set_cursor_hidden */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_cursor_hidden_obj, 2, mp_lv_obj_set_auto_realign, lv_textarea_set_cursor_hidden);
    
/* Reusing lv_obj_set_auto_realign for lv_textarea_set_cursor_click_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_cursor_click_pos_obj, 2, mp_lv_obj_set_auto_realign, lv_textarea_set_cursor_click_pos);
    
/* Reusing lv_obj_set_auto_realign for lv_textarea_set_pwd_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_pwd_mode_obj, 2, mp_lv_obj_set_auto_realign, lv_textarea_set_pwd_mode);
    
/* Reusing lv_obj_set_auto_realign for lv_textarea_set_one_line */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_one_line_obj, 2, mp_lv_obj_set_auto_realign, lv_textarea_set_one_line);
    
/* Reusing lv_label_set_align for lv_textarea_set_text_align */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_text_align_obj, 2, mp_lv_label_set_align, lv_textarea_set_text_align);
    
/* Reusing lv_label_set_text for lv_textarea_set_accepted_chars */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_accepted_chars_obj, 2, mp_lv_label_set_text, lv_textarea_set_accepted_chars);
    
/* Reusing lv_label_set_text_sel_start for lv_textarea_set_max_length */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_max_length_obj, 2, mp_lv_label_set_text_sel_start, lv_textarea_set_max_length);
    
/* Reusing lv_label_set_text for lv_textarea_set_insert_replace */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_insert_replace_obj, 2, mp_lv_label_set_text, lv_textarea_set_insert_replace);
    
/* Reusing lv_obj_set_auto_realign for lv_textarea_set_text_sel */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_text_sel_obj, 2, mp_lv_obj_set_auto_realign, lv_textarea_set_text_sel);
    
/* Reusing lv_label_set_anim_speed for lv_textarea_set_pwd_show_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_pwd_show_time_obj, 2, mp_lv_label_set_anim_speed, lv_textarea_set_pwd_show_time);
    
/* Reusing lv_label_set_anim_speed for lv_textarea_set_cursor_blink_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_set_cursor_blink_time_obj, 2, mp_lv_label_set_anim_speed, lv_textarea_set_cursor_blink_time);
    
/* Reusing lv_img_get_file_name for lv_textarea_get_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_text_obj, 1, mp_lv_img_get_file_name, lv_textarea_get_text);
    
/* Reusing lv_dropdown_get_text for lv_textarea_get_placeholder_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_placeholder_text_obj, 1, mp_lv_dropdown_get_text, lv_textarea_get_placeholder_text);
    
/* Reusing lv_obj_get_screen for lv_textarea_get_label */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_label_obj, 1, mp_lv_obj_get_screen, lv_textarea_get_label);
    
/* Reusing lv_label_get_text_sel_start for lv_textarea_get_cursor_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_cursor_pos_obj, 1, mp_lv_label_get_text_sel_start, lv_textarea_get_cursor_pos);
    
/* Reusing lv_obj_is_visible for lv_textarea_get_cursor_hidden */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_cursor_hidden_obj, 1, mp_lv_obj_is_visible, lv_textarea_get_cursor_hidden);
    
/* Reusing lv_img_get_antialias for lv_textarea_get_cursor_click_pos */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_cursor_click_pos_obj, 1, mp_lv_img_get_antialias, lv_textarea_get_cursor_click_pos);
    
/* Reusing lv_obj_is_visible for lv_textarea_get_pwd_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_pwd_mode_obj, 1, mp_lv_obj_is_visible, lv_textarea_get_pwd_mode);
    
/* Reusing lv_obj_is_visible for lv_textarea_get_one_line */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_one_line_obj, 1, mp_lv_obj_is_visible, lv_textarea_get_one_line);
    
/* Reusing lv_dropdown_get_text for lv_textarea_get_accepted_chars */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_accepted_chars_obj, 1, mp_lv_dropdown_get_text, lv_textarea_get_accepted_chars);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_textarea_get_max_length(lv_obj_t *ta)
 */
 
STATIC mp_obj_t mp_lv_textarea_get_max_length(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *ta = mp_to_lv(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(lv_obj_t *))lv_func_ptr)(ta);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_max_length_obj, 1, mp_lv_textarea_get_max_length, lv_textarea_get_max_length);
    
/* Reusing lv_obj_is_visible for lv_textarea_text_is_selected */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_text_is_selected_obj, 1, mp_lv_obj_is_visible, lv_textarea_text_is_selected);
    
/* Reusing lv_img_get_antialias for lv_textarea_get_text_sel_en */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_text_sel_en_obj, 1, mp_lv_img_get_antialias, lv_textarea_get_text_sel_en);
    
/* Reusing lv_img_get_angle for lv_textarea_get_pwd_show_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_pwd_show_time_obj, 1, mp_lv_img_get_angle, lv_textarea_get_pwd_show_time);
    
/* Reusing lv_img_get_angle for lv_textarea_get_cursor_blink_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_get_cursor_blink_time_obj, 1, mp_lv_img_get_angle, lv_textarea_get_cursor_blink_time);
    
/* Reusing lv_obj_clean for lv_textarea_clear_selection */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_clear_selection_obj, 1, mp_lv_obj_clean, lv_textarea_clear_selection);
    
/* Reusing lv_obj_clean for lv_textarea_cursor_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_cursor_right_obj, 1, mp_lv_obj_clean, lv_textarea_cursor_right);
    
/* Reusing lv_obj_clean for lv_textarea_cursor_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_cursor_left_obj, 1, mp_lv_obj_clean, lv_textarea_cursor_left);
    
/* Reusing lv_obj_clean for lv_textarea_cursor_down */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_cursor_down_obj, 1, mp_lv_obj_clean, lv_textarea_cursor_down);
    
/* Reusing lv_obj_clean for lv_textarea_cursor_up */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_textarea_cursor_up_obj, 1, mp_lv_obj_clean, lv_textarea_cursor_up);
    

/*
 * lvgl textarea object definitions
 */
    

STATIC const mp_rom_map_elem_t textarea_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_scrollbar_mode), MP_ROM_PTR(&mp_lv_textarea_set_scrollbar_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scroll_propagation), MP_ROM_PTR(&mp_lv_textarea_set_scroll_propagation_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_edge_flash), MP_ROM_PTR(&mp_lv_textarea_set_edge_flash_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scrollbar_mode), MP_ROM_PTR(&mp_lv_textarea_get_scrollbar_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scroll_propagation), MP_ROM_PTR(&mp_lv_textarea_get_scroll_propagation_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_edge_flash), MP_ROM_PTR(&mp_lv_textarea_get_edge_flash_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_char), MP_ROM_PTR(&mp_lv_textarea_add_char_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_text), MP_ROM_PTR(&mp_lv_textarea_add_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_del_char), MP_ROM_PTR(&mp_lv_textarea_del_char_obj) },
    { MP_ROM_QSTR(MP_QSTR_del_char_forward), MP_ROM_PTR(&mp_lv_textarea_del_char_forward_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text), MP_ROM_PTR(&mp_lv_textarea_set_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_placeholder_text), MP_ROM_PTR(&mp_lv_textarea_set_placeholder_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_cursor_pos), MP_ROM_PTR(&mp_lv_textarea_set_cursor_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_cursor_hidden), MP_ROM_PTR(&mp_lv_textarea_set_cursor_hidden_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_cursor_click_pos), MP_ROM_PTR(&mp_lv_textarea_set_cursor_click_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pwd_mode), MP_ROM_PTR(&mp_lv_textarea_set_pwd_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_one_line), MP_ROM_PTR(&mp_lv_textarea_set_one_line_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_align), MP_ROM_PTR(&mp_lv_textarea_set_text_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_accepted_chars), MP_ROM_PTR(&mp_lv_textarea_set_accepted_chars_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_max_length), MP_ROM_PTR(&mp_lv_textarea_set_max_length_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_insert_replace), MP_ROM_PTR(&mp_lv_textarea_set_insert_replace_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_sel), MP_ROM_PTR(&mp_lv_textarea_set_text_sel_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pwd_show_time), MP_ROM_PTR(&mp_lv_textarea_set_pwd_show_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_cursor_blink_time), MP_ROM_PTR(&mp_lv_textarea_set_cursor_blink_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_text), MP_ROM_PTR(&mp_lv_textarea_get_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_placeholder_text), MP_ROM_PTR(&mp_lv_textarea_get_placeholder_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_label), MP_ROM_PTR(&mp_lv_textarea_get_label_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_cursor_pos), MP_ROM_PTR(&mp_lv_textarea_get_cursor_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_cursor_hidden), MP_ROM_PTR(&mp_lv_textarea_get_cursor_hidden_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_cursor_click_pos), MP_ROM_PTR(&mp_lv_textarea_get_cursor_click_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_pwd_mode), MP_ROM_PTR(&mp_lv_textarea_get_pwd_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_one_line), MP_ROM_PTR(&mp_lv_textarea_get_one_line_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_accepted_chars), MP_ROM_PTR(&mp_lv_textarea_get_accepted_chars_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_max_length), MP_ROM_PTR(&mp_lv_textarea_get_max_length_obj) },
    { MP_ROM_QSTR(MP_QSTR_text_is_selected), MP_ROM_PTR(&mp_lv_textarea_text_is_selected_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_text_sel_en), MP_ROM_PTR(&mp_lv_textarea_get_text_sel_en_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_pwd_show_time), MP_ROM_PTR(&mp_lv_textarea_get_pwd_show_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_cursor_blink_time), MP_ROM_PTR(&mp_lv_textarea_get_cursor_blink_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_clear_selection), MP_ROM_PTR(&mp_lv_textarea_clear_selection_obj) },
    { MP_ROM_QSTR(MP_QSTR_cursor_right), MP_ROM_PTR(&mp_lv_textarea_cursor_right_obj) },
    { MP_ROM_QSTR(MP_QSTR_cursor_left), MP_ROM_PTR(&mp_lv_textarea_cursor_left_obj) },
    { MP_ROM_QSTR(MP_QSTR_cursor_down), MP_ROM_PTR(&mp_lv_textarea_cursor_down_obj) },
    { MP_ROM_QSTR(MP_QSTR_cursor_up), MP_ROM_PTR(&mp_lv_textarea_cursor_up_obj) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_TEXTAREA_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(textarea_locals_dict, textarea_locals_dict_table);

STATIC void textarea_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl textarea");
}


STATIC mp_obj_t textarea_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_textarea_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_textarea_type = {
    { &mp_type_type },
    .name = MP_QSTR_textarea,
    .print = textarea_print,
    .make_new = textarea_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&textarea_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * void lv_canvas_set_buffer(lv_obj_t *canvas, void *buf, lv_coord_t w, lv_coord_t h, lv_img_cf_t cf)
 */
 
STATIC mp_obj_t mp_lv_canvas_set_buffer(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    void *buf = mp_to_ptr(mp_args[1]);
    lv_coord_t w = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t h = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_img_cf_t cf = (uint8_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(lv_obj_t *, void *, lv_coord_t, lv_coord_t, lv_img_cf_t))lv_func_ptr)(canvas, buf, w, h, cf);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_set_buffer_obj, 5, mp_lv_canvas_set_buffer, lv_canvas_set_buffer);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_set_px(lv_obj_t *canvas, lv_coord_t x, lv_coord_t y, lv_color_t c)
 */
 
STATIC mp_obj_t mp_lv_canvas_set_px(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_color_t c = mp_write_lv_color32_t(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_coord_t, lv_coord_t, lv_color_t))lv_func_ptr)(canvas, x, y, c);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_set_px_obj, 4, mp_lv_canvas_set_px, lv_canvas_set_px);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_set_palette(lv_obj_t *canvas, uint8_t id, lv_color_t c)
 */
 
STATIC mp_obj_t mp_lv_canvas_set_palette(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    uint8_t id = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_color_t c = mp_write_lv_color32_t(mp_args[2]);
    ((void (*)(lv_obj_t *, uint8_t, lv_color_t))lv_func_ptr)(canvas, id, c);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_set_palette_obj, 3, mp_lv_canvas_set_palette, lv_canvas_set_palette);
    

/*
 * lvgl extension definition for:
 * lv_color_t lv_canvas_get_px(lv_obj_t *canvas, lv_coord_t x, lv_coord_t y)
 */
 
STATIC mp_obj_t mp_lv_canvas_get_px(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_color_t _res = ((lv_color_t (*)(lv_obj_t *, lv_coord_t, lv_coord_t))lv_func_ptr)(canvas, x, y);
    return mp_read_lv_color32_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_get_px_obj, 3, mp_lv_canvas_get_px, lv_canvas_get_px);
    

/*
 * lvgl extension definition for:
 * lv_img_dsc_t *lv_canvas_get_img(lv_obj_t *canvas)
 */
 
STATIC mp_obj_t mp_lv_canvas_get_img(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    lv_img_dsc_t * _res = ((lv_img_dsc_t *(*)(lv_obj_t *))lv_func_ptr)(canvas);
    return mp_read_ptr_lv_img_dsc_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_get_img_obj, 1, mp_lv_canvas_get_img, lv_canvas_get_img);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_copy_buf(lv_obj_t *canvas, const void *to_copy, lv_coord_t x, lv_coord_t y, lv_coord_t w, lv_coord_t h)
 */
 
STATIC mp_obj_t mp_lv_canvas_copy_buf(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    const void *to_copy = mp_to_ptr(mp_args[1]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t w = (int16_t)mp_obj_get_int(mp_args[4]);
    lv_coord_t h = (int16_t)mp_obj_get_int(mp_args[5]);
    ((void (*)(lv_obj_t *, const void *, lv_coord_t, lv_coord_t, lv_coord_t, lv_coord_t))lv_func_ptr)(canvas, to_copy, x, y, w, h);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_copy_buf_obj, 6, mp_lv_canvas_copy_buf, lv_canvas_copy_buf);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_transform(lv_obj_t *canvas, lv_img_dsc_t *img, int16_t angle, uint16_t zoom, lv_coord_t offset_x, lv_coord_t offset_y, int32_t pivot_x, int32_t pivot_y, bool antialias)
 */
 
STATIC mp_obj_t mp_lv_canvas_transform(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    lv_img_dsc_t *img = mp_write_ptr_lv_img_dsc_t(mp_args[1]);
    int16_t angle = (int16_t)mp_obj_get_int(mp_args[2]);
    uint16_t zoom = (uint16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t offset_x = (int16_t)mp_obj_get_int(mp_args[4]);
    lv_coord_t offset_y = (int16_t)mp_obj_get_int(mp_args[5]);
    int32_t pivot_x = (int32_t)mp_obj_get_int(mp_args[6]);
    int32_t pivot_y = (int32_t)mp_obj_get_int(mp_args[7]);
    bool antialias = mp_obj_is_true(mp_args[8]);
    ((void (*)(lv_obj_t *, lv_img_dsc_t *, int16_t, uint16_t, lv_coord_t, lv_coord_t, int32_t, int32_t, bool))lv_func_ptr)(canvas, img, angle, zoom, offset_x, offset_y, pivot_x, pivot_y, antialias);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_transform_obj, 9, mp_lv_canvas_transform, lv_canvas_transform);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_blur_hor(lv_obj_t *canvas, const lv_area_t *area, uint16_t r)
 */
 
STATIC mp_obj_t mp_lv_canvas_blur_hor(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    const lv_area_t *area = mp_write_ptr_lv_area_t(mp_args[1]);
    uint16_t r = (uint16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const lv_area_t *, uint16_t))lv_func_ptr)(canvas, area, r);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_blur_hor_obj, 3, mp_lv_canvas_blur_hor, lv_canvas_blur_hor);
    
/* Reusing lv_canvas_blur_hor for lv_canvas_blur_ver */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_blur_ver_obj, 3, mp_lv_canvas_blur_hor, lv_canvas_blur_ver);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_fill_bg(lv_obj_t *canvas, lv_color_t color, lv_opa_t opa)
 */
 
STATIC mp_obj_t mp_lv_canvas_fill_bg(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    lv_color_t color = mp_write_lv_color32_t(mp_args[1]);
    lv_opa_t opa = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_color_t, lv_opa_t))lv_func_ptr)(canvas, color, opa);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_fill_bg_obj, 3, mp_lv_canvas_fill_bg, lv_canvas_fill_bg);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_draw_rect(lv_obj_t *canvas, lv_coord_t x, lv_coord_t y, lv_coord_t w, lv_coord_t h, const lv_draw_rect_dsc_t *rect_dsc)
 */
 
STATIC mp_obj_t mp_lv_canvas_draw_rect(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t w = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t h = (int16_t)mp_obj_get_int(mp_args[4]);
    const lv_draw_rect_dsc_t *rect_dsc = mp_write_ptr_lv_draw_rect_dsc_t(mp_args[5]);
    ((void (*)(lv_obj_t *, lv_coord_t, lv_coord_t, lv_coord_t, lv_coord_t, const lv_draw_rect_dsc_t *))lv_func_ptr)(canvas, x, y, w, h, rect_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_draw_rect_obj, 6, mp_lv_canvas_draw_rect, lv_canvas_draw_rect);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_draw_text(lv_obj_t *canvas, lv_coord_t x, lv_coord_t y, lv_coord_t max_w, lv_draw_label_dsc_t *label_draw_dsc, const char *txt, lv_label_align_t align)
 */
 
STATIC mp_obj_t mp_lv_canvas_draw_text(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t max_w = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_draw_label_dsc_t *label_draw_dsc = mp_write_ptr_lv_draw_label_dsc_t(mp_args[4]);
    const char *txt = (char*)convert_from_str(mp_args[5]);
    lv_label_align_t align = (uint8_t)mp_obj_get_int(mp_args[6]);
    ((void (*)(lv_obj_t *, lv_coord_t, lv_coord_t, lv_coord_t, lv_draw_label_dsc_t *, const char *, lv_label_align_t))lv_func_ptr)(canvas, x, y, max_w, label_draw_dsc, txt, align);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_draw_text_obj, 7, mp_lv_canvas_draw_text, lv_canvas_draw_text);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_draw_img(lv_obj_t *canvas, lv_coord_t x, lv_coord_t y, const void *src, const lv_draw_img_dsc_t *img_draw_dsc)
 */
 
STATIC mp_obj_t mp_lv_canvas_draw_img(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    const void *src = mp_to_ptr(mp_args[3]);
    const lv_draw_img_dsc_t *img_draw_dsc = mp_write_ptr_lv_draw_img_dsc_t(mp_args[4]);
    ((void (*)(lv_obj_t *, lv_coord_t, lv_coord_t, const void *, const lv_draw_img_dsc_t *))lv_func_ptr)(canvas, x, y, src, img_draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_draw_img_obj, 5, mp_lv_canvas_draw_img, lv_canvas_draw_img);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_draw_line(lv_obj_t *canvas, const lv_point_t points[], uint32_t point_cnt, const lv_draw_line_dsc_t *line_draw_dsc)
 */
 
STATIC mp_obj_t mp_lv_canvas_draw_line(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    const lv_point_t *points = mp_arr_to_lv_point_t_____(mp_args[1]);
    uint32_t point_cnt = (uint32_t)mp_obj_get_int(mp_args[2]);
    const lv_draw_line_dsc_t *line_draw_dsc = mp_write_ptr_lv_draw_line_dsc_t(mp_args[3]);
    ((void (*)(lv_obj_t *, const lv_point_t [], uint32_t, const lv_draw_line_dsc_t *))lv_func_ptr)(canvas, points, point_cnt, line_draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_draw_line_obj, 4, mp_lv_canvas_draw_line, lv_canvas_draw_line);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_draw_polygon(lv_obj_t *canvas, const lv_point_t points[], uint32_t point_cnt, const lv_draw_rect_dsc_t *poly_draw_dsc)
 */
 
STATIC mp_obj_t mp_lv_canvas_draw_polygon(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    const lv_point_t *points = mp_arr_to_lv_point_t_____(mp_args[1]);
    uint32_t point_cnt = (uint32_t)mp_obj_get_int(mp_args[2]);
    const lv_draw_rect_dsc_t *poly_draw_dsc = mp_write_ptr_lv_draw_rect_dsc_t(mp_args[3]);
    ((void (*)(lv_obj_t *, const lv_point_t [], uint32_t, const lv_draw_rect_dsc_t *))lv_func_ptr)(canvas, points, point_cnt, poly_draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_draw_polygon_obj, 4, mp_lv_canvas_draw_polygon, lv_canvas_draw_polygon);
    

/*
 * lvgl extension definition for:
 * void lv_canvas_draw_arc(lv_obj_t *canvas, lv_coord_t x, lv_coord_t y, lv_coord_t r, int32_t start_angle, int32_t end_angle, const lv_draw_line_dsc_t *arc_draw_dsc)
 */
 
STATIC mp_obj_t mp_lv_canvas_draw_arc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *canvas = mp_to_lv(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t r = (int16_t)mp_obj_get_int(mp_args[3]);
    int32_t start_angle = (int32_t)mp_obj_get_int(mp_args[4]);
    int32_t end_angle = (int32_t)mp_obj_get_int(mp_args[5]);
    const lv_draw_line_dsc_t *arc_draw_dsc = mp_write_ptr_lv_draw_line_dsc_t(mp_args[6]);
    ((void (*)(lv_obj_t *, lv_coord_t, lv_coord_t, lv_coord_t, int32_t, int32_t, const lv_draw_line_dsc_t *))lv_func_ptr)(canvas, x, y, r, start_angle, end_angle, arc_draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_canvas_draw_arc_obj, 7, mp_lv_canvas_draw_arc, lv_canvas_draw_arc);
    

/*
 * lvgl canvas object definitions
 */
    

STATIC const mp_rom_map_elem_t canvas_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_buffer), MP_ROM_PTR(&mp_lv_canvas_set_buffer_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_px), MP_ROM_PTR(&mp_lv_canvas_set_px_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_palette), MP_ROM_PTR(&mp_lv_canvas_set_palette_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_px), MP_ROM_PTR(&mp_lv_canvas_get_px_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_img), MP_ROM_PTR(&mp_lv_canvas_get_img_obj) },
    { MP_ROM_QSTR(MP_QSTR_copy_buf), MP_ROM_PTR(&mp_lv_canvas_copy_buf_obj) },
    { MP_ROM_QSTR(MP_QSTR_transform), MP_ROM_PTR(&mp_lv_canvas_transform_obj) },
    { MP_ROM_QSTR(MP_QSTR_blur_hor), MP_ROM_PTR(&mp_lv_canvas_blur_hor_obj) },
    { MP_ROM_QSTR(MP_QSTR_blur_ver), MP_ROM_PTR(&mp_lv_canvas_blur_ver_obj) },
    { MP_ROM_QSTR(MP_QSTR_fill_bg), MP_ROM_PTR(&mp_lv_canvas_fill_bg_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_rect), MP_ROM_PTR(&mp_lv_canvas_draw_rect_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_text), MP_ROM_PTR(&mp_lv_canvas_draw_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_img), MP_ROM_PTR(&mp_lv_canvas_draw_img_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_line), MP_ROM_PTR(&mp_lv_canvas_draw_line_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_polygon), MP_ROM_PTR(&mp_lv_canvas_draw_polygon_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_arc), MP_ROM_PTR(&mp_lv_canvas_draw_arc_obj) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_CANVAS_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(canvas_locals_dict, canvas_locals_dict_table);

STATIC void canvas_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl canvas");
}


STATIC mp_obj_t canvas_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_canvas_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_canvas_type = {
    { &mp_type_type },
    .name = MP_QSTR_canvas,
    .print = canvas_print,
    .make_new = canvas_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&canvas_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_obj_is_visible for lv_win_get_drag */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_get_drag_obj, 1, mp_lv_obj_is_visible, lv_win_get_drag);
    
/* Reusing lv_obj_set_x for lv_win_scroll_hor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_scroll_hor_obj, 2, mp_lv_obj_set_x, lv_win_scroll_hor);
    
/* Reusing lv_obj_set_x for lv_win_scroll_ver */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_scroll_ver_obj, 2, mp_lv_obj_set_x, lv_win_scroll_ver);
    
/* Reusing lv_obj_clean for lv_win_clean */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_clean_obj, 1, mp_lv_obj_clean, lv_win_clean);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_win_add_btn_right(lv_obj_t *win, const void *img_src)
 */
 
STATIC mp_obj_t mp_lv_win_add_btn_right(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *win = mp_to_lv(mp_args[0]);
    const void *img_src = mp_to_ptr(mp_args[1]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *, const void *))lv_func_ptr)(win, img_src);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_add_btn_right_obj, 2, mp_lv_win_add_btn_right, lv_win_add_btn_right);
    
/* Reusing lv_win_add_btn_right for lv_win_add_btn_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_add_btn_left_obj, 2, mp_lv_win_add_btn_right, lv_win_add_btn_left);
    
/* Reusing lv_keyboard_def_event_cb for lv_win_close_event_cb */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_close_event_cb_obj, 2, mp_lv_keyboard_def_event_cb, lv_win_close_event_cb);
    
/* Reusing lv_label_set_text for lv_win_set_title */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_set_title_obj, 2, mp_lv_label_set_text, lv_win_set_title);
    
/* Reusing lv_obj_set_x for lv_win_set_header_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_set_header_height_obj, 2, mp_lv_obj_set_x, lv_win_set_header_height);
    
/* Reusing lv_obj_set_x for lv_win_set_btn_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_set_btn_width_obj, 2, mp_lv_obj_set_x, lv_win_set_btn_width);
    
/* Reusing lv_obj_set_pos for lv_win_set_content_size */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_set_content_size_obj, 3, mp_lv_obj_set_pos, lv_win_set_content_size);
    
/* Reusing lv_cont_set_layout for lv_win_set_layout */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_set_layout_obj, 2, mp_lv_cont_set_layout, lv_win_set_layout);
    
/* Reusing lv_page_set_scrollbar_mode for lv_win_set_scrollbar_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_set_scrollbar_mode_obj, 2, mp_lv_page_set_scrollbar_mode, lv_win_set_scrollbar_mode);
    
/* Reusing lv_label_set_anim_speed for lv_win_set_anim_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_set_anim_time_obj, 2, mp_lv_label_set_anim_speed, lv_win_set_anim_time);
    
/* Reusing lv_obj_set_auto_realign for lv_win_set_drag */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_set_drag_obj, 2, mp_lv_obj_set_auto_realign, lv_win_set_drag);
    
/* Reusing lv_obj_clean_style_list for lv_win_title_set_alignment */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_title_set_alignment_obj, 2, mp_lv_obj_clean_style_list, lv_win_title_set_alignment);
    
/* Reusing lv_img_get_file_name for lv_win_get_title */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_get_title_obj, 1, mp_lv_img_get_file_name, lv_win_get_title);
    
/* Reusing lv_obj_get_screen for lv_win_get_content */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_get_content_obj, 1, mp_lv_obj_get_screen, lv_win_get_content);
    
/* Reusing lv_obj_get_x for lv_win_get_header_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_get_header_height_obj, 1, mp_lv_obj_get_x, lv_win_get_header_height);
    
/* Reusing lv_obj_get_height_margin for lv_win_get_btn_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_get_btn_width_obj, 1, mp_lv_obj_get_height_margin, lv_win_get_btn_width);
    
/* Reusing lv_obj_get_screen for lv_win_get_from_btn */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_get_from_btn_obj, 1, mp_lv_obj_get_screen, lv_win_get_from_btn);
    
/* Reusing lv_list_get_layout for lv_win_get_layout */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_get_layout_obj, 1, mp_lv_list_get_layout, lv_win_get_layout);
    

/*
 * lvgl extension definition for:
 * lv_scrollbar_mode_t lv_win_get_sb_mode(lv_obj_t *win)
 */
 
STATIC mp_obj_t mp_lv_win_get_sb_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *win = mp_to_lv(mp_args[0]);
    lv_scrollbar_mode_t _res = ((lv_scrollbar_mode_t (*)(lv_obj_t *))lv_func_ptr)(win);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_get_sb_mode_obj, 1, mp_lv_win_get_sb_mode, lv_win_get_sb_mode);
    
/* Reusing lv_obj_count_children for lv_win_get_anim_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_get_anim_time_obj, 1, mp_lv_obj_count_children, lv_win_get_anim_time);
    
/* Reusing lv_obj_get_height_margin for lv_win_get_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_get_width_obj, 1, mp_lv_obj_get_height_margin, lv_win_get_width);
    
/* Reusing lv_cpicker_get_saturation for lv_win_title_get_alignment */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_title_get_alignment_obj, 1, mp_lv_cpicker_get_saturation, lv_win_title_get_alignment);
    

/*
 * lvgl extension definition for:
 * void lv_win_focus(lv_obj_t *win, lv_obj_t *obj, lv_anim_enable_t anim_en)
 */
 
STATIC mp_obj_t mp_lv_win_focus(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *win = mp_to_lv(mp_args[0]);
    lv_obj_t *obj = mp_to_lv(mp_args[1]);
    lv_anim_enable_t anim_en = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_obj_t *, lv_anim_enable_t))lv_func_ptr)(win, obj, anim_en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_win_focus_obj, 3, mp_lv_win_focus, lv_win_focus);
    

/*
 * lvgl win object definitions
 */
    

STATIC const mp_rom_map_elem_t win_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_get_drag), MP_ROM_PTR(&mp_lv_win_get_drag_obj) },
    { MP_ROM_QSTR(MP_QSTR_scroll_hor), MP_ROM_PTR(&mp_lv_win_scroll_hor_obj) },
    { MP_ROM_QSTR(MP_QSTR_scroll_ver), MP_ROM_PTR(&mp_lv_win_scroll_ver_obj) },
    { MP_ROM_QSTR(MP_QSTR_clean), MP_ROM_PTR(&mp_lv_win_clean_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_btn_right), MP_ROM_PTR(&mp_lv_win_add_btn_right_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_btn_left), MP_ROM_PTR(&mp_lv_win_add_btn_left_obj) },
    { MP_ROM_QSTR(MP_QSTR_close_event_cb), MP_ROM_PTR(&mp_lv_win_close_event_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_title), MP_ROM_PTR(&mp_lv_win_set_title_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_header_height), MP_ROM_PTR(&mp_lv_win_set_header_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_btn_width), MP_ROM_PTR(&mp_lv_win_set_btn_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_content_size), MP_ROM_PTR(&mp_lv_win_set_content_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_layout), MP_ROM_PTR(&mp_lv_win_set_layout_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scrollbar_mode), MP_ROM_PTR(&mp_lv_win_set_scrollbar_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_anim_time), MP_ROM_PTR(&mp_lv_win_set_anim_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_drag), MP_ROM_PTR(&mp_lv_win_set_drag_obj) },
    { MP_ROM_QSTR(MP_QSTR_title_set_alignment), MP_ROM_PTR(&mp_lv_win_title_set_alignment_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_title), MP_ROM_PTR(&mp_lv_win_get_title_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_content), MP_ROM_PTR(&mp_lv_win_get_content_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_header_height), MP_ROM_PTR(&mp_lv_win_get_header_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_btn_width), MP_ROM_PTR(&mp_lv_win_get_btn_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_from_btn), MP_ROM_PTR(&mp_lv_win_get_from_btn_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_layout), MP_ROM_PTR(&mp_lv_win_get_layout_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_sb_mode), MP_ROM_PTR(&mp_lv_win_get_sb_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_anim_time), MP_ROM_PTR(&mp_lv_win_get_anim_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_width), MP_ROM_PTR(&mp_lv_win_get_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_title_get_alignment), MP_ROM_PTR(&mp_lv_win_title_get_alignment_obj) },
    { MP_ROM_QSTR(MP_QSTR_focus), MP_ROM_PTR(&mp_lv_win_focus_obj) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_WIN_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(win_locals_dict, win_locals_dict_table);

STATIC void win_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl win");
}


STATIC mp_obj_t win_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_win_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_win_type = {
    { &mp_type_type },
    .name = MP_QSTR_win,
    .print = win_print,
    .make_new = win_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&win_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_tabview_add_tab(lv_obj_t *tabview, const char *name)
 */
 
STATIC mp_obj_t mp_lv_tabview_add_tab(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *tabview = mp_to_lv(mp_args[0]);
    const char *name = (char*)convert_from_str(mp_args[1]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *, const char *))lv_func_ptr)(tabview, name);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_add_tab_obj, 2, mp_lv_tabview_add_tab, lv_tabview_add_tab);
    
/* Reusing lv_obj_clean for lv_tabview_clean_tab */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_clean_tab_obj, 1, mp_lv_obj_clean, lv_tabview_clean_tab);
    
/* Reusing lv_roller_set_selected for lv_tabview_set_tab_act */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_set_tab_act_obj, 3, mp_lv_roller_set_selected, lv_tabview_set_tab_act);
    

/*
 * lvgl extension definition for:
 * void lv_tabview_set_tab_name(lv_obj_t *tabview, uint16_t id, char *name)
 */
 
STATIC mp_obj_t mp_lv_tabview_set_tab_name(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *tabview = mp_to_lv(mp_args[0]);
    uint16_t id = (uint16_t)mp_obj_get_int(mp_args[1]);
    char *name = (char*)convert_from_str(mp_args[2]);
    ((void (*)(lv_obj_t *, uint16_t, char *))lv_func_ptr)(tabview, id, name);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_set_tab_name_obj, 3, mp_lv_tabview_set_tab_name, lv_tabview_set_tab_name);
    
/* Reusing lv_label_set_anim_speed for lv_tabview_set_anim_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_set_anim_time_obj, 2, mp_lv_label_set_anim_speed, lv_tabview_set_anim_time);
    

/*
 * lvgl extension definition for:
 * void lv_tabview_set_btns_pos(lv_obj_t *tabview, lv_tabview_btns_pos_t btns_pos)
 */
 
STATIC mp_obj_t mp_lv_tabview_set_btns_pos(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *tabview = mp_to_lv(mp_args[0]);
    lv_tabview_btns_pos_t btns_pos = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_tabview_btns_pos_t))lv_func_ptr)(tabview, btns_pos);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_set_btns_pos_obj, 2, mp_lv_tabview_set_btns_pos, lv_tabview_set_btns_pos);
    
/* Reusing lv_obj_count_children for lv_tabview_get_tab_act */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_get_tab_act_obj, 1, mp_lv_obj_count_children, lv_tabview_get_tab_act);
    
/* Reusing lv_obj_count_children for lv_tabview_get_tab_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_get_tab_count_obj, 1, mp_lv_obj_count_children, lv_tabview_get_tab_count);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_tabview_get_tab(const lv_obj_t *tabview, uint16_t id)
 */
 
STATIC mp_obj_t mp_lv_tabview_get_tab(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *tabview = mp_to_lv(mp_args[0]);
    uint16_t id = (uint16_t)mp_obj_get_int(mp_args[1]);
    lv_obj_t * _res = ((lv_obj_t *(*)(const lv_obj_t *, uint16_t))lv_func_ptr)(tabview, id);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_get_tab_obj, 2, mp_lv_tabview_get_tab, lv_tabview_get_tab);
    
/* Reusing lv_obj_count_children for lv_tabview_get_anim_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_get_anim_time_obj, 1, mp_lv_obj_count_children, lv_tabview_get_anim_time);
    

/*
 * lvgl extension definition for:
 * lv_tabview_btns_pos_t lv_tabview_get_btns_pos(const lv_obj_t *tabview)
 */
 
STATIC mp_obj_t mp_lv_tabview_get_btns_pos(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *tabview = mp_to_lv(mp_args[0]);
    lv_tabview_btns_pos_t _res = ((lv_tabview_btns_pos_t (*)(const lv_obj_t *))lv_func_ptr)(tabview);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tabview_get_btns_pos_obj, 1, mp_lv_tabview_get_btns_pos, lv_tabview_get_btns_pos);
    

/*
 * lvgl tabview object definitions
 */
    

STATIC const mp_rom_map_elem_t tabview_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_add_tab), MP_ROM_PTR(&mp_lv_tabview_add_tab_obj) },
    { MP_ROM_QSTR(MP_QSTR_clean_tab), MP_ROM_PTR(&mp_lv_tabview_clean_tab_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_tab_act), MP_ROM_PTR(&mp_lv_tabview_set_tab_act_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_tab_name), MP_ROM_PTR(&mp_lv_tabview_set_tab_name_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_anim_time), MP_ROM_PTR(&mp_lv_tabview_set_anim_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_btns_pos), MP_ROM_PTR(&mp_lv_tabview_set_btns_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_tab_act), MP_ROM_PTR(&mp_lv_tabview_get_tab_act_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_tab_count), MP_ROM_PTR(&mp_lv_tabview_get_tab_count_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_tab), MP_ROM_PTR(&mp_lv_tabview_get_tab_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_anim_time), MP_ROM_PTR(&mp_lv_tabview_get_anim_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_btns_pos), MP_ROM_PTR(&mp_lv_tabview_get_btns_pos_obj) },
    { MP_ROM_QSTR(MP_QSTR_TAB_POS), MP_ROM_PTR(&mp_LV_TABVIEW_TAB_POS_type) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_TABVIEW_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(tabview_locals_dict, tabview_locals_dict_table);

STATIC void tabview_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl tabview");
}


STATIC mp_obj_t tabview_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_tabview_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_tabview_type = {
    { &mp_type_type },
    .name = MP_QSTR_tabview,
    .print = tabview_print,
    .make_new = tabview_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&tabview_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_obj_set_auto_realign for lv_tileview_set_edge_flash */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tileview_set_edge_flash_obj, 2, mp_lv_obj_set_auto_realign, lv_tileview_set_edge_flash);
    
/* Reusing lv_label_set_anim_speed for lv_tileview_set_anim_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tileview_set_anim_time_obj, 2, mp_lv_label_set_anim_speed, lv_tileview_set_anim_time);
    
/* Reusing lv_img_get_antialias for lv_tileview_get_edge_flash */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tileview_get_edge_flash_obj, 1, mp_lv_img_get_antialias, lv_tileview_get_edge_flash);
    
/* Reusing lv_img_get_angle for lv_tileview_get_anim_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tileview_get_anim_time_obj, 1, mp_lv_img_get_angle, lv_tileview_get_anim_time);
    
/* Reusing lv_obj_set_parent for lv_tileview_add_element */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tileview_add_element_obj, 2, mp_lv_obj_set_parent, lv_tileview_add_element);
    
/* Reusing lv_line_set_points for lv_tileview_set_valid_positions */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tileview_set_valid_positions_obj, 3, mp_lv_line_set_points, lv_tileview_set_valid_positions);
    

/*
 * lvgl extension definition for:
 * void lv_tileview_set_tile_act(lv_obj_t *tileview, lv_coord_t x, lv_coord_t y, lv_anim_enable_t anim)
 */
 
STATIC mp_obj_t mp_lv_tileview_set_tile_act(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *tileview = mp_to_lv(mp_args[0]);
    lv_coord_t x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_anim_enable_t anim = (uint8_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, lv_coord_t, lv_coord_t, lv_anim_enable_t))lv_func_ptr)(tileview, x, y, anim);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tileview_set_tile_act_obj, 4, mp_lv_tileview_set_tile_act, lv_tileview_set_tile_act);
    

/*
 * lvgl extension definition for:
 * void lv_tileview_get_tile_act(lv_obj_t *tileview, lv_coord_t *x, lv_coord_t *y)
 */
 
STATIC mp_obj_t mp_lv_tileview_get_tile_act(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *tileview = mp_to_lv(mp_args[0]);
    lv_coord_t *x = mp_to_ptr(mp_args[1]);
    lv_coord_t *y = mp_to_ptr(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_coord_t *, lv_coord_t *))lv_func_ptr)(tileview, x, y);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_tileview_get_tile_act_obj, 3, mp_lv_tileview_get_tile_act, lv_tileview_get_tile_act);
    

/*
 * lvgl tileview object definitions
 */
    

STATIC const mp_rom_map_elem_t tileview_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_edge_flash), MP_ROM_PTR(&mp_lv_tileview_set_edge_flash_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_anim_time), MP_ROM_PTR(&mp_lv_tileview_set_anim_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_edge_flash), MP_ROM_PTR(&mp_lv_tileview_get_edge_flash_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_anim_time), MP_ROM_PTR(&mp_lv_tileview_get_anim_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_element), MP_ROM_PTR(&mp_lv_tileview_add_element_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_valid_positions), MP_ROM_PTR(&mp_lv_tileview_set_valid_positions_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_tile_act), MP_ROM_PTR(&mp_lv_tileview_set_tile_act_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_tile_act), MP_ROM_PTR(&mp_lv_tileview_get_tile_act_obj) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_TILEVIEW_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(tileview_locals_dict, tileview_locals_dict_table);

STATIC void tileview_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl tileview");
}


STATIC mp_obj_t tileview_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_tileview_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_tileview_type = {
    { &mp_type_type },
    .name = MP_QSTR_tileview,
    .print = tileview_print,
    .make_new = tileview_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&tileview_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_btnmatrix_set_map for lv_msgbox_add_btns */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_add_btns_obj, 2, mp_lv_btnmatrix_set_map, lv_msgbox_add_btns);
    
/* Reusing lv_label_set_text for lv_msgbox_set_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_set_text_obj, 2, mp_lv_label_set_text, lv_msgbox_set_text);
    

/*
 * Function NOT generated:
 * Cannot convert ellipsis param
 * void lv_msgbox_set_text_fmt(lv_obj_t *mbox, const char *fmt, ...)
 */
    
/* Reusing lv_label_set_anim_speed for lv_msgbox_set_anim_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_set_anim_time_obj, 2, mp_lv_label_set_anim_speed, lv_msgbox_set_anim_time);
    
/* Reusing lv_label_set_anim_speed for lv_msgbox_start_auto_close */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_start_auto_close_obj, 2, mp_lv_label_set_anim_speed, lv_msgbox_start_auto_close);
    
/* Reusing lv_obj_clean for lv_msgbox_stop_auto_close */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_stop_auto_close_obj, 1, mp_lv_obj_clean, lv_msgbox_stop_auto_close);
    
/* Reusing lv_obj_set_auto_realign for lv_msgbox_set_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_set_recolor_obj, 2, mp_lv_obj_set_auto_realign, lv_msgbox_set_recolor);
    
/* Reusing lv_img_get_file_name for lv_msgbox_get_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_get_text_obj, 1, mp_lv_img_get_file_name, lv_msgbox_get_text);
    
/* Reusing lv_img_get_angle for lv_msgbox_get_active_btn */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_get_active_btn_obj, 1, mp_lv_img_get_angle, lv_msgbox_get_active_btn);
    
/* Reusing lv_dropdown_get_text for lv_msgbox_get_active_btn_text */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_get_active_btn_text_obj, 1, mp_lv_dropdown_get_text, lv_msgbox_get_active_btn_text);
    
/* Reusing lv_obj_count_children for lv_msgbox_get_anim_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_get_anim_time_obj, 1, mp_lv_obj_count_children, lv_msgbox_get_anim_time);
    
/* Reusing lv_obj_is_visible for lv_msgbox_get_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_get_recolor_obj, 1, mp_lv_obj_is_visible, lv_msgbox_get_recolor);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_msgbox_get_btnmatrix(lv_obj_t *mbox)
 */
 
STATIC mp_obj_t mp_lv_msgbox_get_btnmatrix(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *mbox = mp_to_lv(mp_args[0]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *))lv_func_ptr)(mbox);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_msgbox_get_btnmatrix_obj, 1, mp_lv_msgbox_get_btnmatrix, lv_msgbox_get_btnmatrix);
    

/*
 * lvgl msgbox object definitions
 */
    

STATIC const mp_rom_map_elem_t msgbox_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_add_btns), MP_ROM_PTR(&mp_lv_msgbox_add_btns_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text), MP_ROM_PTR(&mp_lv_msgbox_set_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_anim_time), MP_ROM_PTR(&mp_lv_msgbox_set_anim_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_start_auto_close), MP_ROM_PTR(&mp_lv_msgbox_start_auto_close_obj) },
    { MP_ROM_QSTR(MP_QSTR_stop_auto_close), MP_ROM_PTR(&mp_lv_msgbox_stop_auto_close_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_recolor), MP_ROM_PTR(&mp_lv_msgbox_set_recolor_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_text), MP_ROM_PTR(&mp_lv_msgbox_get_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_active_btn), MP_ROM_PTR(&mp_lv_msgbox_get_active_btn_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_active_btn_text), MP_ROM_PTR(&mp_lv_msgbox_get_active_btn_text_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_anim_time), MP_ROM_PTR(&mp_lv_msgbox_get_anim_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_recolor), MP_ROM_PTR(&mp_lv_msgbox_get_recolor_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_btnmatrix), MP_ROM_PTR(&mp_lv_msgbox_get_btnmatrix_obj) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_MSGBOX_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(msgbox_locals_dict, msgbox_locals_dict_table);

STATIC void msgbox_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl msgbox");
}


STATIC mp_obj_t msgbox_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_msgbox_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_msgbox_type = {
    { &mp_type_type },
    .name = MP_QSTR_msgbox,
    .print = msgbox_print,
    .make_new = msgbox_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&msgbox_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * Struct lv_objmask_mask_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_objmask_mask_t_type();

STATIC inline lv_objmask_mask_t* mp_write_ptr_lv_objmask_mask_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_objmask_mask_t_type()));
    return (lv_objmask_mask_t*)self->data;
}

#define mp_write_lv_objmask_mask_t(struct_obj) *mp_write_ptr_lv_objmask_mask_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_objmask_mask_t(lv_objmask_mask_t *field)
{
    return lv_to_mp_struct(get_mp_lv_objmask_mask_t_type(), (void*)field);
}

#define mp_read_lv_objmask_mask_t(field) mp_read_ptr_lv_objmask_mask_t(copy_buffer(&field, sizeof(lv_objmask_mask_t)))
#define mp_read_byref_lv_objmask_mask_t(field) mp_read_ptr_lv_objmask_mask_t(&field)

STATIC void mp_lv_objmask_mask_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_objmask_mask_t *data = (lv_objmask_mask_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_param: dest[0] = ptr_to_mp((void*)data->param); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_param: data->param = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_objmask_mask_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_objmask_mask_t");
}

STATIC const mp_obj_dict_t mp_lv_objmask_mask_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_objmask_mask_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_objmask_mask_t,
    .print = mp_lv_objmask_mask_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_objmask_mask_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_objmask_mask_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_objmask_mask_t_type()
{
    return &mp_lv_objmask_mask_t_type;
}
    

/*
 * lvgl extension definition for:
 * lv_objmask_mask_t *lv_objmask_add_mask(lv_obj_t *objmask, void *param)
 */
 
STATIC mp_obj_t mp_lv_objmask_add_mask(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *objmask = mp_to_lv(mp_args[0]);
    void *param = mp_to_ptr(mp_args[1]);
    lv_objmask_mask_t * _res = ((lv_objmask_mask_t *(*)(lv_obj_t *, void *))lv_func_ptr)(objmask, param);
    return mp_read_ptr_lv_objmask_mask_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_objmask_add_mask_obj, 2, mp_lv_objmask_add_mask, lv_objmask_add_mask);
    

/*
 * lvgl extension definition for:
 * void lv_objmask_update_mask(lv_obj_t *objmask, lv_objmask_mask_t *mask, void *param)
 */
 
STATIC mp_obj_t mp_lv_objmask_update_mask(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *objmask = mp_to_lv(mp_args[0]);
    lv_objmask_mask_t *mask = mp_write_ptr_lv_objmask_mask_t(mp_args[1]);
    void *param = mp_to_ptr(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_objmask_mask_t *, void *))lv_func_ptr)(objmask, mask, param);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_objmask_update_mask_obj, 3, mp_lv_objmask_update_mask, lv_objmask_update_mask);
    

/*
 * lvgl extension definition for:
 * void lv_objmask_remove_mask(lv_obj_t *objmask, lv_objmask_mask_t *mask)
 */
 
STATIC mp_obj_t mp_lv_objmask_remove_mask(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *objmask = mp_to_lv(mp_args[0]);
    lv_objmask_mask_t *mask = mp_write_ptr_lv_objmask_mask_t(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_objmask_mask_t *))lv_func_ptr)(objmask, mask);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_objmask_remove_mask_obj, 2, mp_lv_objmask_remove_mask, lv_objmask_remove_mask);
    

/*
 * lvgl objmask object definitions
 */
    

STATIC const mp_rom_map_elem_t objmask_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_add_mask), MP_ROM_PTR(&mp_lv_objmask_add_mask_obj) },
    { MP_ROM_QSTR(MP_QSTR_update_mask), MP_ROM_PTR(&mp_lv_objmask_update_mask_obj) },
    { MP_ROM_QSTR(MP_QSTR_remove_mask), MP_ROM_PTR(&mp_lv_objmask_remove_mask_obj) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_OBJMASK_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(objmask_locals_dict, objmask_locals_dict_table);

STATIC void objmask_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl objmask");
}


STATIC mp_obj_t objmask_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_objmask_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_objmask_type = {
    { &mp_type_type },
    .name = MP_QSTR_objmask,
    .print = objmask_print,
    .make_new = objmask_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&objmask_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_textarea_set_cursor_pos for lv_linemeter_set_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_linemeter_set_value_obj, 2, mp_lv_textarea_set_cursor_pos, lv_linemeter_set_value);
    

/*
 * lvgl extension definition for:
 * void lv_linemeter_set_range(lv_obj_t *lmeter, int32_t min, int32_t max)
 */
 
STATIC mp_obj_t mp_lv_linemeter_set_range(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *lmeter = mp_to_lv(mp_args[0]);
    int32_t min = (int32_t)mp_obj_get_int(mp_args[1]);
    int32_t max = (int32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, int32_t, int32_t))lv_func_ptr)(lmeter, min, max);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_linemeter_set_range_obj, 3, mp_lv_linemeter_set_range, lv_linemeter_set_range);
    

/*
 * lvgl extension definition for:
 * void lv_linemeter_set_scale(lv_obj_t *lmeter, uint16_t angle, uint16_t line_cnt)
 */
 
STATIC mp_obj_t mp_lv_linemeter_set_scale(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *lmeter = mp_to_lv(mp_args[0]);
    uint16_t angle = (uint16_t)mp_obj_get_int(mp_args[1]);
    uint16_t line_cnt = (uint16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint16_t, uint16_t))lv_func_ptr)(lmeter, angle, line_cnt);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_linemeter_set_scale_obj, 3, mp_lv_linemeter_set_scale, lv_linemeter_set_scale);
    
/* Reusing lv_label_set_anim_speed for lv_linemeter_set_angle_offset */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_linemeter_set_angle_offset_obj, 2, mp_lv_label_set_anim_speed, lv_linemeter_set_angle_offset);
    
/* Reusing lv_obj_set_auto_realign for lv_linemeter_set_mirror */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_linemeter_set_mirror_obj, 2, mp_lv_obj_set_auto_realign, lv_linemeter_set_mirror);
    

/*
 * lvgl extension definition for:
 * int32_t lv_linemeter_get_value(const lv_obj_t *lmeter)
 */
 
STATIC mp_obj_t mp_lv_linemeter_get_value(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *lmeter = mp_to_lv(mp_args[0]);
    int32_t _res = ((int32_t (*)(const lv_obj_t *))lv_func_ptr)(lmeter);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_linemeter_get_value_obj, 1, mp_lv_linemeter_get_value, lv_linemeter_get_value);
    
/* Reusing lv_linemeter_get_value for lv_linemeter_get_min_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_linemeter_get_min_value_obj, 1, mp_lv_linemeter_get_value, lv_linemeter_get_min_value);
    
/* Reusing lv_linemeter_get_value for lv_linemeter_get_max_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_linemeter_get_max_value_obj, 1, mp_lv_linemeter_get_value, lv_linemeter_get_max_value);
    
/* Reusing lv_obj_count_children for lv_linemeter_get_line_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_linemeter_get_line_count_obj, 1, mp_lv_obj_count_children, lv_linemeter_get_line_count);
    
/* Reusing lv_obj_count_children for lv_linemeter_get_scale_angle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_linemeter_get_scale_angle_obj, 1, mp_lv_obj_count_children, lv_linemeter_get_scale_angle);
    
/* Reusing lv_img_get_angle for lv_linemeter_get_angle_offset */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_linemeter_get_angle_offset_obj, 1, mp_lv_img_get_angle, lv_linemeter_get_angle_offset);
    

/*
 * lvgl extension definition for:
 * void lv_linemeter_draw_scale(lv_obj_t *lmeter, const lv_area_t *clip_area, uint8_t part)
 */
 
STATIC mp_obj_t mp_lv_linemeter_draw_scale(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *lmeter = mp_to_lv(mp_args[0]);
    const lv_area_t *clip_area = mp_write_ptr_lv_area_t(mp_args[1]);
    uint8_t part = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, const lv_area_t *, uint8_t))lv_func_ptr)(lmeter, clip_area, part);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_linemeter_draw_scale_obj, 3, mp_lv_linemeter_draw_scale, lv_linemeter_draw_scale);
    
/* Reusing lv_img_get_antialias for lv_linemeter_get_mirror */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_linemeter_get_mirror_obj, 1, mp_lv_img_get_antialias, lv_linemeter_get_mirror);
    

/*
 * lvgl linemeter object definitions
 */
    

STATIC const mp_rom_map_elem_t linemeter_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_value), MP_ROM_PTR(&mp_lv_linemeter_set_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_range), MP_ROM_PTR(&mp_lv_linemeter_set_range_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scale), MP_ROM_PTR(&mp_lv_linemeter_set_scale_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_angle_offset), MP_ROM_PTR(&mp_lv_linemeter_set_angle_offset_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_mirror), MP_ROM_PTR(&mp_lv_linemeter_set_mirror_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_value), MP_ROM_PTR(&mp_lv_linemeter_get_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_min_value), MP_ROM_PTR(&mp_lv_linemeter_get_min_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_max_value), MP_ROM_PTR(&mp_lv_linemeter_get_max_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_line_count), MP_ROM_PTR(&mp_lv_linemeter_get_line_count_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scale_angle), MP_ROM_PTR(&mp_lv_linemeter_get_scale_angle_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_angle_offset), MP_ROM_PTR(&mp_lv_linemeter_get_angle_offset_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_scale), MP_ROM_PTR(&mp_lv_linemeter_draw_scale_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_mirror), MP_ROM_PTR(&mp_lv_linemeter_get_mirror_obj) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_LINEMETER_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(linemeter_locals_dict, linemeter_locals_dict_table);

STATIC void linemeter_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl linemeter");
}


STATIC mp_obj_t linemeter_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_linemeter_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_linemeter_type = {
    { &mp_type_type },
    .name = MP_QSTR_linemeter,
    .print = linemeter_print,
    .make_new = linemeter_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&linemeter_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_linemeter_set_range for lv_gauge_set_range */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gauge_set_range_obj, 3, mp_lv_linemeter_set_range, lv_gauge_set_range);
    
/* Reusing lv_textarea_set_cursor_pos for lv_gauge_set_critical_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gauge_set_critical_value_obj, 2, mp_lv_textarea_set_cursor_pos, lv_gauge_set_critical_value);
    
/* Reusing lv_label_set_anim_speed for lv_gauge_set_angle_offset */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gauge_set_angle_offset_obj, 2, mp_lv_label_set_anim_speed, lv_gauge_set_angle_offset);
    
/* Reusing lv_linemeter_get_value for lv_gauge_get_min_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gauge_get_min_value_obj, 1, mp_lv_linemeter_get_value, lv_gauge_get_min_value);
    
/* Reusing lv_linemeter_get_value for lv_gauge_get_max_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gauge_get_max_value_obj, 1, mp_lv_linemeter_get_value, lv_gauge_get_max_value);
    
/* Reusing lv_linemeter_get_value for lv_gauge_get_critical_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gauge_get_critical_value_obj, 1, mp_lv_linemeter_get_value, lv_gauge_get_critical_value);
    
/* Reusing lv_obj_count_children for lv_gauge_get_line_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gauge_get_line_count_obj, 1, mp_lv_obj_count_children, lv_gauge_get_line_count);
    
/* Reusing lv_obj_count_children for lv_gauge_get_scale_angle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gauge_get_scale_angle_obj, 1, mp_lv_obj_count_children, lv_gauge_get_scale_angle);
    
/* Reusing lv_img_get_angle for lv_gauge_get_angle_offset */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gauge_get_angle_offset_obj, 1, mp_lv_img_get_angle, lv_gauge_get_angle_offset);
    

/*
 * Array convertors for lv_color_t []
 */

STATIC const lv_color_t *mp_arr_to_lv_color_t_____(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    
    lv_color_t *lv_arr = (lv_color_t*)m_malloc(len * sizeof(lv_color_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = mp_write_lv_color32_t(item);
    }
    return (const lv_color_t *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_lv_color_t_____(const lv_color_t *arr)
{
    mp_obj_t obj_arr[1];
    for (size_t i=0; i<1; i++){
        obj_arr[i] = mp_read_lv_color32_t(arr[i]);
    }
    return mp_obj_new_list(1, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * lvgl extension definition for:
 * void lv_gauge_set_needle_count(lv_obj_t *gauge, uint8_t needle_cnt, const lv_color_t colors[])
 */
 
STATIC mp_obj_t mp_lv_gauge_set_needle_count(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *gauge = mp_to_lv(mp_args[0]);
    uint8_t needle_cnt = (uint8_t)mp_obj_get_int(mp_args[1]);
    const lv_color_t *colors = mp_arr_to_lv_color_t_____(mp_args[2]);
    ((void (*)(lv_obj_t *, uint8_t, const lv_color_t []))lv_func_ptr)(gauge, needle_cnt, colors);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gauge_set_needle_count_obj, 3, mp_lv_gauge_set_needle_count, lv_gauge_set_needle_count);
    

/*
 * lvgl extension definition for:
 * void lv_gauge_set_value(lv_obj_t *gauge, uint8_t needle_id, int32_t value)
 */
 
STATIC mp_obj_t mp_lv_gauge_set_value(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *gauge = mp_to_lv(mp_args[0]);
    uint8_t needle_id = (uint8_t)mp_obj_get_int(mp_args[1]);
    int32_t value = (int32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, uint8_t, int32_t))lv_func_ptr)(gauge, needle_id, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gauge_set_value_obj, 3, mp_lv_gauge_set_value, lv_gauge_set_value);
    

/*
 * lvgl extension definition for:
 * void lv_gauge_set_scale(lv_obj_t *gauge, uint16_t angle, uint8_t line_cnt, uint8_t label_cnt)
 */
 
STATIC mp_obj_t mp_lv_gauge_set_scale(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *gauge = mp_to_lv(mp_args[0]);
    uint16_t angle = (uint16_t)mp_obj_get_int(mp_args[1]);
    uint8_t line_cnt = (uint8_t)mp_obj_get_int(mp_args[2]);
    uint8_t label_cnt = (uint8_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, uint16_t, uint8_t, uint8_t))lv_func_ptr)(gauge, angle, line_cnt, label_cnt);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gauge_set_scale_obj, 4, mp_lv_gauge_set_scale, lv_gauge_set_scale);
    

/*
 * lvgl extension definition for:
 * void lv_gauge_set_needle_img(lv_obj_t *gauge, const void *img, lv_coord_t pivot_x, lv_coord_t pivot_y)
 */
 
STATIC mp_obj_t mp_lv_gauge_set_needle_img(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *gauge = mp_to_lv(mp_args[0]);
    const void *img = mp_to_ptr(mp_args[1]);
    lv_coord_t pivot_x = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t pivot_y = (int16_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_obj_t *, const void *, lv_coord_t, lv_coord_t))lv_func_ptr)(gauge, img, pivot_x, pivot_y);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gauge_set_needle_img_obj, 4, mp_lv_gauge_set_needle_img, lv_gauge_set_needle_img);
    

/*
 * Callback function lv_obj_t_format_cb
 * void lv_gauge_format_cb_t(lv_obj_t *gauge, char *buf, int bufsize, int32_t value)
 */

STATIC void lv_obj_t_format_cb_callback(lv_obj_t * arg0, char * arg1, int arg2, int32_t arg3)
{
    mp_obj_t mp_args[4];
    mp_args[0] = lv_to_mp((void*)arg0);
    mp_args[1] = convert_to_str((void*)arg1);
    mp_args[2] = mp_obj_new_int(arg2);
    mp_args[3] = mp_obj_new_int(arg3);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_obj_t_format_cb)) , 4, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * void lv_gauge_set_formatter_cb(lv_obj_t *gauge, lv_gauge_format_cb_t format_cb)
 */
 
STATIC mp_obj_t mp_lv_gauge_set_formatter_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *gauge = mp_to_lv(mp_args[0]);
    void *format_cb = mp_lv_callback(mp_args[1], &lv_obj_t_format_cb_callback, MP_QSTR_lv_obj_t_format_cb, &gauge->user_data);
    ((void (*)(lv_obj_t *, lv_gauge_format_cb_t))lv_func_ptr)(gauge, format_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gauge_set_formatter_cb_obj, 2, mp_lv_gauge_set_formatter_cb, lv_gauge_set_formatter_cb);
    

/*
 * lvgl extension definition for:
 * int32_t lv_gauge_get_value(const lv_obj_t *gauge, uint8_t needle)
 */
 
STATIC mp_obj_t mp_lv_gauge_get_value(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *gauge = mp_to_lv(mp_args[0]);
    uint8_t needle = (uint8_t)mp_obj_get_int(mp_args[1]);
    int32_t _res = ((int32_t (*)(const lv_obj_t *, uint8_t))lv_func_ptr)(gauge, needle);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gauge_get_value_obj, 2, mp_lv_gauge_get_value, lv_gauge_get_value);
    
/* Reusing lv_obj_get_protect for lv_gauge_get_needle_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gauge_get_needle_count_obj, 1, mp_lv_obj_get_protect, lv_gauge_get_needle_count);
    
/* Reusing lv_obj_get_protect for lv_gauge_get_label_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gauge_get_label_count_obj, 1, mp_lv_obj_get_protect, lv_gauge_get_label_count);
    
/* Reusing lv_img_get_src for lv_gauge_get_needle_img */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gauge_get_needle_img_obj, 1, mp_lv_img_get_src, lv_gauge_get_needle_img);
    
/* Reusing lv_obj_get_height_margin for lv_gauge_get_needle_img_pivot_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gauge_get_needle_img_pivot_x_obj, 1, mp_lv_obj_get_height_margin, lv_gauge_get_needle_img_pivot_x);
    
/* Reusing lv_obj_get_height_margin for lv_gauge_get_needle_img_pivot_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_gauge_get_needle_img_pivot_y_obj, 1, mp_lv_obj_get_height_margin, lv_gauge_get_needle_img_pivot_y);
    

/*
 * lvgl gauge object definitions
 */
    

STATIC const mp_rom_map_elem_t gauge_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_range), MP_ROM_PTR(&mp_lv_gauge_set_range_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_critical_value), MP_ROM_PTR(&mp_lv_gauge_set_critical_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_angle_offset), MP_ROM_PTR(&mp_lv_gauge_set_angle_offset_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_min_value), MP_ROM_PTR(&mp_lv_gauge_get_min_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_max_value), MP_ROM_PTR(&mp_lv_gauge_get_max_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_critical_value), MP_ROM_PTR(&mp_lv_gauge_get_critical_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_line_count), MP_ROM_PTR(&mp_lv_gauge_get_line_count_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scale_angle), MP_ROM_PTR(&mp_lv_gauge_get_scale_angle_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_angle_offset), MP_ROM_PTR(&mp_lv_gauge_get_angle_offset_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_needle_count), MP_ROM_PTR(&mp_lv_gauge_set_needle_count_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_value), MP_ROM_PTR(&mp_lv_gauge_set_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scale), MP_ROM_PTR(&mp_lv_gauge_set_scale_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_needle_img), MP_ROM_PTR(&mp_lv_gauge_set_needle_img_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_formatter_cb), MP_ROM_PTR(&mp_lv_gauge_set_formatter_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_value), MP_ROM_PTR(&mp_lv_gauge_get_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_needle_count), MP_ROM_PTR(&mp_lv_gauge_get_needle_count_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_label_count), MP_ROM_PTR(&mp_lv_gauge_get_label_count_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_needle_img), MP_ROM_PTR(&mp_lv_gauge_get_needle_img_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_needle_img_pivot_x), MP_ROM_PTR(&mp_lv_gauge_get_needle_img_pivot_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_needle_img_pivot_y), MP_ROM_PTR(&mp_lv_gauge_get_needle_img_pivot_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_GAUGE_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(gauge_locals_dict, gauge_locals_dict_table);

STATIC void gauge_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl gauge");
}


STATIC mp_obj_t gauge_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_gauge_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_gauge_type = {
    { &mp_type_type },
    .name = MP_QSTR_gauge,
    .print = gauge_print,
    .make_new = gauge_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&gauge_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_label_set_anim_speed for lv_switch_set_anim_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_switch_set_anim_time_obj, 2, mp_lv_label_set_anim_speed, lv_switch_set_anim_time);
    
/* Reusing lv_obj_is_visible for lv_switch_get_state */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_switch_get_state_obj, 1, mp_lv_obj_is_visible, lv_switch_get_state);
    
/* Reusing lv_obj_count_children for lv_switch_get_anim_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_switch_get_anim_time_obj, 1, mp_lv_obj_count_children, lv_switch_get_anim_time);
    

/*
 * lvgl extension definition for:
 * void lv_switch_on(lv_obj_t *sw, lv_anim_enable_t anim)
 */
 
STATIC mp_obj_t mp_lv_switch_on(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *sw = mp_to_lv(mp_args[0]);
    lv_anim_enable_t anim = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_anim_enable_t))lv_func_ptr)(sw, anim);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_switch_on_obj, 2, mp_lv_switch_on, lv_switch_on);
    
/* Reusing lv_switch_on for lv_switch_off */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_switch_off_obj, 2, mp_lv_switch_on, lv_switch_off);
    

/*
 * lvgl extension definition for:
 * bool lv_switch_toggle(lv_obj_t *sw, lv_anim_enable_t anim)
 */
 
STATIC mp_obj_t mp_lv_switch_toggle(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *sw = mp_to_lv(mp_args[0]);
    lv_anim_enable_t anim = (uint8_t)mp_obj_get_int(mp_args[1]);
    bool _res = ((bool (*)(lv_obj_t *, lv_anim_enable_t))lv_func_ptr)(sw, anim);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_switch_toggle_obj, 2, mp_lv_switch_toggle, lv_switch_toggle);
    

/*
 * lvgl switch object definitions
 */
    

STATIC const mp_rom_map_elem_t switch_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_anim_time), MP_ROM_PTR(&mp_lv_switch_set_anim_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_state), MP_ROM_PTR(&mp_lv_switch_get_state_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_anim_time), MP_ROM_PTR(&mp_lv_switch_get_anim_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_on), MP_ROM_PTR(&mp_lv_switch_on_obj) },
    { MP_ROM_QSTR(MP_QSTR_off), MP_ROM_PTR(&mp_lv_switch_off_obj) },
    { MP_ROM_QSTR(MP_QSTR_toggle), MP_ROM_PTR(&mp_lv_switch_toggle_obj) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_SWITCH_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(switch_locals_dict, switch_locals_dict_table);

STATIC void switch_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl switch");
}


STATIC mp_obj_t switch_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_switch_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_switch_type = {
    { &mp_type_type },
    .name = MP_QSTR_switch,
    .print = switch_print,
    .make_new = switch_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&switch_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_label_set_anim_speed for lv_arc_set_start_angle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_start_angle_obj, 2, mp_lv_label_set_anim_speed, lv_arc_set_start_angle);
    
/* Reusing lv_label_set_anim_speed for lv_arc_set_end_angle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_end_angle_obj, 2, mp_lv_label_set_anim_speed, lv_arc_set_end_angle);
    
/* Reusing lv_linemeter_set_scale for lv_arc_set_angles */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_angles_obj, 3, mp_lv_linemeter_set_scale, lv_arc_set_angles);
    
/* Reusing lv_label_set_anim_speed for lv_arc_set_bg_start_angle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_bg_start_angle_obj, 2, mp_lv_label_set_anim_speed, lv_arc_set_bg_start_angle);
    
/* Reusing lv_label_set_anim_speed for lv_arc_set_bg_end_angle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_bg_end_angle_obj, 2, mp_lv_label_set_anim_speed, lv_arc_set_bg_end_angle);
    
/* Reusing lv_linemeter_set_scale for lv_arc_set_bg_angles */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_bg_angles_obj, 3, mp_lv_linemeter_set_scale, lv_arc_set_bg_angles);
    
/* Reusing lv_label_set_anim_speed for lv_arc_set_rotation */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_rotation_obj, 2, mp_lv_label_set_anim_speed, lv_arc_set_rotation);
    

/*
 * lvgl extension definition for:
 * void lv_arc_set_type(lv_obj_t *arc, lv_arc_type_t type)
 */
 
STATIC mp_obj_t mp_lv_arc_set_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *arc = mp_to_lv(mp_args[0]);
    lv_arc_type_t type = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_arc_type_t))lv_func_ptr)(arc, type);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_type_obj, 2, mp_lv_arc_set_type, lv_arc_set_type);
    
/* Reusing lv_img_set_angle for lv_arc_set_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_value_obj, 2, mp_lv_img_set_angle, lv_arc_set_value);
    
/* Reusing lv_bar_set_range for lv_arc_set_range */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_range_obj, 3, mp_lv_bar_set_range, lv_arc_set_range);
    
/* Reusing lv_label_set_anim_speed for lv_arc_set_chg_rate */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_chg_rate_obj, 2, mp_lv_label_set_anim_speed, lv_arc_set_chg_rate);
    
/* Reusing lv_obj_set_auto_realign for lv_arc_set_adjustable */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_set_adjustable_obj, 2, mp_lv_obj_set_auto_realign, lv_arc_set_adjustable);
    
/* Reusing lv_img_get_angle for lv_arc_get_angle_start */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_angle_start_obj, 1, mp_lv_img_get_angle, lv_arc_get_angle_start);
    
/* Reusing lv_img_get_angle for lv_arc_get_angle_end */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_angle_end_obj, 1, mp_lv_img_get_angle, lv_arc_get_angle_end);
    
/* Reusing lv_img_get_angle for lv_arc_get_bg_angle_start */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_bg_angle_start_obj, 1, mp_lv_img_get_angle, lv_arc_get_bg_angle_start);
    
/* Reusing lv_img_get_angle for lv_arc_get_bg_angle_end */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_bg_angle_end_obj, 1, mp_lv_img_get_angle, lv_arc_get_bg_angle_end);
    

/*
 * lvgl extension definition for:
 * lv_arc_type_t lv_arc_get_type(const lv_obj_t *arc)
 */
 
STATIC mp_obj_t mp_lv_arc_get_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *arc = mp_to_lv(mp_args[0]);
    lv_arc_type_t _res = ((lv_arc_type_t (*)(const lv_obj_t *))lv_func_ptr)(arc);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_type_obj, 1, mp_lv_arc_get_type, lv_arc_get_type);
    
/* Reusing lv_bar_get_value for lv_arc_get_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_value_obj, 1, mp_lv_bar_get_value, lv_arc_get_value);
    
/* Reusing lv_bar_get_value for lv_arc_get_min_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_min_value_obj, 1, mp_lv_bar_get_value, lv_arc_get_min_value);
    
/* Reusing lv_bar_get_value for lv_arc_get_max_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_max_value_obj, 1, mp_lv_bar_get_value, lv_arc_get_max_value);
    
/* Reusing lv_obj_is_visible for lv_arc_is_dragged */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_is_dragged_obj, 1, mp_lv_obj_is_visible, lv_arc_is_dragged);
    
/* Reusing lv_img_get_antialias for lv_arc_get_adjustable */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_arc_get_adjustable_obj, 1, mp_lv_img_get_antialias, lv_arc_get_adjustable);
    

/*
 * lvgl arc object definitions
 */
    

STATIC const mp_rom_map_elem_t arc_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_start_angle), MP_ROM_PTR(&mp_lv_arc_set_start_angle_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_end_angle), MP_ROM_PTR(&mp_lv_arc_set_end_angle_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_angles), MP_ROM_PTR(&mp_lv_arc_set_angles_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_start_angle), MP_ROM_PTR(&mp_lv_arc_set_bg_start_angle_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_end_angle), MP_ROM_PTR(&mp_lv_arc_set_bg_end_angle_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_angles), MP_ROM_PTR(&mp_lv_arc_set_bg_angles_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_rotation), MP_ROM_PTR(&mp_lv_arc_set_rotation_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_type), MP_ROM_PTR(&mp_lv_arc_set_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_value), MP_ROM_PTR(&mp_lv_arc_set_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_range), MP_ROM_PTR(&mp_lv_arc_set_range_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_chg_rate), MP_ROM_PTR(&mp_lv_arc_set_chg_rate_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_adjustable), MP_ROM_PTR(&mp_lv_arc_set_adjustable_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_angle_start), MP_ROM_PTR(&mp_lv_arc_get_angle_start_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_angle_end), MP_ROM_PTR(&mp_lv_arc_get_angle_end_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_bg_angle_start), MP_ROM_PTR(&mp_lv_arc_get_bg_angle_start_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_bg_angle_end), MP_ROM_PTR(&mp_lv_arc_get_bg_angle_end_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_type), MP_ROM_PTR(&mp_lv_arc_get_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_value), MP_ROM_PTR(&mp_lv_arc_get_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_min_value), MP_ROM_PTR(&mp_lv_arc_get_min_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_max_value), MP_ROM_PTR(&mp_lv_arc_get_max_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_dragged), MP_ROM_PTR(&mp_lv_arc_is_dragged_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_adjustable), MP_ROM_PTR(&mp_lv_arc_get_adjustable_obj) },
    { MP_ROM_QSTR(MP_QSTR_TYPE), MP_ROM_PTR(&mp_LV_ARC_TYPE_type) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_ARC_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(arc_locals_dict, arc_locals_dict_table);

STATIC void arc_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl arc");
}


STATIC mp_obj_t arc_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_arc_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_arc_type = {
    { &mp_type_type },
    .name = MP_QSTR_arc,
    .print = arc_print,
    .make_new = arc_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&arc_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * lvgl extension definition for:
 * void lv_spinner_set_arc_length(lv_obj_t *spinner, lv_anim_value_t deg)
 */
 
STATIC mp_obj_t mp_lv_spinner_set_arc_length(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *spinner = mp_to_lv(mp_args[0]);
    lv_anim_value_t deg = (int16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_anim_value_t))lv_func_ptr)(spinner, deg);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinner_set_arc_length_obj, 2, mp_lv_spinner_set_arc_length, lv_spinner_set_arc_length);
    
/* Reusing lv_label_set_anim_speed for lv_spinner_set_spin_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinner_set_spin_time_obj, 2, mp_lv_label_set_anim_speed, lv_spinner_set_spin_time);
    

/*
 * lvgl extension definition for:
 * void lv_spinner_set_type(lv_obj_t *spinner, lv_spinner_type_t type)
 */
 
STATIC mp_obj_t mp_lv_spinner_set_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *spinner = mp_to_lv(mp_args[0]);
    lv_spinner_type_t type = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_spinner_type_t))lv_func_ptr)(spinner, type);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinner_set_type_obj, 2, mp_lv_spinner_set_type, lv_spinner_set_type);
    

/*
 * lvgl extension definition for:
 * void lv_spinner_set_dir(lv_obj_t *spinner, lv_spinner_dir_t dir)
 */
 
STATIC mp_obj_t mp_lv_spinner_set_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *spinner = mp_to_lv(mp_args[0]);
    lv_spinner_dir_t dir = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_spinner_dir_t))lv_func_ptr)(spinner, dir);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinner_set_dir_obj, 2, mp_lv_spinner_set_dir, lv_spinner_set_dir);
    

/*
 * lvgl extension definition for:
 * lv_anim_value_t lv_spinner_get_arc_length(const lv_obj_t *spinner)
 */
 
STATIC mp_obj_t mp_lv_spinner_get_arc_length(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *spinner = mp_to_lv(mp_args[0]);
    lv_anim_value_t _res = ((lv_anim_value_t (*)(const lv_obj_t *))lv_func_ptr)(spinner);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinner_get_arc_length_obj, 1, mp_lv_spinner_get_arc_length, lv_spinner_get_arc_length);
    
/* Reusing lv_obj_count_children for lv_spinner_get_spin_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinner_get_spin_time_obj, 1, mp_lv_obj_count_children, lv_spinner_get_spin_time);
    

/*
 * lvgl extension definition for:
 * lv_spinner_type_t lv_spinner_get_type(lv_obj_t *spinner)
 */
 
STATIC mp_obj_t mp_lv_spinner_get_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *spinner = mp_to_lv(mp_args[0]);
    lv_spinner_type_t _res = ((lv_spinner_type_t (*)(lv_obj_t *))lv_func_ptr)(spinner);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinner_get_type_obj, 1, mp_lv_spinner_get_type, lv_spinner_get_type);
    

/*
 * lvgl extension definition for:
 * lv_spinner_dir_t lv_spinner_get_dir(lv_obj_t *spinner)
 */
 
STATIC mp_obj_t mp_lv_spinner_get_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *spinner = mp_to_lv(mp_args[0]);
    lv_spinner_dir_t _res = ((lv_spinner_dir_t (*)(lv_obj_t *))lv_func_ptr)(spinner);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinner_get_dir_obj, 1, mp_lv_spinner_get_dir, lv_spinner_get_dir);
    
/* Reusing funcptr_lv_anim_exec_xcb_t for lv_spinner_anim_cb */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_spinner_anim_cb_obj, 2, mp_funcptr_lv_anim_exec_xcb_t, lv_spinner_anim_cb);
    

/*
 * lvgl spinner object definitions
 */
    

STATIC const mp_rom_map_elem_t spinner_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_arc_length), MP_ROM_PTR(&mp_lv_spinner_set_arc_length_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_spin_time), MP_ROM_PTR(&mp_lv_spinner_set_spin_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_type), MP_ROM_PTR(&mp_lv_spinner_set_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_dir), MP_ROM_PTR(&mp_lv_spinner_set_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_arc_length), MP_ROM_PTR(&mp_lv_spinner_get_arc_length_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_spin_time), MP_ROM_PTR(&mp_lv_spinner_get_spin_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_type), MP_ROM_PTR(&mp_lv_spinner_get_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_dir), MP_ROM_PTR(&mp_lv_spinner_get_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_anim_cb), MP_ROM_PTR(&mp_lv_spinner_anim_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_TYPE), MP_ROM_PTR(&mp_LV_SPINNER_TYPE_type) },
    { MP_ROM_QSTR(MP_QSTR_DIR), MP_ROM_PTR(&mp_LV_SPINNER_DIR_type) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_SPINNER_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(spinner_locals_dict, spinner_locals_dict_table);

STATIC void spinner_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl spinner");
}


STATIC mp_obj_t spinner_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_spinner_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_spinner_type = {
    { &mp_type_type },
    .name = MP_QSTR_spinner,
    .print = spinner_print,
    .make_new = spinner_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&spinner_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    

/*
 * Struct lv_calendar_date_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_calendar_date_t_type();

STATIC inline lv_calendar_date_t* mp_write_ptr_lv_calendar_date_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_calendar_date_t_type()));
    return (lv_calendar_date_t*)self->data;
}

#define mp_write_lv_calendar_date_t(struct_obj) *mp_write_ptr_lv_calendar_date_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_calendar_date_t(lv_calendar_date_t *field)
{
    return lv_to_mp_struct(get_mp_lv_calendar_date_t_type(), (void*)field);
}

#define mp_read_lv_calendar_date_t(field) mp_read_ptr_lv_calendar_date_t(copy_buffer(&field, sizeof(lv_calendar_date_t)))
#define mp_read_byref_lv_calendar_date_t(field) mp_read_ptr_lv_calendar_date_t(&field)

STATIC void mp_lv_calendar_date_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_calendar_date_t *data = (lv_calendar_date_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_year: dest[0] = mp_obj_new_int_from_uint(data->year); break; // converting from uint16_t;
            case MP_QSTR_month: dest[0] = mp_obj_new_int(data->month); break; // converting from int8_t;
            case MP_QSTR_day: dest[0] = mp_obj_new_int(data->day); break; // converting from int8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_year: data->year = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_month: data->month = (int8_t)mp_obj_get_int(dest[1]); break; // converting to int8_t;
                case MP_QSTR_day: data->day = (int8_t)mp_obj_get_int(dest[1]); break; // converting to int8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_calendar_date_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_calendar_date_t");
}

STATIC const mp_obj_dict_t mp_lv_calendar_date_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_calendar_date_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_calendar_date_t,
    .print = mp_lv_calendar_date_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_calendar_date_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_calendar_date_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_calendar_date_t_type()
{
    return &mp_lv_calendar_date_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_calendar_set_today_date(lv_obj_t *calendar, lv_calendar_date_t *today)
 */
 
STATIC mp_obj_t mp_lv_calendar_set_today_date(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *calendar = mp_to_lv(mp_args[0]);
    lv_calendar_date_t *today = mp_write_ptr_lv_calendar_date_t(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_calendar_date_t *))lv_func_ptr)(calendar, today);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_set_today_date_obj, 2, mp_lv_calendar_set_today_date, lv_calendar_set_today_date);
    
/* Reusing lv_calendar_set_today_date for lv_calendar_set_showed_date */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_set_showed_date_obj, 2, mp_lv_calendar_set_today_date, lv_calendar_set_showed_date);
    

/*
 * Array convertors for lv_calendar_date_t []
 */

STATIC lv_calendar_date_t *mp_arr_to_lv_calendar_date_t_____(mp_obj_t mp_arr)
{
    mp_obj_t mp_len = mp_obj_len_maybe(mp_arr);
    if (mp_len == MP_OBJ_NULL) return mp_to_ptr(mp_arr);
    mp_int_t len = mp_obj_get_int(mp_len);
    
    lv_calendar_date_t *lv_arr = (lv_calendar_date_t*)m_malloc(len * sizeof(lv_calendar_date_t));
    mp_obj_t iter = mp_getiter(mp_arr, NULL);
    mp_obj_t item;
    size_t i = 0;
    while ((item = mp_iternext(iter)) != MP_OBJ_STOP_ITERATION) {
        lv_arr[i++] = mp_write_lv_calendar_date_t(item);
    }
    return (lv_calendar_date_t *)lv_arr;
}
    
STATIC mp_obj_t mp_arr_from_lv_calendar_date_t_____(lv_calendar_date_t *arr)
{
    mp_obj_t obj_arr[1];
    for (size_t i=0; i<1; i++){
        obj_arr[i] = mp_read_lv_calendar_date_t(arr[i]);
    }
    return mp_obj_new_list(1, obj_arr); // TODO: return custom iterable object!
}
    

/*
 * lvgl extension definition for:
 * void lv_calendar_set_highlighted_dates(lv_obj_t *calendar, lv_calendar_date_t highlighted[], uint16_t date_num)
 */
 
STATIC mp_obj_t mp_lv_calendar_set_highlighted_dates(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *calendar = mp_to_lv(mp_args[0]);
    lv_calendar_date_t *highlighted = mp_arr_to_lv_calendar_date_t_____(mp_args[1]);
    uint16_t date_num = (uint16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_obj_t *, lv_calendar_date_t [], uint16_t))lv_func_ptr)(calendar, highlighted, date_num);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_set_highlighted_dates_obj, 3, mp_lv_calendar_set_highlighted_dates, lv_calendar_set_highlighted_dates);
    

/*
 * lvgl extension definition for:
 * void lv_calendar_set_day_names(lv_obj_t *calendar, const char **day_names)
 */
 
STATIC mp_obj_t mp_lv_calendar_set_day_names(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *calendar = mp_to_lv(mp_args[0]);
    const char **day_names = mp_to_ptr(mp_args[1]);
    ((void (*)(lv_obj_t *, const char **))lv_func_ptr)(calendar, day_names);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_set_day_names_obj, 2, mp_lv_calendar_set_day_names, lv_calendar_set_day_names);
    
/* Reusing lv_calendar_set_day_names for lv_calendar_set_month_names */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_set_month_names_obj, 2, mp_lv_calendar_set_day_names, lv_calendar_set_month_names);
    

/*
 * lvgl extension definition for:
 * lv_calendar_date_t *lv_calendar_get_today_date(const lv_obj_t *calendar)
 */
 
STATIC mp_obj_t mp_lv_calendar_get_today_date(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *calendar = mp_to_lv(mp_args[0]);
    lv_calendar_date_t * _res = ((lv_calendar_date_t *(*)(const lv_obj_t *))lv_func_ptr)(calendar);
    return mp_read_ptr_lv_calendar_date_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_get_today_date_obj, 1, mp_lv_calendar_get_today_date, lv_calendar_get_today_date);
    
/* Reusing lv_calendar_get_today_date for lv_calendar_get_showed_date */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_get_showed_date_obj, 1, mp_lv_calendar_get_today_date, lv_calendar_get_showed_date);
    
/* Reusing lv_calendar_get_today_date for lv_calendar_get_pressed_date */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_get_pressed_date_obj, 1, mp_lv_calendar_get_today_date, lv_calendar_get_pressed_date);
    
/* Reusing lv_calendar_get_today_date for lv_calendar_get_highlighted_dates */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_get_highlighted_dates_obj, 1, mp_lv_calendar_get_today_date, lv_calendar_get_highlighted_dates);
    
/* Reusing lv_obj_count_children for lv_calendar_get_highlighted_dates_num */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_get_highlighted_dates_num_obj, 1, mp_lv_obj_count_children, lv_calendar_get_highlighted_dates_num);
    
/* Reusing lv_btnmatrix_get_map_array for lv_calendar_get_day_names */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_get_day_names_obj, 1, mp_lv_btnmatrix_get_map_array, lv_calendar_get_day_names);
    
/* Reusing lv_btnmatrix_get_map_array for lv_calendar_get_month_names */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_calendar_get_month_names_obj, 1, mp_lv_btnmatrix_get_map_array, lv_calendar_get_month_names);
    

/*
 * lvgl extension definition for:
 * uint8_t lv_calendar_get_day_of_week(uint32_t year, uint32_t month, uint32_t day)
 */
 
STATIC mp_obj_t mp_lv_calendar_get_day_of_week(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint32_t year = (uint32_t)mp_obj_get_int(mp_args[0]);
    uint32_t month = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t day = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint8_t _res = ((uint8_t (*)(uint32_t, uint32_t, uint32_t))lv_func_ptr)(year, month, day);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_calendar_get_day_of_week_obj, 3, mp_lv_calendar_get_day_of_week, lv_calendar_get_day_of_week);
    

/*
 * lvgl calendar object definitions
 */
    

STATIC const mp_rom_map_elem_t calendar_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_today_date), MP_ROM_PTR(&mp_lv_calendar_set_today_date_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_showed_date), MP_ROM_PTR(&mp_lv_calendar_set_showed_date_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_highlighted_dates), MP_ROM_PTR(&mp_lv_calendar_set_highlighted_dates_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_day_names), MP_ROM_PTR(&mp_lv_calendar_set_day_names_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_month_names), MP_ROM_PTR(&mp_lv_calendar_set_month_names_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_today_date), MP_ROM_PTR(&mp_lv_calendar_get_today_date_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_showed_date), MP_ROM_PTR(&mp_lv_calendar_get_showed_date_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_pressed_date), MP_ROM_PTR(&mp_lv_calendar_get_pressed_date_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_highlighted_dates), MP_ROM_PTR(&mp_lv_calendar_get_highlighted_dates_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_highlighted_dates_num), MP_ROM_PTR(&mp_lv_calendar_get_highlighted_dates_num_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_day_names), MP_ROM_PTR(&mp_lv_calendar_get_day_names_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_month_names), MP_ROM_PTR(&mp_lv_calendar_get_month_names_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_day_of_week), MP_ROM_PTR(&mp_lv_calendar_get_day_of_week_obj) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_CALENDAR_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(calendar_locals_dict, calendar_locals_dict_table);

STATIC void calendar_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl calendar");
}


STATIC mp_obj_t calendar_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_calendar_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_calendar_type = {
    { &mp_type_type },
    .name = MP_QSTR_calendar,
    .print = calendar_print,
    .make_new = calendar_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&calendar_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
/* Reusing lv_obj_set_auto_realign for lv_spinbox_set_rollover */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_set_rollover_obj, 2, mp_lv_obj_set_auto_realign, lv_spinbox_set_rollover);
    
/* Reusing lv_textarea_set_cursor_pos for lv_spinbox_set_value */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_set_value_obj, 2, mp_lv_textarea_set_cursor_pos, lv_spinbox_set_value);
    
/* Reusing lv_chart_set_div_line_count for lv_spinbox_set_digit_format */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_set_digit_format_obj, 3, mp_lv_chart_set_div_line_count, lv_spinbox_set_digit_format);
    
/* Reusing lv_label_set_text_sel_start for lv_spinbox_set_step */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_set_step_obj, 2, mp_lv_label_set_text_sel_start, lv_spinbox_set_step);
    
/* Reusing lv_linemeter_set_range for lv_spinbox_set_range */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_set_range_obj, 3, mp_lv_linemeter_set_range, lv_spinbox_set_range);
    
/* Reusing lv_obj_clean_style_list for lv_spinbox_set_padding_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_set_padding_left_obj, 2, mp_lv_obj_clean_style_list, lv_spinbox_set_padding_left);
    
/* Reusing lv_img_get_antialias for lv_spinbox_get_rollover */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_get_rollover_obj, 1, mp_lv_img_get_antialias, lv_spinbox_get_rollover);
    

/*
 * lvgl extension definition for:
 * int32_t lv_spinbox_get_value(lv_obj_t *spinbox)
 */
 
STATIC mp_obj_t mp_lv_spinbox_get_value(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *spinbox = mp_to_lv(mp_args[0]);
    int32_t _res = ((int32_t (*)(lv_obj_t *))lv_func_ptr)(spinbox);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_get_value_obj, 1, mp_lv_spinbox_get_value, lv_spinbox_get_value);
    
/* Reusing lv_obj_clean for lv_spinbox_step_next */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_step_next_obj, 1, mp_lv_obj_clean, lv_spinbox_step_next);
    
/* Reusing lv_obj_clean for lv_spinbox_step_prev */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_step_prev_obj, 1, mp_lv_obj_clean, lv_spinbox_step_prev);
    
/* Reusing lv_obj_clean for lv_spinbox_increment */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_increment_obj, 1, mp_lv_obj_clean, lv_spinbox_increment);
    
/* Reusing lv_obj_clean for lv_spinbox_decrement */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_spinbox_decrement_obj, 1, mp_lv_obj_clean, lv_spinbox_decrement);
    

/*
 * lvgl spinbox object definitions
 */
    

STATIC const mp_rom_map_elem_t spinbox_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_set_rollover), MP_ROM_PTR(&mp_lv_spinbox_set_rollover_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_value), MP_ROM_PTR(&mp_lv_spinbox_set_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_digit_format), MP_ROM_PTR(&mp_lv_spinbox_set_digit_format_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_step), MP_ROM_PTR(&mp_lv_spinbox_set_step_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_range), MP_ROM_PTR(&mp_lv_spinbox_set_range_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_padding_left), MP_ROM_PTR(&mp_lv_spinbox_set_padding_left_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_rollover), MP_ROM_PTR(&mp_lv_spinbox_get_rollover_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_value), MP_ROM_PTR(&mp_lv_spinbox_get_value_obj) },
    { MP_ROM_QSTR(MP_QSTR_step_next), MP_ROM_PTR(&mp_lv_spinbox_step_next_obj) },
    { MP_ROM_QSTR(MP_QSTR_step_prev), MP_ROM_PTR(&mp_lv_spinbox_step_prev_obj) },
    { MP_ROM_QSTR(MP_QSTR_increment), MP_ROM_PTR(&mp_lv_spinbox_increment_obj) },
    { MP_ROM_QSTR(MP_QSTR_decrement), MP_ROM_PTR(&mp_lv_spinbox_decrement_obj) },
    { MP_ROM_QSTR(MP_QSTR_PART), MP_ROM_PTR(&mp_LV_SPINBOX_PART_type) }
};

STATIC MP_DEFINE_CONST_DICT(spinbox_locals_dict, spinbox_locals_dict_table);

STATIC void spinbox_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "lvgl spinbox");
}


STATIC mp_obj_t spinbox_make_new(
    const mp_obj_type_t *type,
    size_t n_args,
    size_t n_kw,
    const mp_obj_t *args)
{
    return make_new(&lv_spinbox_create, type, n_args, n_kw, args);           
}


STATIC const mp_obj_type_t mp_spinbox_type = {
    { &mp_type_type },
    .name = MP_QSTR_spinbox,
    .print = spinbox_print,
    .make_new = spinbox_make_new,
    .attr = call_parent_methods,
    .locals_dict = (mp_obj_dict_t*)&spinbox_locals_dict,
    .buffer_p = { .get_buffer = mp_lv_obj_get_buffer },
    .parent = &mp_obj_type,
};
    
#define funcptr_lv_log_print_g_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_log_print_g_cb_t(lv_log_level_t level, const char *, uint32_t, const char *, const char *)
 */
 
STATIC mp_obj_t mp_funcptr_lv_log_print_g_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_log_level_t level = (int8_t)mp_obj_get_int(mp_args[0]);
    const char *arg1 = (char*)convert_from_str(mp_args[1]);
    uint32_t arg2 = (uint32_t)mp_obj_get_int(mp_args[2]);
    const char *arg3 = (char*)convert_from_str(mp_args[3]);
    const char *arg4 = (char*)convert_from_str(mp_args[4]);
    ((void (*)(lv_log_level_t, const char *, uint32_t, const char *, const char *))lv_func_ptr)(level, arg1, arg2, arg3, arg4);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_log_print_g_cb_t_obj, 5, mp_funcptr_lv_log_print_g_cb_t, funcptr_lv_log_print_g_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_log_print_g_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_log_print_g_cb_t_obj, func, NULL, MP_QSTR_, NULL); }


/*
 * Struct lv_mem_monitor_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_mem_monitor_t_type();

STATIC inline lv_mem_monitor_t* mp_write_ptr_lv_mem_monitor_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_mem_monitor_t_type()));
    return (lv_mem_monitor_t*)self->data;
}

#define mp_write_lv_mem_monitor_t(struct_obj) *mp_write_ptr_lv_mem_monitor_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_mem_monitor_t(lv_mem_monitor_t *field)
{
    return lv_to_mp_struct(get_mp_lv_mem_monitor_t_type(), (void*)field);
}

#define mp_read_lv_mem_monitor_t(field) mp_read_ptr_lv_mem_monitor_t(copy_buffer(&field, sizeof(lv_mem_monitor_t)))
#define mp_read_byref_lv_mem_monitor_t(field) mp_read_ptr_lv_mem_monitor_t(&field)

STATIC void mp_lv_mem_monitor_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_mem_monitor_t *data = (lv_mem_monitor_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_total_size: dest[0] = mp_obj_new_int_from_uint(data->total_size); break; // converting from uint32_t;
            case MP_QSTR_free_cnt: dest[0] = mp_obj_new_int_from_uint(data->free_cnt); break; // converting from uint32_t;
            case MP_QSTR_free_size: dest[0] = mp_obj_new_int_from_uint(data->free_size); break; // converting from uint32_t;
            case MP_QSTR_free_biggest_size: dest[0] = mp_obj_new_int_from_uint(data->free_biggest_size); break; // converting from uint32_t;
            case MP_QSTR_used_cnt: dest[0] = mp_obj_new_int_from_uint(data->used_cnt); break; // converting from uint32_t;
            case MP_QSTR_max_used: dest[0] = mp_obj_new_int_from_uint(data->max_used); break; // converting from uint32_t;
            case MP_QSTR_used_pct: dest[0] = mp_obj_new_int_from_uint(data->used_pct); break; // converting from uint8_t;
            case MP_QSTR_frag_pct: dest[0] = mp_obj_new_int_from_uint(data->frag_pct); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_total_size: data->total_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_free_cnt: data->free_cnt = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_free_size: data->free_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_free_biggest_size: data->free_biggest_size = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_used_cnt: data->used_cnt = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_max_used: data->max_used = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_used_pct: data->used_pct = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_frag_pct: data->frag_pct = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_mem_monitor_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_mem_monitor_t");
}

STATIC const mp_obj_dict_t mp_lv_mem_monitor_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_mem_monitor_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_mem_monitor_t,
    .print = mp_lv_mem_monitor_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_mem_monitor_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_mem_monitor_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_mem_monitor_t_type()
{
    return &mp_lv_mem_monitor_t_type;
}
    
#define funcptr_lv_async_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_async_cb_t(void *)
 */
 
STATIC mp_obj_t mp_funcptr_lv_async_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *arg0 = mp_to_ptr(mp_args[0]);
    ((void (*)(void *))lv_func_ptr)(arg0);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_async_cb_t_obj, 1, mp_funcptr_lv_async_cb_t, funcptr_lv_async_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_async_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_async_cb_t_obj, func, NULL, MP_QSTR_, NULL); }

#define funcptr_read_cb NULL


/*
 * Struct lv_indev_data_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_indev_data_t_type();

STATIC inline lv_indev_data_t* mp_write_ptr_lv_indev_data_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_indev_data_t_type()));
    return (lv_indev_data_t*)self->data;
}

#define mp_write_lv_indev_data_t(struct_obj) *mp_write_ptr_lv_indev_data_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_indev_data_t(lv_indev_data_t *field)
{
    return lv_to_mp_struct(get_mp_lv_indev_data_t_type(), (void*)field);
}

#define mp_read_lv_indev_data_t(field) mp_read_ptr_lv_indev_data_t(copy_buffer(&field, sizeof(lv_indev_data_t)))
#define mp_read_byref_lv_indev_data_t(field) mp_read_ptr_lv_indev_data_t(&field)

STATIC void mp_lv_indev_data_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_indev_data_t *data = (lv_indev_data_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_point: dest[0] = mp_read_byref_lv_point_t(data->point); break; // converting from lv_point_t;
            case MP_QSTR_key: dest[0] = mp_obj_new_int_from_uint(data->key); break; // converting from uint32_t;
            case MP_QSTR_btn_id: dest[0] = mp_obj_new_int_from_uint(data->btn_id); break; // converting from uint32_t;
            case MP_QSTR_enc_diff: dest[0] = mp_obj_new_int(data->enc_diff); break; // converting from int16_t;
            case MP_QSTR_state: dest[0] = mp_obj_new_int_from_uint(data->state); break; // converting from lv_indev_state_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_point: data->point = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_key: data->key = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_btn_id: data->btn_id = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_enc_diff: data->enc_diff = (int16_t)mp_obj_get_int(dest[1]); break; // converting to int16_t;
                case MP_QSTR_state: data->state = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_indev_state_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_indev_data_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_indev_data_t");
}

STATIC const mp_obj_dict_t mp_lv_indev_data_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_indev_data_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_indev_data_t,
    .print = mp_lv_indev_data_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_indev_data_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_indev_data_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_indev_data_t_type()
{
    return &mp_lv_indev_data_t_type;
}
    

/*
 * lvgl extension definition for:
 * bool read_cb(struct _lv_indev_drv_t *indev_drv, lv_indev_data_t *data)
 */
 
STATIC mp_obj_t mp_funcptr_read_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_indev_drv_t *indev_drv = mp_to_ptr(mp_args[0]);
    lv_indev_data_t *data = mp_write_ptr_lv_indev_data_t(mp_args[1]);
    bool _res = ((bool (*)(struct _lv_indev_drv_t *, lv_indev_data_t *))lv_func_ptr)(indev_drv, data);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_read_cb_obj, 2, mp_funcptr_read_cb, funcptr_read_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_read_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_read_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC bool lv_indev_drv_t_read_cb_callback(struct _lv_indev_drv_t *indev_drv, lv_indev_data_t *data);
#define funcptr_feedback_cb NULL


/*
 * lvgl extension definition for:
 * void feedback_cb(struct _lv_indev_drv_t *, uint8_t)
 */
 
STATIC mp_obj_t mp_funcptr_feedback_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_indev_drv_t *arg0 = mp_to_ptr(mp_args[0]);
    uint8_t arg1 = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(struct _lv_indev_drv_t *, uint8_t))lv_func_ptr)(arg0, arg1);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_feedback_cb_obj, 2, mp_funcptr_feedback_cb, funcptr_feedback_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_feedback_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_feedback_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_indev_drv_t_feedback_cb_callback(struct _lv_indev_drv_t *, uint8_t);

/*
 * Struct lv_indev_drv_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_indev_drv_t_type();

STATIC inline lv_indev_drv_t* mp_write_ptr_lv_indev_drv_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_indev_drv_t_type()));
    return (lv_indev_drv_t*)self->data;
}

#define mp_write_lv_indev_drv_t(struct_obj) *mp_write_ptr_lv_indev_drv_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_indev_drv_t(lv_indev_drv_t *field)
{
    return lv_to_mp_struct(get_mp_lv_indev_drv_t_type(), (void*)field);
}

#define mp_read_lv_indev_drv_t(field) mp_read_ptr_lv_indev_drv_t(copy_buffer(&field, sizeof(lv_indev_drv_t)))
#define mp_read_byref_lv_indev_drv_t(field) mp_read_ptr_lv_indev_drv_t(&field)

STATIC void mp_lv_indev_drv_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_indev_drv_t *data = (lv_indev_drv_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_type: dest[0] = mp_obj_new_int_from_uint(data->type); break; // converting from lv_indev_type_t;
            case MP_QSTR_read_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_read_cb_obj, (void*)data->read_cb, lv_indev_drv_t_read_cb_callback ,MP_QSTR_lv_indev_drv_t_read_cb, data->user_data); break; // converting from callback bool (*)(lv_indev_drv_t *indev_drv, lv_indev_data_t *data);
            case MP_QSTR_feedback_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_feedback_cb_obj, (void*)data->feedback_cb, lv_indev_drv_t_feedback_cb_callback ,MP_QSTR_lv_indev_drv_t_feedback_cb, data->user_data); break; // converting from callback void (*)(lv_indev_drv_t *, uint8_t);
            case MP_QSTR_user_data: dest[0] = ptr_to_mp(data->user_data); break; // converting from lv_indev_drv_user_data_t;
            case MP_QSTR_disp: dest[0] = mp_read_ptr_lv_disp_t((void*)data->disp); break; // converting from lv_disp_t *;
            case MP_QSTR_read_task: dest[0] = mp_read_ptr_lv_task_t((void*)data->read_task); break; // converting from lv_task_t *;
            case MP_QSTR_drag_limit: dest[0] = mp_obj_new_int_from_uint(data->drag_limit); break; // converting from uint8_t;
            case MP_QSTR_drag_throw: dest[0] = mp_obj_new_int_from_uint(data->drag_throw); break; // converting from uint8_t;
            case MP_QSTR_gesture_min_velocity: dest[0] = mp_obj_new_int_from_uint(data->gesture_min_velocity); break; // converting from uint8_t;
            case MP_QSTR_gesture_limit: dest[0] = mp_obj_new_int_from_uint(data->gesture_limit); break; // converting from uint8_t;
            case MP_QSTR_long_press_time: dest[0] = mp_obj_new_int_from_uint(data->long_press_time); break; // converting from uint16_t;
            case MP_QSTR_long_press_rep_time: dest[0] = mp_obj_new_int_from_uint(data->long_press_rep_time); break; // converting from uint16_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_type: data->type = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_indev_type_t;
                case MP_QSTR_read_cb: data->read_cb = (void*)mp_lv_callback(dest[1], lv_indev_drv_t_read_cb_callback ,MP_QSTR_lv_indev_drv_t_read_cb, &data->user_data); break; // converting to callback bool (*)(lv_indev_drv_t *indev_drv, lv_indev_data_t *data);
                case MP_QSTR_feedback_cb: data->feedback_cb = (void*)mp_lv_callback(dest[1], lv_indev_drv_t_feedback_cb_callback ,MP_QSTR_lv_indev_drv_t_feedback_cb, &data->user_data); break; // converting to callback void (*)(lv_indev_drv_t *, uint8_t);
                case MP_QSTR_user_data: data->user_data = mp_to_ptr(dest[1]); break; // converting to lv_indev_drv_user_data_t;
                case MP_QSTR_disp: data->disp = (void*)mp_write_ptr_lv_disp_t(dest[1]); break; // converting to lv_disp_t *;
                case MP_QSTR_read_task: data->read_task = (void*)mp_write_ptr_lv_task_t(dest[1]); break; // converting to lv_task_t *;
                case MP_QSTR_drag_limit: data->drag_limit = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_drag_throw: data->drag_throw = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_gesture_min_velocity: data->gesture_min_velocity = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_gesture_limit: data->gesture_limit = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_long_press_time: data->long_press_time = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_long_press_rep_time: data->long_press_rep_time = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_indev_drv_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_indev_drv_t");
}

STATIC const mp_obj_dict_t mp_lv_indev_drv_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_indev_drv_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_indev_drv_t,
    .print = mp_lv_indev_drv_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_indev_drv_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_indev_drv_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_indev_drv_t_type()
{
    return &mp_lv_indev_drv_t_type;
}
    
typedef __typeof__( ((lv_indev_proc_t*)(0))->types ) lv_indev_proc_types_t;
typedef __typeof__( ((lv_indev_proc_types_t*)(0))->pointer ) lv_indev_proc_types_pointer_t;

/*
 * Struct lv_indev_proc_types_pointer_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_indev_proc_types_pointer_t_type();

STATIC inline lv_indev_proc_types_pointer_t* mp_write_ptr_lv_indev_proc_types_pointer_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_indev_proc_types_pointer_t_type()));
    return (lv_indev_proc_types_pointer_t*)self->data;
}

#define mp_write_lv_indev_proc_types_pointer_t(struct_obj) *mp_write_ptr_lv_indev_proc_types_pointer_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_indev_proc_types_pointer_t(lv_indev_proc_types_pointer_t *field)
{
    return lv_to_mp_struct(get_mp_lv_indev_proc_types_pointer_t_type(), (void*)field);
}

#define mp_read_lv_indev_proc_types_pointer_t(field) mp_read_ptr_lv_indev_proc_types_pointer_t(copy_buffer(&field, sizeof(lv_indev_proc_types_pointer_t)))
#define mp_read_byref_lv_indev_proc_types_pointer_t(field) mp_read_ptr_lv_indev_proc_types_pointer_t(&field)

STATIC void mp_lv_indev_proc_types_pointer_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_indev_proc_types_pointer_t *data = (lv_indev_proc_types_pointer_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_act_point: dest[0] = mp_read_byref_lv_point_t(data->act_point); break; // converting from lv_point_t;
            case MP_QSTR_last_point: dest[0] = mp_read_byref_lv_point_t(data->last_point); break; // converting from lv_point_t;
            case MP_QSTR_vect: dest[0] = mp_read_byref_lv_point_t(data->vect); break; // converting from lv_point_t;
            case MP_QSTR_drag_sum: dest[0] = mp_read_byref_lv_point_t(data->drag_sum); break; // converting from lv_point_t;
            case MP_QSTR_drag_throw_vect: dest[0] = mp_read_byref_lv_point_t(data->drag_throw_vect); break; // converting from lv_point_t;
            case MP_QSTR_act_obj: dest[0] = lv_to_mp((void*)data->act_obj); break; // converting from lv_obj_t *;
            case MP_QSTR_last_obj: dest[0] = lv_to_mp((void*)data->last_obj); break; // converting from lv_obj_t *;
            case MP_QSTR_last_pressed: dest[0] = lv_to_mp((void*)data->last_pressed); break; // converting from lv_obj_t *;
            case MP_QSTR_gesture_dir: dest[0] = mp_obj_new_int_from_uint(data->gesture_dir); break; // converting from lv_gesture_dir_t;
            case MP_QSTR_gesture_sum: dest[0] = mp_read_byref_lv_point_t(data->gesture_sum); break; // converting from lv_point_t;
            case MP_QSTR_drag_limit_out: dest[0] = mp_obj_new_int_from_uint(data->drag_limit_out); break; // converting from uint8_t;
            case MP_QSTR_drag_in_prog: dest[0] = mp_obj_new_int_from_uint(data->drag_in_prog); break; // converting from uint8_t;
            case MP_QSTR_drag_dir: dest[0] = mp_obj_new_int_from_uint(data->drag_dir); break; // converting from lv_drag_dir_t;
            case MP_QSTR_gesture_sent: dest[0] = mp_obj_new_int_from_uint(data->gesture_sent); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_act_point: data->act_point = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_last_point: data->last_point = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_vect: data->vect = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_drag_sum: data->drag_sum = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_drag_throw_vect: data->drag_throw_vect = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_act_obj: data->act_obj = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_last_obj: data->last_obj = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_last_pressed: data->last_pressed = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_gesture_dir: data->gesture_dir = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_gesture_dir_t;
                case MP_QSTR_gesture_sum: data->gesture_sum = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_drag_limit_out: data->drag_limit_out = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_drag_in_prog: data->drag_in_prog = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_drag_dir: data->drag_dir = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_drag_dir_t;
                case MP_QSTR_gesture_sent: data->gesture_sent = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_indev_proc_types_pointer_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_indev_proc_types_pointer_t");
}

STATIC const mp_obj_dict_t mp_lv_indev_proc_types_pointer_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_indev_proc_types_pointer_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_indev_proc_types_pointer_t,
    .print = mp_lv_indev_proc_types_pointer_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_indev_proc_types_pointer_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_indev_proc_types_pointer_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_indev_proc_types_pointer_t_type()
{
    return &mp_lv_indev_proc_types_pointer_t_type;
}
    
typedef __typeof__( ((lv_indev_proc_types_t*)(0))->keypad ) lv_indev_proc_types_keypad_t;

/*
 * Struct lv_indev_proc_types_keypad_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_indev_proc_types_keypad_t_type();

STATIC inline lv_indev_proc_types_keypad_t* mp_write_ptr_lv_indev_proc_types_keypad_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_indev_proc_types_keypad_t_type()));
    return (lv_indev_proc_types_keypad_t*)self->data;
}

#define mp_write_lv_indev_proc_types_keypad_t(struct_obj) *mp_write_ptr_lv_indev_proc_types_keypad_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_indev_proc_types_keypad_t(lv_indev_proc_types_keypad_t *field)
{
    return lv_to_mp_struct(get_mp_lv_indev_proc_types_keypad_t_type(), (void*)field);
}

#define mp_read_lv_indev_proc_types_keypad_t(field) mp_read_ptr_lv_indev_proc_types_keypad_t(copy_buffer(&field, sizeof(lv_indev_proc_types_keypad_t)))
#define mp_read_byref_lv_indev_proc_types_keypad_t(field) mp_read_ptr_lv_indev_proc_types_keypad_t(&field)

STATIC void mp_lv_indev_proc_types_keypad_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_indev_proc_types_keypad_t *data = (lv_indev_proc_types_keypad_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_last_state: dest[0] = mp_obj_new_int_from_uint(data->last_state); break; // converting from lv_indev_state_t;
            case MP_QSTR_last_key: dest[0] = mp_obj_new_int_from_uint(data->last_key); break; // converting from uint32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_last_state: data->last_state = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_indev_state_t;
                case MP_QSTR_last_key: data->last_key = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_indev_proc_types_keypad_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_indev_proc_types_keypad_t");
}

STATIC const mp_obj_dict_t mp_lv_indev_proc_types_keypad_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_indev_proc_types_keypad_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_indev_proc_types_keypad_t,
    .print = mp_lv_indev_proc_types_keypad_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_indev_proc_types_keypad_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_indev_proc_types_keypad_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_indev_proc_types_keypad_t_type()
{
    return &mp_lv_indev_proc_types_keypad_t_type;
}
    

/*
 * Struct lv_indev_proc_types_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_indev_proc_types_t_type();

STATIC inline lv_indev_proc_types_t* mp_write_ptr_lv_indev_proc_types_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_indev_proc_types_t_type()));
    return (lv_indev_proc_types_t*)self->data;
}

#define mp_write_lv_indev_proc_types_t(struct_obj) *mp_write_ptr_lv_indev_proc_types_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_indev_proc_types_t(lv_indev_proc_types_t *field)
{
    return lv_to_mp_struct(get_mp_lv_indev_proc_types_t_type(), (void*)field);
}

#define mp_read_lv_indev_proc_types_t(field) mp_read_ptr_lv_indev_proc_types_t(copy_buffer(&field, sizeof(lv_indev_proc_types_t)))
#define mp_read_byref_lv_indev_proc_types_t(field) mp_read_ptr_lv_indev_proc_types_t(&field)

STATIC void mp_lv_indev_proc_types_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_indev_proc_types_t *data = (lv_indev_proc_types_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_pointer: dest[0] = mp_read_byref_lv_indev_proc_types_pointer_t(data->pointer); break; // converting from lv_indev_proc_types_pointer_t;
            case MP_QSTR_keypad: dest[0] = mp_read_byref_lv_indev_proc_types_keypad_t(data->keypad); break; // converting from lv_indev_proc_types_keypad_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_pointer: data->pointer = mp_write_lv_indev_proc_types_pointer_t(dest[1]); break; // converting to lv_indev_proc_types_pointer_t;
                case MP_QSTR_keypad: data->keypad = mp_write_lv_indev_proc_types_keypad_t(dest[1]); break; // converting to lv_indev_proc_types_keypad_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_indev_proc_types_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_indev_proc_types_t");
}

STATIC const mp_obj_dict_t mp_lv_indev_proc_types_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_indev_proc_types_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_indev_proc_types_t,
    .print = mp_lv_indev_proc_types_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_indev_proc_types_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_indev_proc_types_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_indev_proc_types_t_type()
{
    return &mp_lv_indev_proc_types_t_type;
}
    

/*
 * Struct lv_indev_proc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_indev_proc_t_type();

STATIC inline lv_indev_proc_t* mp_write_ptr_lv_indev_proc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_indev_proc_t_type()));
    return (lv_indev_proc_t*)self->data;
}

#define mp_write_lv_indev_proc_t(struct_obj) *mp_write_ptr_lv_indev_proc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_indev_proc_t(lv_indev_proc_t *field)
{
    return lv_to_mp_struct(get_mp_lv_indev_proc_t_type(), (void*)field);
}

#define mp_read_lv_indev_proc_t(field) mp_read_ptr_lv_indev_proc_t(copy_buffer(&field, sizeof(lv_indev_proc_t)))
#define mp_read_byref_lv_indev_proc_t(field) mp_read_ptr_lv_indev_proc_t(&field)

STATIC void mp_lv_indev_proc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_indev_proc_t *data = (lv_indev_proc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_state: dest[0] = mp_obj_new_int_from_uint(data->state); break; // converting from lv_indev_state_t;
            case MP_QSTR_types: dest[0] = mp_read_byref_lv_indev_proc_types_t(data->types); break; // converting from lv_indev_proc_types_t;
            case MP_QSTR_pr_timestamp: dest[0] = mp_obj_new_int_from_uint(data->pr_timestamp); break; // converting from uint32_t;
            case MP_QSTR_longpr_rep_timestamp: dest[0] = mp_obj_new_int_from_uint(data->longpr_rep_timestamp); break; // converting from uint32_t;
            case MP_QSTR_long_pr_sent: dest[0] = mp_obj_new_int_from_uint(data->long_pr_sent); break; // converting from uint8_t;
            case MP_QSTR_reset_query: dest[0] = mp_obj_new_int_from_uint(data->reset_query); break; // converting from uint8_t;
            case MP_QSTR_disabled: dest[0] = mp_obj_new_int_from_uint(data->disabled); break; // converting from uint8_t;
            case MP_QSTR_wait_until_release: dest[0] = mp_obj_new_int_from_uint(data->wait_until_release); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_state: data->state = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_indev_state_t;
                case MP_QSTR_types: data->types = mp_write_lv_indev_proc_types_t(dest[1]); break; // converting to lv_indev_proc_types_t;
                case MP_QSTR_pr_timestamp: data->pr_timestamp = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_longpr_rep_timestamp: data->longpr_rep_timestamp = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_long_pr_sent: data->long_pr_sent = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_reset_query: data->reset_query = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_disabled: data->disabled = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_wait_until_release: data->wait_until_release = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_indev_proc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_indev_proc_t");
}

STATIC const mp_obj_dict_t mp_lv_indev_proc_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_indev_proc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_indev_proc_t,
    .print = mp_lv_indev_proc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_indev_proc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_indev_proc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_indev_proc_t_type()
{
    return &mp_lv_indev_proc_t_type;
}
    
#define funcptr_lv_group_focus_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_group_focus_cb_t(struct _lv_group_t *)
 */
 
STATIC mp_obj_t mp_funcptr_lv_group_focus_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_group_t *arg0 = mp_to_ptr(mp_args[0]);
    ((void (*)(struct _lv_group_t *))lv_func_ptr)(arg0);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_group_focus_cb_t_obj, 1, mp_funcptr_lv_group_focus_cb_t, funcptr_lv_group_focus_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_group_focus_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_group_focus_cb_t_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_group_t_focus_cb_callback(struct _lv_group_t *);

/*
 * Struct lv_group_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_group_t_type();

STATIC inline lv_group_t* mp_write_ptr_lv_group_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_group_t_type()));
    return (lv_group_t*)self->data;
}

#define mp_write_lv_group_t(struct_obj) *mp_write_ptr_lv_group_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_group_t(lv_group_t *field)
{
    return lv_to_mp_struct(get_mp_lv_group_t_type(), (void*)field);
}

#define mp_read_lv_group_t(field) mp_read_ptr_lv_group_t(copy_buffer(&field, sizeof(lv_group_t)))
#define mp_read_byref_lv_group_t(field) mp_read_ptr_lv_group_t(&field)

STATIC void mp_lv_group_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_group_t *data = (lv_group_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_obj_ll: dest[0] = mp_read_byref_lv_ll_t(data->obj_ll); break; // converting from lv_ll_t;
            case MP_QSTR_obj_focus: dest[0] = ptr_to_mp((void*)data->obj_focus); break; // converting from lv_obj_t **;
            case MP_QSTR_focus_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_group_focus_cb_t_obj, data->focus_cb, lv_group_t_focus_cb_callback ,MP_QSTR_lv_group_t_focus_cb, data->user_data); break; // converting from callback lv_group_focus_cb_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp(data->user_data); break; // converting from lv_group_user_data_t;
            case MP_QSTR_frozen: dest[0] = mp_obj_new_int_from_uint(data->frozen); break; // converting from uint8_t;
            case MP_QSTR_editing: dest[0] = mp_obj_new_int_from_uint(data->editing); break; // converting from uint8_t;
            case MP_QSTR_click_focus: dest[0] = mp_obj_new_int_from_uint(data->click_focus); break; // converting from uint8_t;
            case MP_QSTR_refocus_policy: dest[0] = mp_obj_new_int_from_uint(data->refocus_policy); break; // converting from uint8_t;
            case MP_QSTR_wrap: dest[0] = mp_obj_new_int_from_uint(data->wrap); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_obj_ll: data->obj_ll = mp_write_lv_ll_t(dest[1]); break; // converting to lv_ll_t;
                case MP_QSTR_obj_focus: data->obj_focus = (void*)mp_to_ptr(dest[1]); break; // converting to lv_obj_t **;
                case MP_QSTR_focus_cb: data->focus_cb = mp_lv_callback(dest[1], lv_group_t_focus_cb_callback ,MP_QSTR_lv_group_t_focus_cb, &data->user_data); break; // converting to callback lv_group_focus_cb_t;
                case MP_QSTR_user_data: data->user_data = mp_to_ptr(dest[1]); break; // converting to lv_group_user_data_t;
                case MP_QSTR_frozen: data->frozen = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_editing: data->editing = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_click_focus: data->click_focus = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_refocus_policy: data->refocus_policy = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_wrap: data->wrap = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_group_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_group_t");
}

STATIC const mp_obj_dict_t mp_lv_group_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_group_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_group_t,
    .print = mp_lv_group_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_group_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_group_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_group_t_type()
{
    return &mp_lv_group_t_type;
}
    

/*
 * Struct lv_indev_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_indev_t_type();

STATIC inline lv_indev_t* mp_write_ptr_lv_indev_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_indev_t_type()));
    return (lv_indev_t*)self->data;
}

#define mp_write_lv_indev_t(struct_obj) *mp_write_ptr_lv_indev_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_indev_t(lv_indev_t *field)
{
    return lv_to_mp_struct(get_mp_lv_indev_t_type(), (void*)field);
}

#define mp_read_lv_indev_t(field) mp_read_ptr_lv_indev_t(copy_buffer(&field, sizeof(lv_indev_t)))
#define mp_read_byref_lv_indev_t(field) mp_read_ptr_lv_indev_t(&field)

STATIC void mp_lv_indev_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_indev_t *data = (lv_indev_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_driver: dest[0] = mp_read_byref_lv_indev_drv_t(data->driver); break; // converting from lv_indev_drv_t;
            case MP_QSTR_proc: dest[0] = mp_read_byref_lv_indev_proc_t(data->proc); break; // converting from lv_indev_proc_t;
            case MP_QSTR_cursor: dest[0] = lv_to_mp((void*)data->cursor); break; // converting from lv_obj_t *;
            case MP_QSTR_group: dest[0] = mp_read_ptr_lv_group_t((void*)data->group); break; // converting from lv_group_t *;
            case MP_QSTR_btn_points: dest[0] = mp_read_ptr_lv_point_t((void*)data->btn_points); break; // converting from lv_point_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_driver: data->driver = mp_write_lv_indev_drv_t(dest[1]); break; // converting to lv_indev_drv_t;
                case MP_QSTR_proc: data->proc = mp_write_lv_indev_proc_t(dest[1]); break; // converting to lv_indev_proc_t;
                case MP_QSTR_cursor: data->cursor = (void*)mp_to_lv(dest[1]); break; // converting to lv_obj_t *;
                case MP_QSTR_group: data->group = (void*)mp_write_ptr_lv_group_t(dest[1]); break; // converting to lv_group_t *;
                case MP_QSTR_btn_points: data->btn_points = (void*)mp_write_ptr_lv_point_t(dest[1]); break; // converting to lv_point_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_indev_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_indev_t");
}

STATIC const mp_obj_dict_t mp_lv_indev_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_indev_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_indev_t,
    .print = mp_lv_indev_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_indev_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_indev_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_indev_t_type()
{
    return &mp_lv_indev_t_type;
}
    
#define funcptr_lv_draw_mask_xcb_t NULL


/*
 * lvgl extension definition for:
 * lv_draw_mask_res_t lv_draw_mask_xcb_t(lv_opa_t *mask_buf, lv_coord_t abs_x, lv_coord_t abs_y, lv_coord_t len, void *p)
 */
 
STATIC mp_obj_t mp_funcptr_lv_draw_mask_xcb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_opa_t *mask_buf = mp_to_ptr(mp_args[0]);
    lv_coord_t abs_x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t abs_y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t len = (int16_t)mp_obj_get_int(mp_args[3]);
    void *p = mp_to_ptr(mp_args[4]);
    lv_draw_mask_res_t _res = ((lv_draw_mask_res_t (*)(lv_opa_t *, lv_coord_t, lv_coord_t, lv_coord_t, void *))lv_func_ptr)(mask_buf, abs_x, abs_y, len, p);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_draw_mask_xcb_t_obj, 5, mp_funcptr_lv_draw_mask_xcb_t, funcptr_lv_draw_mask_xcb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_draw_mask_xcb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_draw_mask_xcb_t_obj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_draw_mask_common_dsc_t_cb_callback'
 * lv_draw_mask_xcb_t cb
 */
    

/*
 * Struct lv_draw_mask_common_dsc_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_common_dsc_t_type();

STATIC inline lv_draw_mask_common_dsc_t* mp_write_ptr_lv_draw_mask_common_dsc_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_common_dsc_t_type()));
    return (lv_draw_mask_common_dsc_t*)self->data;
}

#define mp_write_lv_draw_mask_common_dsc_t(struct_obj) *mp_write_ptr_lv_draw_mask_common_dsc_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_common_dsc_t(lv_draw_mask_common_dsc_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_common_dsc_t_type(), (void*)field);
}

#define mp_read_lv_draw_mask_common_dsc_t(field) mp_read_ptr_lv_draw_mask_common_dsc_t(copy_buffer(&field, sizeof(lv_draw_mask_common_dsc_t)))
#define mp_read_byref_lv_draw_mask_common_dsc_t(field) mp_read_ptr_lv_draw_mask_common_dsc_t(&field)

STATIC void mp_lv_draw_mask_common_dsc_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_mask_common_dsc_t *data = (lv_draw_mask_common_dsc_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_draw_mask_xcb_t_obj, data->cb, NULL ,MP_QSTR_lv_draw_mask_common_dsc_t_cb, NULL); break; // converting from callback lv_draw_mask_xcb_t;
            case MP_QSTR_type: dest[0] = mp_obj_new_int_from_uint(data->type); break; // converting from lv_draw_mask_type_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_cb: data->cb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_draw_mask_common_dsc_t_cb, NULL); break; // converting to callback lv_draw_mask_xcb_t;
                case MP_QSTR_type: data->type = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_draw_mask_type_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_common_dsc_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_common_dsc_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_common_dsc_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_mask_common_dsc_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_mask_common_dsc_t,
    .print = mp_lv_draw_mask_common_dsc_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_mask_common_dsc_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_mask_common_dsc_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_common_dsc_t_type()
{
    return &mp_lv_draw_mask_common_dsc_t_type;
}
    
typedef __typeof__( ((lv_draw_mask_line_param_t*)(0))->cfg ) lv_draw_mask_line_param_cfg_t;

/*
 * Struct lv_draw_mask_line_param_cfg_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_line_param_cfg_t_type();

STATIC inline lv_draw_mask_line_param_cfg_t* mp_write_ptr_lv_draw_mask_line_param_cfg_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_line_param_cfg_t_type()));
    return (lv_draw_mask_line_param_cfg_t*)self->data;
}

#define mp_write_lv_draw_mask_line_param_cfg_t(struct_obj) *mp_write_ptr_lv_draw_mask_line_param_cfg_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_line_param_cfg_t(lv_draw_mask_line_param_cfg_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_line_param_cfg_t_type(), (void*)field);
}

#define mp_read_lv_draw_mask_line_param_cfg_t(field) mp_read_ptr_lv_draw_mask_line_param_cfg_t(copy_buffer(&field, sizeof(lv_draw_mask_line_param_cfg_t)))
#define mp_read_byref_lv_draw_mask_line_param_cfg_t(field) mp_read_ptr_lv_draw_mask_line_param_cfg_t(&field)

STATIC void mp_lv_draw_mask_line_param_cfg_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_mask_line_param_cfg_t *data = (lv_draw_mask_line_param_cfg_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_p1: dest[0] = mp_read_byref_lv_point_t(data->p1); break; // converting from lv_point_t;
            case MP_QSTR_p2: dest[0] = mp_read_byref_lv_point_t(data->p2); break; // converting from lv_point_t;
            case MP_QSTR_side: dest[0] = mp_obj_new_int_from_uint(data->side); break; // converting from lv_draw_mask_line_side_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_p1: data->p1 = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_p2: data->p2 = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_side: data->side = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_draw_mask_line_side_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_line_param_cfg_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_line_param_cfg_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_line_param_cfg_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_mask_line_param_cfg_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_mask_line_param_cfg_t,
    .print = mp_lv_draw_mask_line_param_cfg_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_mask_line_param_cfg_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_mask_line_param_cfg_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_line_param_cfg_t_type()
{
    return &mp_lv_draw_mask_line_param_cfg_t_type;
}
    

/*
 * Struct lv_draw_mask_line_param_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_line_param_t_type();

STATIC inline lv_draw_mask_line_param_t* mp_write_ptr_lv_draw_mask_line_param_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_line_param_t_type()));
    return (lv_draw_mask_line_param_t*)self->data;
}

#define mp_write_lv_draw_mask_line_param_t(struct_obj) *mp_write_ptr_lv_draw_mask_line_param_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_line_param_t(lv_draw_mask_line_param_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_line_param_t_type(), (void*)field);
}

#define mp_read_lv_draw_mask_line_param_t(field) mp_read_ptr_lv_draw_mask_line_param_t(copy_buffer(&field, sizeof(lv_draw_mask_line_param_t)))
#define mp_read_byref_lv_draw_mask_line_param_t(field) mp_read_ptr_lv_draw_mask_line_param_t(&field)

STATIC void mp_lv_draw_mask_line_param_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_mask_line_param_t *data = (lv_draw_mask_line_param_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_dsc: dest[0] = mp_read_byref_lv_draw_mask_common_dsc_t(data->dsc); break; // converting from lv_draw_mask_common_dsc_t;
            case MP_QSTR_cfg: dest[0] = mp_read_byref_lv_draw_mask_line_param_cfg_t(data->cfg); break; // converting from lv_draw_mask_line_param_cfg_t;
            case MP_QSTR_origo: dest[0] = mp_read_byref_lv_point_t(data->origo); break; // converting from lv_point_t;
            case MP_QSTR_xy_steep: dest[0] = mp_obj_new_int(data->xy_steep); break; // converting from int32_t;
            case MP_QSTR_yx_steep: dest[0] = mp_obj_new_int(data->yx_steep); break; // converting from int32_t;
            case MP_QSTR_steep: dest[0] = mp_obj_new_int(data->steep); break; // converting from int32_t;
            case MP_QSTR_spx: dest[0] = mp_obj_new_int(data->spx); break; // converting from int32_t;
            case MP_QSTR_flat: dest[0] = mp_obj_new_int_from_uint(data->flat); break; // converting from uint8_t;
            case MP_QSTR_inv: dest[0] = mp_obj_new_int_from_uint(data->inv); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_dsc: data->dsc = mp_write_lv_draw_mask_common_dsc_t(dest[1]); break; // converting to lv_draw_mask_common_dsc_t;
                case MP_QSTR_cfg: data->cfg = mp_write_lv_draw_mask_line_param_cfg_t(dest[1]); break; // converting to lv_draw_mask_line_param_cfg_t;
                case MP_QSTR_origo: data->origo = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_xy_steep: data->xy_steep = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_yx_steep: data->yx_steep = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_steep: data->steep = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_spx: data->spx = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_flat: data->flat = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                case MP_QSTR_inv: data->inv = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_line_param_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_line_param_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_line_param_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_mask_line_param_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_mask_line_param_t,
    .print = mp_lv_draw_mask_line_param_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_mask_line_param_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_mask_line_param_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_line_param_t_type()
{
    return &mp_lv_draw_mask_line_param_t_type;
}
    
typedef __typeof__( ((lv_draw_mask_angle_param_t*)(0))->cfg ) lv_draw_mask_angle_param_cfg_t;

/*
 * Struct lv_draw_mask_angle_param_cfg_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_angle_param_cfg_t_type();

STATIC inline lv_draw_mask_angle_param_cfg_t* mp_write_ptr_lv_draw_mask_angle_param_cfg_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_angle_param_cfg_t_type()));
    return (lv_draw_mask_angle_param_cfg_t*)self->data;
}

#define mp_write_lv_draw_mask_angle_param_cfg_t(struct_obj) *mp_write_ptr_lv_draw_mask_angle_param_cfg_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_angle_param_cfg_t(lv_draw_mask_angle_param_cfg_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_angle_param_cfg_t_type(), (void*)field);
}

#define mp_read_lv_draw_mask_angle_param_cfg_t(field) mp_read_ptr_lv_draw_mask_angle_param_cfg_t(copy_buffer(&field, sizeof(lv_draw_mask_angle_param_cfg_t)))
#define mp_read_byref_lv_draw_mask_angle_param_cfg_t(field) mp_read_ptr_lv_draw_mask_angle_param_cfg_t(&field)

STATIC void mp_lv_draw_mask_angle_param_cfg_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_mask_angle_param_cfg_t *data = (lv_draw_mask_angle_param_cfg_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_vertex_p: dest[0] = mp_read_byref_lv_point_t(data->vertex_p); break; // converting from lv_point_t;
            case MP_QSTR_start_angle: dest[0] = mp_obj_new_int(data->start_angle); break; // converting from lv_coord_t;
            case MP_QSTR_end_angle: dest[0] = mp_obj_new_int(data->end_angle); break; // converting from lv_coord_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_vertex_p: data->vertex_p = mp_write_lv_point_t(dest[1]); break; // converting to lv_point_t;
                case MP_QSTR_start_angle: data->start_angle = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_end_angle: data->end_angle = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_angle_param_cfg_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_angle_param_cfg_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_angle_param_cfg_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_mask_angle_param_cfg_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_mask_angle_param_cfg_t,
    .print = mp_lv_draw_mask_angle_param_cfg_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_mask_angle_param_cfg_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_mask_angle_param_cfg_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_angle_param_cfg_t_type()
{
    return &mp_lv_draw_mask_angle_param_cfg_t_type;
}
    

/*
 * Struct lv_draw_mask_angle_param_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_angle_param_t_type();

STATIC inline lv_draw_mask_angle_param_t* mp_write_ptr_lv_draw_mask_angle_param_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_angle_param_t_type()));
    return (lv_draw_mask_angle_param_t*)self->data;
}

#define mp_write_lv_draw_mask_angle_param_t(struct_obj) *mp_write_ptr_lv_draw_mask_angle_param_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_angle_param_t(lv_draw_mask_angle_param_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_angle_param_t_type(), (void*)field);
}

#define mp_read_lv_draw_mask_angle_param_t(field) mp_read_ptr_lv_draw_mask_angle_param_t(copy_buffer(&field, sizeof(lv_draw_mask_angle_param_t)))
#define mp_read_byref_lv_draw_mask_angle_param_t(field) mp_read_ptr_lv_draw_mask_angle_param_t(&field)

STATIC void mp_lv_draw_mask_angle_param_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_mask_angle_param_t *data = (lv_draw_mask_angle_param_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_dsc: dest[0] = mp_read_byref_lv_draw_mask_common_dsc_t(data->dsc); break; // converting from lv_draw_mask_common_dsc_t;
            case MP_QSTR_cfg: dest[0] = mp_read_byref_lv_draw_mask_angle_param_cfg_t(data->cfg); break; // converting from lv_draw_mask_angle_param_cfg_t;
            case MP_QSTR_start_line: dest[0] = mp_read_byref_lv_draw_mask_line_param_t(data->start_line); break; // converting from lv_draw_mask_line_param_t;
            case MP_QSTR_end_line: dest[0] = mp_read_byref_lv_draw_mask_line_param_t(data->end_line); break; // converting from lv_draw_mask_line_param_t;
            case MP_QSTR_delta_deg: dest[0] = mp_obj_new_int_from_uint(data->delta_deg); break; // converting from uint16_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_dsc: data->dsc = mp_write_lv_draw_mask_common_dsc_t(dest[1]); break; // converting to lv_draw_mask_common_dsc_t;
                case MP_QSTR_cfg: data->cfg = mp_write_lv_draw_mask_angle_param_cfg_t(dest[1]); break; // converting to lv_draw_mask_angle_param_cfg_t;
                case MP_QSTR_start_line: data->start_line = mp_write_lv_draw_mask_line_param_t(dest[1]); break; // converting to lv_draw_mask_line_param_t;
                case MP_QSTR_end_line: data->end_line = mp_write_lv_draw_mask_line_param_t(dest[1]); break; // converting to lv_draw_mask_line_param_t;
                case MP_QSTR_delta_deg: data->delta_deg = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_angle_param_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_angle_param_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_angle_param_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_mask_angle_param_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_mask_angle_param_t,
    .print = mp_lv_draw_mask_angle_param_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_mask_angle_param_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_mask_angle_param_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_angle_param_t_type()
{
    return &mp_lv_draw_mask_angle_param_t_type;
}
    
typedef __typeof__( ((lv_draw_mask_radius_param_t*)(0))->cfg ) lv_draw_mask_radius_param_cfg_t;

/*
 * Struct lv_draw_mask_radius_param_cfg_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_radius_param_cfg_t_type();

STATIC inline lv_draw_mask_radius_param_cfg_t* mp_write_ptr_lv_draw_mask_radius_param_cfg_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_radius_param_cfg_t_type()));
    return (lv_draw_mask_radius_param_cfg_t*)self->data;
}

#define mp_write_lv_draw_mask_radius_param_cfg_t(struct_obj) *mp_write_ptr_lv_draw_mask_radius_param_cfg_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_radius_param_cfg_t(lv_draw_mask_radius_param_cfg_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_radius_param_cfg_t_type(), (void*)field);
}

#define mp_read_lv_draw_mask_radius_param_cfg_t(field) mp_read_ptr_lv_draw_mask_radius_param_cfg_t(copy_buffer(&field, sizeof(lv_draw_mask_radius_param_cfg_t)))
#define mp_read_byref_lv_draw_mask_radius_param_cfg_t(field) mp_read_ptr_lv_draw_mask_radius_param_cfg_t(&field)

STATIC void mp_lv_draw_mask_radius_param_cfg_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_mask_radius_param_cfg_t *data = (lv_draw_mask_radius_param_cfg_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_rect: dest[0] = mp_read_byref_lv_area_t(data->rect); break; // converting from lv_area_t;
            case MP_QSTR_radius: dest[0] = mp_obj_new_int(data->radius); break; // converting from lv_coord_t;
            case MP_QSTR_outer: dest[0] = mp_obj_new_int_from_uint(data->outer); break; // converting from uint8_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_rect: data->rect = mp_write_lv_area_t(dest[1]); break; // converting to lv_area_t;
                case MP_QSTR_radius: data->radius = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_outer: data->outer = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to uint8_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_radius_param_cfg_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_radius_param_cfg_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_radius_param_cfg_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_mask_radius_param_cfg_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_mask_radius_param_cfg_t,
    .print = mp_lv_draw_mask_radius_param_cfg_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_mask_radius_param_cfg_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_mask_radius_param_cfg_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_radius_param_cfg_t_type()
{
    return &mp_lv_draw_mask_radius_param_cfg_t_type;
}
    

/*
 * Struct lv_sqrt_res_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_sqrt_res_t_type();

STATIC inline lv_sqrt_res_t* mp_write_ptr_lv_sqrt_res_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_sqrt_res_t_type()));
    return (lv_sqrt_res_t*)self->data;
}

#define mp_write_lv_sqrt_res_t(struct_obj) *mp_write_ptr_lv_sqrt_res_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_sqrt_res_t(lv_sqrt_res_t *field)
{
    return lv_to_mp_struct(get_mp_lv_sqrt_res_t_type(), (void*)field);
}

#define mp_read_lv_sqrt_res_t(field) mp_read_ptr_lv_sqrt_res_t(copy_buffer(&field, sizeof(lv_sqrt_res_t)))
#define mp_read_byref_lv_sqrt_res_t(field) mp_read_ptr_lv_sqrt_res_t(&field)

STATIC void mp_lv_sqrt_res_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_sqrt_res_t *data = (lv_sqrt_res_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_i: dest[0] = mp_obj_new_int_from_uint(data->i); break; // converting from uint16_t;
            case MP_QSTR_f: dest[0] = mp_obj_new_int_from_uint(data->f); break; // converting from uint16_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_i: data->i = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_f: data->f = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_sqrt_res_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_sqrt_res_t");
}

STATIC const mp_obj_dict_t mp_lv_sqrt_res_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_sqrt_res_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_sqrt_res_t,
    .print = mp_lv_sqrt_res_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_sqrt_res_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_sqrt_res_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_sqrt_res_t_type()
{
    return &mp_lv_sqrt_res_t_type;
}
    

/*
 * Struct lv_draw_mask_radius_param_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_radius_param_t_type();

STATIC inline lv_draw_mask_radius_param_t* mp_write_ptr_lv_draw_mask_radius_param_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_radius_param_t_type()));
    return (lv_draw_mask_radius_param_t*)self->data;
}

#define mp_write_lv_draw_mask_radius_param_t(struct_obj) *mp_write_ptr_lv_draw_mask_radius_param_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_radius_param_t(lv_draw_mask_radius_param_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_radius_param_t_type(), (void*)field);
}

#define mp_read_lv_draw_mask_radius_param_t(field) mp_read_ptr_lv_draw_mask_radius_param_t(copy_buffer(&field, sizeof(lv_draw_mask_radius_param_t)))
#define mp_read_byref_lv_draw_mask_radius_param_t(field) mp_read_ptr_lv_draw_mask_radius_param_t(&field)

STATIC void mp_lv_draw_mask_radius_param_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_mask_radius_param_t *data = (lv_draw_mask_radius_param_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_dsc: dest[0] = mp_read_byref_lv_draw_mask_common_dsc_t(data->dsc); break; // converting from lv_draw_mask_common_dsc_t;
            case MP_QSTR_cfg: dest[0] = mp_read_byref_lv_draw_mask_radius_param_cfg_t(data->cfg); break; // converting from lv_draw_mask_radius_param_cfg_t;
            case MP_QSTR_y_prev: dest[0] = mp_obj_new_int(data->y_prev); break; // converting from int32_t;
            case MP_QSTR_y_prev_x: dest[0] = mp_read_byref_lv_sqrt_res_t(data->y_prev_x); break; // converting from lv_sqrt_res_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_dsc: data->dsc = mp_write_lv_draw_mask_common_dsc_t(dest[1]); break; // converting to lv_draw_mask_common_dsc_t;
                case MP_QSTR_cfg: data->cfg = mp_write_lv_draw_mask_radius_param_cfg_t(dest[1]); break; // converting to lv_draw_mask_radius_param_cfg_t;
                case MP_QSTR_y_prev: data->y_prev = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_y_prev_x: data->y_prev_x = mp_write_lv_sqrt_res_t(dest[1]); break; // converting to lv_sqrt_res_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_radius_param_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_radius_param_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_radius_param_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_mask_radius_param_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_mask_radius_param_t,
    .print = mp_lv_draw_mask_radius_param_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_mask_radius_param_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_mask_radius_param_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_radius_param_t_type()
{
    return &mp_lv_draw_mask_radius_param_t_type;
}
    
typedef __typeof__( ((lv_draw_mask_fade_param_t*)(0))->cfg ) lv_draw_mask_fade_param_cfg_t;

/*
 * Struct lv_draw_mask_fade_param_cfg_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_fade_param_cfg_t_type();

STATIC inline lv_draw_mask_fade_param_cfg_t* mp_write_ptr_lv_draw_mask_fade_param_cfg_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_fade_param_cfg_t_type()));
    return (lv_draw_mask_fade_param_cfg_t*)self->data;
}

#define mp_write_lv_draw_mask_fade_param_cfg_t(struct_obj) *mp_write_ptr_lv_draw_mask_fade_param_cfg_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_fade_param_cfg_t(lv_draw_mask_fade_param_cfg_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_fade_param_cfg_t_type(), (void*)field);
}

#define mp_read_lv_draw_mask_fade_param_cfg_t(field) mp_read_ptr_lv_draw_mask_fade_param_cfg_t(copy_buffer(&field, sizeof(lv_draw_mask_fade_param_cfg_t)))
#define mp_read_byref_lv_draw_mask_fade_param_cfg_t(field) mp_read_ptr_lv_draw_mask_fade_param_cfg_t(&field)

STATIC void mp_lv_draw_mask_fade_param_cfg_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_mask_fade_param_cfg_t *data = (lv_draw_mask_fade_param_cfg_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_coords: dest[0] = mp_read_byref_lv_area_t(data->coords); break; // converting from lv_area_t;
            case MP_QSTR_y_top: dest[0] = mp_obj_new_int(data->y_top); break; // converting from lv_coord_t;
            case MP_QSTR_y_bottom: dest[0] = mp_obj_new_int(data->y_bottom); break; // converting from lv_coord_t;
            case MP_QSTR_opa_top: dest[0] = mp_obj_new_int_from_uint(data->opa_top); break; // converting from lv_opa_t;
            case MP_QSTR_opa_bottom: dest[0] = mp_obj_new_int_from_uint(data->opa_bottom); break; // converting from lv_opa_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_coords: data->coords = mp_write_lv_area_t(dest[1]); break; // converting to lv_area_t;
                case MP_QSTR_y_top: data->y_top = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_y_bottom: data->y_bottom = (int16_t)mp_obj_get_int(dest[1]); break; // converting to lv_coord_t;
                case MP_QSTR_opa_top: data->opa_top = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                case MP_QSTR_opa_bottom: data->opa_bottom = (uint8_t)mp_obj_get_int(dest[1]); break; // converting to lv_opa_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_fade_param_cfg_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_fade_param_cfg_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_fade_param_cfg_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_mask_fade_param_cfg_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_mask_fade_param_cfg_t,
    .print = mp_lv_draw_mask_fade_param_cfg_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_mask_fade_param_cfg_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_mask_fade_param_cfg_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_fade_param_cfg_t_type()
{
    return &mp_lv_draw_mask_fade_param_cfg_t_type;
}
    

/*
 * Struct lv_draw_mask_fade_param_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_fade_param_t_type();

STATIC inline lv_draw_mask_fade_param_t* mp_write_ptr_lv_draw_mask_fade_param_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_fade_param_t_type()));
    return (lv_draw_mask_fade_param_t*)self->data;
}

#define mp_write_lv_draw_mask_fade_param_t(struct_obj) *mp_write_ptr_lv_draw_mask_fade_param_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_fade_param_t(lv_draw_mask_fade_param_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_fade_param_t_type(), (void*)field);
}

#define mp_read_lv_draw_mask_fade_param_t(field) mp_read_ptr_lv_draw_mask_fade_param_t(copy_buffer(&field, sizeof(lv_draw_mask_fade_param_t)))
#define mp_read_byref_lv_draw_mask_fade_param_t(field) mp_read_ptr_lv_draw_mask_fade_param_t(&field)

STATIC void mp_lv_draw_mask_fade_param_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_mask_fade_param_t *data = (lv_draw_mask_fade_param_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_dsc: dest[0] = mp_read_byref_lv_draw_mask_common_dsc_t(data->dsc); break; // converting from lv_draw_mask_common_dsc_t;
            case MP_QSTR_cfg: dest[0] = mp_read_byref_lv_draw_mask_fade_param_cfg_t(data->cfg); break; // converting from lv_draw_mask_fade_param_cfg_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_dsc: data->dsc = mp_write_lv_draw_mask_common_dsc_t(dest[1]); break; // converting to lv_draw_mask_common_dsc_t;
                case MP_QSTR_cfg: data->cfg = mp_write_lv_draw_mask_fade_param_cfg_t(dest[1]); break; // converting to lv_draw_mask_fade_param_cfg_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_fade_param_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_fade_param_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_fade_param_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_mask_fade_param_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_mask_fade_param_t,
    .print = mp_lv_draw_mask_fade_param_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_mask_fade_param_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_mask_fade_param_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_fade_param_t_type()
{
    return &mp_lv_draw_mask_fade_param_t_type;
}
    
typedef __typeof__( ((lv_draw_mask_map_param_t*)(0))->cfg ) lv_draw_mask_map_param_cfg_t;

/*
 * Struct lv_draw_mask_map_param_cfg_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_map_param_cfg_t_type();

STATIC inline lv_draw_mask_map_param_cfg_t* mp_write_ptr_lv_draw_mask_map_param_cfg_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_map_param_cfg_t_type()));
    return (lv_draw_mask_map_param_cfg_t*)self->data;
}

#define mp_write_lv_draw_mask_map_param_cfg_t(struct_obj) *mp_write_ptr_lv_draw_mask_map_param_cfg_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_map_param_cfg_t(lv_draw_mask_map_param_cfg_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_map_param_cfg_t_type(), (void*)field);
}

#define mp_read_lv_draw_mask_map_param_cfg_t(field) mp_read_ptr_lv_draw_mask_map_param_cfg_t(copy_buffer(&field, sizeof(lv_draw_mask_map_param_cfg_t)))
#define mp_read_byref_lv_draw_mask_map_param_cfg_t(field) mp_read_ptr_lv_draw_mask_map_param_cfg_t(&field)

STATIC void mp_lv_draw_mask_map_param_cfg_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_mask_map_param_cfg_t *data = (lv_draw_mask_map_param_cfg_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_coords: dest[0] = mp_read_byref_lv_area_t(data->coords); break; // converting from lv_area_t;
            case MP_QSTR_map: dest[0] = ptr_to_mp((void*)data->map); break; // converting from lv_opa_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_coords: data->coords = mp_write_lv_area_t(dest[1]); break; // converting to lv_area_t;
                case MP_QSTR_map: data->map = (void*)mp_to_ptr(dest[1]); break; // converting to lv_opa_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_map_param_cfg_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_map_param_cfg_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_map_param_cfg_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_mask_map_param_cfg_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_mask_map_param_cfg_t,
    .print = mp_lv_draw_mask_map_param_cfg_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_mask_map_param_cfg_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_mask_map_param_cfg_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_map_param_cfg_t_type()
{
    return &mp_lv_draw_mask_map_param_cfg_t_type;
}
    

/*
 * Struct lv_draw_mask_map_param_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_map_param_t_type();

STATIC inline lv_draw_mask_map_param_t* mp_write_ptr_lv_draw_mask_map_param_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_mask_map_param_t_type()));
    return (lv_draw_mask_map_param_t*)self->data;
}

#define mp_write_lv_draw_mask_map_param_t(struct_obj) *mp_write_ptr_lv_draw_mask_map_param_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_mask_map_param_t(lv_draw_mask_map_param_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_mask_map_param_t_type(), (void*)field);
}

#define mp_read_lv_draw_mask_map_param_t(field) mp_read_ptr_lv_draw_mask_map_param_t(copy_buffer(&field, sizeof(lv_draw_mask_map_param_t)))
#define mp_read_byref_lv_draw_mask_map_param_t(field) mp_read_ptr_lv_draw_mask_map_param_t(&field)

STATIC void mp_lv_draw_mask_map_param_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_mask_map_param_t *data = (lv_draw_mask_map_param_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_dsc: dest[0] = mp_read_byref_lv_draw_mask_common_dsc_t(data->dsc); break; // converting from lv_draw_mask_common_dsc_t;
            case MP_QSTR_cfg: dest[0] = mp_read_byref_lv_draw_mask_map_param_cfg_t(data->cfg); break; // converting from lv_draw_mask_map_param_cfg_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_dsc: data->dsc = mp_write_lv_draw_mask_common_dsc_t(dest[1]); break; // converting to lv_draw_mask_common_dsc_t;
                case MP_QSTR_cfg: data->cfg = mp_write_lv_draw_mask_map_param_cfg_t(dest[1]); break; // converting to lv_draw_mask_map_param_cfg_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_mask_map_param_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_mask_map_param_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_mask_map_param_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_mask_map_param_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_mask_map_param_t,
    .print = mp_lv_draw_mask_map_param_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_mask_map_param_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_mask_map_param_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_mask_map_param_t_type()
{
    return &mp_lv_draw_mask_map_param_t_type;
}
    
#define funcptr_ready_cb NULL


/*
 * lvgl extension definition for:
 * bool ready_cb(struct _lv_fs_drv_t *drv)
 */
 
STATIC mp_obj_t mp_funcptr_ready_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    bool _res = ((bool (*)(struct _lv_fs_drv_t *))lv_func_ptr)(drv);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_ready_cb_obj, 1, mp_funcptr_ready_cb, funcptr_ready_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_ready_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_ready_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC bool lv_fs_drv_t_ready_cb_callback(struct _lv_fs_drv_t *drv);
#define funcptr_open_cb NULL


/*
 * lvgl extension definition for:
 * lv_fs_res_t open_cb(struct _lv_fs_drv_t *drv, void *file_p, const char *path, lv_fs_mode_t mode)
 */
 
STATIC mp_obj_t mp_funcptr_open_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    void *file_p = mp_to_ptr(mp_args[1]);
    const char *path = (char*)convert_from_str(mp_args[2]);
    lv_fs_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[3]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(struct _lv_fs_drv_t *, void *, const char *, lv_fs_mode_t))lv_func_ptr)(drv, file_p, path, mode);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_open_cb_obj, 4, mp_funcptr_open_cb, funcptr_open_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_open_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_open_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_open_cb_callback(struct _lv_fs_drv_t *drv, void *file_p, const char *path, lv_fs_mode_t mode);
#define funcptr_close_cb NULL


/*
 * lvgl extension definition for:
 * lv_fs_res_t close_cb(struct _lv_fs_drv_t *drv, void *file_p)
 */
 
STATIC mp_obj_t mp_funcptr_close_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    void *file_p = mp_to_ptr(mp_args[1]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(struct _lv_fs_drv_t *, void *))lv_func_ptr)(drv, file_p);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_close_cb_obj, 2, mp_funcptr_close_cb, funcptr_close_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_close_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_close_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_close_cb_callback(struct _lv_fs_drv_t *drv, void *file_p);
#define funcptr_remove_cb NULL


/*
 * lvgl extension definition for:
 * lv_fs_res_t remove_cb(struct _lv_fs_drv_t *drv, const char *fn)
 */
 
STATIC mp_obj_t mp_funcptr_remove_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    const char *fn = (char*)convert_from_str(mp_args[1]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(struct _lv_fs_drv_t *, const char *))lv_func_ptr)(drv, fn);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_remove_cb_obj, 2, mp_funcptr_remove_cb, funcptr_remove_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_remove_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_remove_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_remove_cb_callback(struct _lv_fs_drv_t *drv, const char *fn);
#define funcptr_read_cb_1 NULL


/*
 * lvgl extension definition for:
 * lv_fs_res_t read_cb(struct _lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btr, uint32_t *br)
 */
 
STATIC mp_obj_t mp_funcptr_read_cb_1(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    void *file_p = mp_to_ptr(mp_args[1]);
    void *buf = mp_to_ptr(mp_args[2]);
    uint32_t btr = (uint32_t)mp_obj_get_int(mp_args[3]);
    uint32_t *br = mp_to_ptr(mp_args[4]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(struct _lv_fs_drv_t *, void *, void *, uint32_t, uint32_t *))lv_func_ptr)(drv, file_p, buf, btr, br);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_read_cb_1_obj, 5, mp_funcptr_read_cb_1, funcptr_read_cb_1);
    
STATIC inline mp_obj_t mp_lv_funcptr_read_cb_1(void *func){ return mp_lv_funcptr(&mp_funcptr_read_cb_1_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_read_cb_callback(struct _lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btr, uint32_t *br);
#define funcptr_write_cb NULL


/*
 * lvgl extension definition for:
 * lv_fs_res_t write_cb(struct _lv_fs_drv_t *drv, void *file_p, const void *buf, uint32_t btw, uint32_t *bw)
 */
 
STATIC mp_obj_t mp_funcptr_write_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    void *file_p = mp_to_ptr(mp_args[1]);
    const void *buf = mp_to_ptr(mp_args[2]);
    uint32_t btw = (uint32_t)mp_obj_get_int(mp_args[3]);
    uint32_t *bw = mp_to_ptr(mp_args[4]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(struct _lv_fs_drv_t *, void *, const void *, uint32_t, uint32_t *))lv_func_ptr)(drv, file_p, buf, btw, bw);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_write_cb_obj, 5, mp_funcptr_write_cb, funcptr_write_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_write_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_write_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_write_cb_callback(struct _lv_fs_drv_t *drv, void *file_p, const void *buf, uint32_t btw, uint32_t *bw);
#define funcptr_seek_cb NULL


/*
 * lvgl extension definition for:
 * lv_fs_res_t seek_cb(struct _lv_fs_drv_t *drv, void *file_p, uint32_t pos)
 */
 
STATIC mp_obj_t mp_funcptr_seek_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    void *file_p = mp_to_ptr(mp_args[1]);
    uint32_t pos = (uint32_t)mp_obj_get_int(mp_args[2]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(struct _lv_fs_drv_t *, void *, uint32_t))lv_func_ptr)(drv, file_p, pos);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_seek_cb_obj, 3, mp_funcptr_seek_cb, funcptr_seek_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_seek_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_seek_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_seek_cb_callback(struct _lv_fs_drv_t *drv, void *file_p, uint32_t pos);
#define funcptr_tell_cb NULL


/*
 * lvgl extension definition for:
 * lv_fs_res_t tell_cb(struct _lv_fs_drv_t *drv, void *file_p, uint32_t *pos_p)
 */
 
STATIC mp_obj_t mp_funcptr_tell_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    void *file_p = mp_to_ptr(mp_args[1]);
    uint32_t *pos_p = mp_to_ptr(mp_args[2]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(struct _lv_fs_drv_t *, void *, uint32_t *))lv_func_ptr)(drv, file_p, pos_p);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_tell_cb_obj, 3, mp_funcptr_tell_cb, funcptr_tell_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_tell_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_tell_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_tell_cb_callback(struct _lv_fs_drv_t *drv, void *file_p, uint32_t *pos_p);
STATIC lv_fs_res_t lv_fs_drv_t_trunc_cb_callback(struct _lv_fs_drv_t *drv, void *file_p);
#define funcptr_size_cb NULL

/* Reusing funcptr_tell_cb for funcptr_size_cb */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_size_cb_obj, 3, mp_funcptr_tell_cb, funcptr_size_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_size_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_size_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_size_cb_callback(struct _lv_fs_drv_t *drv, void *file_p, uint32_t *size_p);
#define funcptr_rename_cb NULL


/*
 * lvgl extension definition for:
 * lv_fs_res_t rename_cb(struct _lv_fs_drv_t *drv, const char *oldname, const char *newname)
 */
 
STATIC mp_obj_t mp_funcptr_rename_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    const char *oldname = (char*)convert_from_str(mp_args[1]);
    const char *newname = (char*)convert_from_str(mp_args[2]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(struct _lv_fs_drv_t *, const char *, const char *))lv_func_ptr)(drv, oldname, newname);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_rename_cb_obj, 3, mp_funcptr_rename_cb, funcptr_rename_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_rename_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_rename_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_rename_cb_callback(struct _lv_fs_drv_t *drv, const char *oldname, const char *newname);
#define funcptr_free_space_cb NULL


/*
 * lvgl extension definition for:
 * lv_fs_res_t free_space_cb(struct _lv_fs_drv_t *drv, uint32_t *total_p, uint32_t *free_p)
 */
 
STATIC mp_obj_t mp_funcptr_free_space_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    uint32_t *total_p = mp_to_ptr(mp_args[1]);
    uint32_t *free_p = mp_to_ptr(mp_args[2]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(struct _lv_fs_drv_t *, uint32_t *, uint32_t *))lv_func_ptr)(drv, total_p, free_p);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_free_space_cb_obj, 3, mp_funcptr_free_space_cb, funcptr_free_space_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_free_space_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_free_space_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_free_space_cb_callback(struct _lv_fs_drv_t *drv, uint32_t *total_p, uint32_t *free_p);
#define funcptr_dir_open_cb NULL


/*
 * lvgl extension definition for:
 * lv_fs_res_t dir_open_cb(struct _lv_fs_drv_t *drv, void *rddir_p, const char *path)
 */
 
STATIC mp_obj_t mp_funcptr_dir_open_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    void *rddir_p = mp_to_ptr(mp_args[1]);
    const char *path = (char*)convert_from_str(mp_args[2]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(struct _lv_fs_drv_t *, void *, const char *))lv_func_ptr)(drv, rddir_p, path);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_dir_open_cb_obj, 3, mp_funcptr_dir_open_cb, funcptr_dir_open_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_dir_open_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_dir_open_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_dir_open_cb_callback(struct _lv_fs_drv_t *drv, void *rddir_p, const char *path);
#define funcptr_dir_read_cb NULL


/*
 * lvgl extension definition for:
 * lv_fs_res_t dir_read_cb(struct _lv_fs_drv_t *drv, void *rddir_p, char *fn)
 */
 
STATIC mp_obj_t mp_funcptr_dir_read_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_fs_drv_t *drv = mp_to_ptr(mp_args[0]);
    void *rddir_p = mp_to_ptr(mp_args[1]);
    char *fn = (char*)convert_from_str(mp_args[2]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(struct _lv_fs_drv_t *, void *, char *))lv_func_ptr)(drv, rddir_p, fn);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_dir_read_cb_obj, 3, mp_funcptr_dir_read_cb, funcptr_dir_read_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_dir_read_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_dir_read_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_dir_read_cb_callback(struct _lv_fs_drv_t *drv, void *rddir_p, char *fn);
#define funcptr_dir_close_cb NULL

/* Reusing funcptr_close_cb for funcptr_dir_close_cb */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_dir_close_cb_obj, 2, mp_funcptr_close_cb, funcptr_dir_close_cb);
    
STATIC inline mp_obj_t mp_lv_funcptr_dir_close_cb(void *func){ return mp_lv_funcptr(&mp_funcptr_dir_close_cb_obj, func, NULL, MP_QSTR_, NULL); }

STATIC lv_fs_res_t lv_fs_drv_t_dir_close_cb_callback(struct _lv_fs_drv_t *drv, void *rddir_p);

/*
 * Struct lv_fs_drv_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_fs_drv_t_type();

STATIC inline lv_fs_drv_t* mp_write_ptr_lv_fs_drv_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_fs_drv_t_type()));
    return (lv_fs_drv_t*)self->data;
}

#define mp_write_lv_fs_drv_t(struct_obj) *mp_write_ptr_lv_fs_drv_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_fs_drv_t(lv_fs_drv_t *field)
{
    return lv_to_mp_struct(get_mp_lv_fs_drv_t_type(), (void*)field);
}

#define mp_read_lv_fs_drv_t(field) mp_read_ptr_lv_fs_drv_t(copy_buffer(&field, sizeof(lv_fs_drv_t)))
#define mp_read_byref_lv_fs_drv_t(field) mp_read_ptr_lv_fs_drv_t(&field)

STATIC void mp_lv_fs_drv_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_fs_drv_t *data = (lv_fs_drv_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_letter: dest[0] = mp_obj_new_int(data->letter); break; // converting from char;
            case MP_QSTR_file_size: dest[0] = mp_obj_new_int_from_uint(data->file_size); break; // converting from uint16_t;
            case MP_QSTR_rddir_size: dest[0] = mp_obj_new_int_from_uint(data->rddir_size); break; // converting from uint16_t;
            case MP_QSTR_ready_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_ready_cb_obj, (void*)data->ready_cb, lv_fs_drv_t_ready_cb_callback ,MP_QSTR_lv_fs_drv_t_ready_cb, data->user_data); break; // converting from callback bool (*)(lv_fs_drv_t *drv);
            case MP_QSTR_open_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_open_cb_obj, (void*)data->open_cb, lv_fs_drv_t_open_cb_callback ,MP_QSTR_lv_fs_drv_t_open_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, char *path, lv_fs_mode_t mode);
            case MP_QSTR_close_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_close_cb_obj, (void*)data->close_cb, lv_fs_drv_t_close_cb_callback ,MP_QSTR_lv_fs_drv_t_close_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p);
            case MP_QSTR_remove_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_remove_cb_obj, (void*)data->remove_cb, lv_fs_drv_t_remove_cb_callback ,MP_QSTR_lv_fs_drv_t_remove_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, char *fn);
            case MP_QSTR_read_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_read_cb_1_obj, (void*)data->read_cb, lv_fs_drv_t_read_cb_callback ,MP_QSTR_lv_fs_drv_t_read_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btr, uint32_t *br);
            case MP_QSTR_write_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_write_cb_obj, (void*)data->write_cb, lv_fs_drv_t_write_cb_callback ,MP_QSTR_lv_fs_drv_t_write_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btw, uint32_t *bw);
            case MP_QSTR_seek_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_seek_cb_obj, (void*)data->seek_cb, lv_fs_drv_t_seek_cb_callback ,MP_QSTR_lv_fs_drv_t_seek_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, uint32_t pos);
            case MP_QSTR_tell_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_tell_cb_obj, (void*)data->tell_cb, lv_fs_drv_t_tell_cb_callback ,MP_QSTR_lv_fs_drv_t_tell_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, uint32_t *pos_p);
            case MP_QSTR_trunc_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_close_cb_obj, (void*)data->trunc_cb, lv_fs_drv_t_trunc_cb_callback ,MP_QSTR_lv_fs_drv_t_trunc_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p);
            case MP_QSTR_size_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_size_cb_obj, (void*)data->size_cb, lv_fs_drv_t_size_cb_callback ,MP_QSTR_lv_fs_drv_t_size_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, uint32_t *size_p);
            case MP_QSTR_rename_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_rename_cb_obj, (void*)data->rename_cb, lv_fs_drv_t_rename_cb_callback ,MP_QSTR_lv_fs_drv_t_rename_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, char *oldname, char *newname);
            case MP_QSTR_free_space_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_free_space_cb_obj, (void*)data->free_space_cb, lv_fs_drv_t_free_space_cb_callback ,MP_QSTR_lv_fs_drv_t_free_space_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, uint32_t *total_p, uint32_t *free_p);
            case MP_QSTR_dir_open_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_dir_open_cb_obj, (void*)data->dir_open_cb, lv_fs_drv_t_dir_open_cb_callback ,MP_QSTR_lv_fs_drv_t_dir_open_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *rddir_p, char *path);
            case MP_QSTR_dir_read_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_dir_read_cb_obj, (void*)data->dir_read_cb, lv_fs_drv_t_dir_read_cb_callback ,MP_QSTR_lv_fs_drv_t_dir_read_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *rddir_p, char *fn);
            case MP_QSTR_dir_close_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_dir_close_cb_obj, (void*)data->dir_close_cb, lv_fs_drv_t_dir_close_cb_callback ,MP_QSTR_lv_fs_drv_t_dir_close_cb, data->user_data); break; // converting from callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *rddir_p);
            case MP_QSTR_user_data: dest[0] = ptr_to_mp(data->user_data); break; // converting from lv_fs_drv_user_data_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_letter: data->letter = (char)mp_obj_get_int(dest[1]); break; // converting to char;
                case MP_QSTR_file_size: data->file_size = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_rddir_size: data->rddir_size = (uint16_t)mp_obj_get_int(dest[1]); break; // converting to uint16_t;
                case MP_QSTR_ready_cb: data->ready_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_ready_cb_callback ,MP_QSTR_lv_fs_drv_t_ready_cb, &data->user_data); break; // converting to callback bool (*)(lv_fs_drv_t *drv);
                case MP_QSTR_open_cb: data->open_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_open_cb_callback ,MP_QSTR_lv_fs_drv_t_open_cb, &data->user_data); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, char *path, lv_fs_mode_t mode);
                case MP_QSTR_close_cb: data->close_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_close_cb_callback ,MP_QSTR_lv_fs_drv_t_close_cb, &data->user_data); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p);
                case MP_QSTR_remove_cb: data->remove_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_remove_cb_callback ,MP_QSTR_lv_fs_drv_t_remove_cb, &data->user_data); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, char *fn);
                case MP_QSTR_read_cb: data->read_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_read_cb_callback ,MP_QSTR_lv_fs_drv_t_read_cb, &data->user_data); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btr, uint32_t *br);
                case MP_QSTR_write_cb: data->write_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_write_cb_callback ,MP_QSTR_lv_fs_drv_t_write_cb, &data->user_data); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btw, uint32_t *bw);
                case MP_QSTR_seek_cb: data->seek_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_seek_cb_callback ,MP_QSTR_lv_fs_drv_t_seek_cb, &data->user_data); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, uint32_t pos);
                case MP_QSTR_tell_cb: data->tell_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_tell_cb_callback ,MP_QSTR_lv_fs_drv_t_tell_cb, &data->user_data); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, uint32_t *pos_p);
                case MP_QSTR_trunc_cb: data->trunc_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_trunc_cb_callback ,MP_QSTR_lv_fs_drv_t_trunc_cb, &data->user_data); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p);
                case MP_QSTR_size_cb: data->size_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_size_cb_callback ,MP_QSTR_lv_fs_drv_t_size_cb, &data->user_data); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *file_p, uint32_t *size_p);
                case MP_QSTR_rename_cb: data->rename_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_rename_cb_callback ,MP_QSTR_lv_fs_drv_t_rename_cb, &data->user_data); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, char *oldname, char *newname);
                case MP_QSTR_free_space_cb: data->free_space_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_free_space_cb_callback ,MP_QSTR_lv_fs_drv_t_free_space_cb, &data->user_data); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, uint32_t *total_p, uint32_t *free_p);
                case MP_QSTR_dir_open_cb: data->dir_open_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_dir_open_cb_callback ,MP_QSTR_lv_fs_drv_t_dir_open_cb, &data->user_data); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *rddir_p, char *path);
                case MP_QSTR_dir_read_cb: data->dir_read_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_dir_read_cb_callback ,MP_QSTR_lv_fs_drv_t_dir_read_cb, &data->user_data); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *rddir_p, char *fn);
                case MP_QSTR_dir_close_cb: data->dir_close_cb = (void*)mp_lv_callback(dest[1], lv_fs_drv_t_dir_close_cb_callback ,MP_QSTR_lv_fs_drv_t_dir_close_cb, &data->user_data); break; // converting to callback lv_fs_res_t (*)(lv_fs_drv_t *drv, void *rddir_p);
                case MP_QSTR_user_data: data->user_data = mp_to_ptr(dest[1]); break; // converting to lv_fs_drv_user_data_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_fs_drv_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_fs_drv_t");
}

STATIC const mp_obj_dict_t mp_lv_fs_drv_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_fs_drv_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_fs_drv_t,
    .print = mp_lv_fs_drv_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_fs_drv_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_fs_drv_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_fs_drv_t_type()
{
    return &mp_lv_fs_drv_t_type;
}
    

/*
 * Struct lv_fs_file_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_fs_file_t_type();

STATIC inline lv_fs_file_t* mp_write_ptr_lv_fs_file_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_fs_file_t_type()));
    return (lv_fs_file_t*)self->data;
}

#define mp_write_lv_fs_file_t(struct_obj) *mp_write_ptr_lv_fs_file_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_fs_file_t(lv_fs_file_t *field)
{
    return lv_to_mp_struct(get_mp_lv_fs_file_t_type(), (void*)field);
}

#define mp_read_lv_fs_file_t(field) mp_read_ptr_lv_fs_file_t(copy_buffer(&field, sizeof(lv_fs_file_t)))
#define mp_read_byref_lv_fs_file_t(field) mp_read_ptr_lv_fs_file_t(&field)

STATIC void mp_lv_fs_file_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_fs_file_t *data = (lv_fs_file_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_file_d: dest[0] = ptr_to_mp((void*)data->file_d); break; // converting from void *;
            case MP_QSTR_drv: dest[0] = mp_read_ptr_lv_fs_drv_t((void*)data->drv); break; // converting from lv_fs_drv_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_file_d: data->file_d = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_drv: data->drv = (void*)mp_write_ptr_lv_fs_drv_t(dest[1]); break; // converting to lv_fs_drv_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_fs_file_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_fs_file_t");
}

STATIC const mp_obj_dict_t mp_lv_fs_file_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_fs_file_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_fs_file_t,
    .print = mp_lv_fs_file_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_fs_file_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_fs_file_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_fs_file_t_type()
{
    return &mp_lv_fs_file_t_type;
}
    

/*
 * Struct lv_fs_dir_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_fs_dir_t_type();

STATIC inline lv_fs_dir_t* mp_write_ptr_lv_fs_dir_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_fs_dir_t_type()));
    return (lv_fs_dir_t*)self->data;
}

#define mp_write_lv_fs_dir_t(struct_obj) *mp_write_ptr_lv_fs_dir_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_fs_dir_t(lv_fs_dir_t *field)
{
    return lv_to_mp_struct(get_mp_lv_fs_dir_t_type(), (void*)field);
}

#define mp_read_lv_fs_dir_t(field) mp_read_ptr_lv_fs_dir_t(copy_buffer(&field, sizeof(lv_fs_dir_t)))
#define mp_read_byref_lv_fs_dir_t(field) mp_read_ptr_lv_fs_dir_t(&field)

STATIC void mp_lv_fs_dir_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_fs_dir_t *data = (lv_fs_dir_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_dir_d: dest[0] = ptr_to_mp((void*)data->dir_d); break; // converting from void *;
            case MP_QSTR_drv: dest[0] = mp_read_ptr_lv_fs_drv_t((void*)data->drv); break; // converting from lv_fs_drv_t *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_dir_d: data->dir_d = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                case MP_QSTR_drv: data->drv = (void*)mp_write_ptr_lv_fs_drv_t(dest[1]); break; // converting to lv_fs_drv_t *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_fs_dir_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_fs_dir_t");
}

STATIC const mp_obj_dict_t mp_lv_fs_dir_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_fs_dir_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_fs_dir_t,
    .print = mp_lv_fs_dir_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_fs_dir_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_fs_dir_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_fs_dir_t_type()
{
    return &mp_lv_fs_dir_t_type;
}
    
#define funcptr_lv_theme_apply_cb_t NULL


/*
 * lvgl extension definition for:
 * void lv_theme_apply_cb_t(struct _lv_theme_t *, lv_obj_t *, lv_theme_style_t)
 */
 
STATIC mp_obj_t mp_funcptr_lv_theme_apply_cb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    struct _lv_theme_t *arg0 = mp_to_ptr(mp_args[0]);
    lv_obj_t *arg1 = mp_to_lv(mp_args[1]);
    lv_theme_style_t arg2 = (int)mp_obj_get_int(mp_args[2]);
    ((void (*)(struct _lv_theme_t *, lv_obj_t *, lv_theme_style_t))lv_func_ptr)(arg0, arg1, arg2);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_funcptr_lv_theme_apply_cb_t_obj, 3, mp_funcptr_lv_theme_apply_cb_t, funcptr_lv_theme_apply_cb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_theme_apply_cb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_theme_apply_cb_t_obj, func, NULL, MP_QSTR_, NULL); }

STATIC void lv_theme_t_apply_cb_callback(struct _lv_theme_t *, lv_obj_t *, lv_theme_style_t);
#define funcptr_lv_theme_apply_xcb_t NULL


/*
 * lvgl extension definition for:
 * void lv_theme_apply_xcb_t(lv_obj_t *, lv_theme_style_t)
 */
 
STATIC mp_obj_t mp_funcptr_lv_theme_apply_xcb_t(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *arg0 = mp_to_lv(mp_args[0]);
    lv_theme_style_t arg1 = (int)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_obj_t *, lv_theme_style_t))lv_func_ptr)(arg0, arg1);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_funcptr_lv_theme_apply_xcb_t_obj, 2, mp_funcptr_lv_theme_apply_xcb_t, funcptr_lv_theme_apply_xcb_t);
    
STATIC inline mp_obj_t mp_lv_funcptr_lv_theme_apply_xcb_t(void *func){ return mp_lv_funcptr(&mp_funcptr_lv_theme_apply_xcb_t_obj, func, NULL, MP_QSTR_, NULL); }


/*
 * Function NOT generated:
 * Missing 'user_data' as a field of the first parameter of the callback function 'lv_theme_t_apply_xcb_callback'
 * lv_theme_apply_xcb_t apply_xcb
 */
    

/*
 * Struct lv_theme_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_theme_t_type();

STATIC inline lv_theme_t* mp_write_ptr_lv_theme_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_theme_t_type()));
    return (lv_theme_t*)self->data;
}

#define mp_write_lv_theme_t(struct_obj) *mp_write_ptr_lv_theme_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_theme_t(lv_theme_t *field)
{
    return lv_to_mp_struct(get_mp_lv_theme_t_type(), (void*)field);
}

#define mp_read_lv_theme_t(field) mp_read_ptr_lv_theme_t(copy_buffer(&field, sizeof(lv_theme_t)))
#define mp_read_byref_lv_theme_t(field) mp_read_ptr_lv_theme_t(&field)

STATIC void mp_lv_theme_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_theme_t *data = (lv_theme_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_apply_cb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_theme_apply_cb_t_obj, data->apply_cb, lv_theme_t_apply_cb_callback ,MP_QSTR_lv_theme_t_apply_cb, data->user_data); break; // converting from callback lv_theme_apply_cb_t;
            case MP_QSTR_apply_xcb: dest[0] = mp_lv_funcptr(&mp_funcptr_lv_theme_apply_xcb_t_obj, data->apply_xcb, NULL ,MP_QSTR_lv_theme_t_apply_xcb, NULL); break; // converting from callback lv_theme_apply_xcb_t;
            case MP_QSTR_base: dest[0] = ptr_to_mp((void*)data->base); break; // converting from lv_theme_t *;
            case MP_QSTR_color_primary: dest[0] = mp_read_byref_lv_color32_t(data->color_primary); break; // converting from lv_color_t;
            case MP_QSTR_color_secondary: dest[0] = mp_read_byref_lv_color32_t(data->color_secondary); break; // converting from lv_color_t;
            case MP_QSTR_font_small: dest[0] = mp_read_ptr_lv_font_t((void*)data->font_small); break; // converting from lv_font_t *;
            case MP_QSTR_font_normal: dest[0] = mp_read_ptr_lv_font_t((void*)data->font_normal); break; // converting from lv_font_t *;
            case MP_QSTR_font_subtitle: dest[0] = mp_read_ptr_lv_font_t((void*)data->font_subtitle); break; // converting from lv_font_t *;
            case MP_QSTR_font_title: dest[0] = mp_read_ptr_lv_font_t((void*)data->font_title); break; // converting from lv_font_t *;
            case MP_QSTR_flags: dest[0] = mp_obj_new_int_from_uint(data->flags); break; // converting from uint32_t;
            case MP_QSTR_user_data: dest[0] = ptr_to_mp((void*)data->user_data); break; // converting from void *;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_apply_cb: data->apply_cb = mp_lv_callback(dest[1], lv_theme_t_apply_cb_callback ,MP_QSTR_lv_theme_t_apply_cb, &data->user_data); break; // converting to callback lv_theme_apply_cb_t;
                case MP_QSTR_apply_xcb: data->apply_xcb = mp_lv_callback(dest[1], NULL ,MP_QSTR_lv_theme_t_apply_xcb, NULL); break; // converting to callback lv_theme_apply_xcb_t;
                case MP_QSTR_base: data->base = (void*)mp_to_ptr(dest[1]); break; // converting to lv_theme_t *;
                case MP_QSTR_color_primary: data->color_primary = mp_write_lv_color32_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_color_secondary: data->color_secondary = mp_write_lv_color32_t(dest[1]); break; // converting to lv_color_t;
                case MP_QSTR_font_small: data->font_small = (void*)mp_write_ptr_lv_font_t(dest[1]); break; // converting to lv_font_t *;
                case MP_QSTR_font_normal: data->font_normal = (void*)mp_write_ptr_lv_font_t(dest[1]); break; // converting to lv_font_t *;
                case MP_QSTR_font_subtitle: data->font_subtitle = (void*)mp_write_ptr_lv_font_t(dest[1]); break; // converting to lv_font_t *;
                case MP_QSTR_font_title: data->font_title = (void*)mp_write_ptr_lv_font_t(dest[1]); break; // converting to lv_font_t *;
                case MP_QSTR_flags: data->flags = (uint32_t)mp_obj_get_int(dest[1]); break; // converting to uint32_t;
                case MP_QSTR_user_data: data->user_data = (void*)mp_to_ptr(dest[1]); break; // converting to void *;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_theme_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_theme_t");
}

STATIC const mp_obj_dict_t mp_lv_theme_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_theme_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_theme_t,
    .print = mp_lv_theme_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_theme_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_theme_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_theme_t_type()
{
    return &mp_lv_theme_t_type;
}
    

STATIC const mp_rom_map_elem_t mp_C_Pointer_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(C_Pointer))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_C_Pointer_locals_dict, mp_C_Pointer_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static uint8_t lv_color_to1(lv_color_t color)
 */
 
STATIC mp_obj_t mp_lv_color_to1(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t color = mp_write_lv_color32_t(mp_args[0]);
    uint8_t _res = ((uint8_t (*)(lv_color_t))lv_func_ptr)(color);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_to1_obj, 1, mp_lv_color_to1, lv_color_to1);
    
/* Reusing lv_color_to1 for lv_color_to8 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_to8_obj, 1, mp_lv_color_to1, lv_color_to8);
    

/*
 * lvgl extension definition for:
 * inline static uint16_t lv_color_to16(lv_color_t color)
 */
 
STATIC mp_obj_t mp_lv_color_to16(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t color = mp_write_lv_color32_t(mp_args[0]);
    uint16_t _res = ((uint16_t (*)(lv_color_t))lv_func_ptr)(color);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_to16_obj, 1, mp_lv_color_to16, lv_color_to16);
    

/*
 * lvgl extension definition for:
 * inline static uint32_t lv_color_to32(lv_color_t color)
 */
 
STATIC mp_obj_t mp_lv_color_to32(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t color = mp_write_lv_color32_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(lv_color_t))lv_func_ptr)(color);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_to32_obj, 1, mp_lv_color_to32, lv_color_to32);
    

/*
 * lvgl extension definition for:
 * inline static lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
 */
 
STATIC mp_obj_t mp_lv_color_mix(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t c1 = mp_write_lv_color32_t(mp_args[0]);
    lv_color_t c2 = mp_write_lv_color32_t(mp_args[1]);
    uint8_t mix = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_color_t _res = ((lv_color_t (*)(lv_color_t, lv_color_t, uint8_t))lv_func_ptr)(c1, c2, mix);
    return mp_read_lv_color32_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_mix_obj, 3, mp_lv_color_mix, lv_color_mix);
    

/*
 * lvgl extension definition for:
 * inline static void lv_color_premult(lv_color_t c, uint8_t mix, uint16_t *out)
 */
 
STATIC mp_obj_t mp_lv_color_premult(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t c = mp_write_lv_color32_t(mp_args[0]);
    uint8_t mix = (uint8_t)mp_obj_get_int(mp_args[1]);
    uint16_t *out = mp_to_ptr(mp_args[2]);
    ((void (*)(lv_color_t, uint8_t, uint16_t *))lv_func_ptr)(c, mix, out);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_premult_obj, 3, mp_lv_color_premult, lv_color_premult);
    

/*
 * lvgl extension definition for:
 * inline static void lv_color_mix_with_alpha(lv_color_t bg_color, lv_opa_t bg_opa, lv_color_t fg_color, lv_opa_t fg_opa, lv_color_t *res_color, lv_opa_t *res_opa)
 */
 
STATIC mp_obj_t mp_lv_color_mix_with_alpha(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t bg_color = mp_write_lv_color32_t(mp_args[0]);
    lv_opa_t bg_opa = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_color_t fg_color = mp_write_lv_color32_t(mp_args[2]);
    lv_opa_t fg_opa = (uint8_t)mp_obj_get_int(mp_args[3]);
    lv_color_t *res_color = mp_write_ptr_lv_color32_t(mp_args[4]);
    lv_opa_t *res_opa = mp_to_ptr(mp_args[5]);
    ((void (*)(lv_color_t, lv_opa_t, lv_color_t, lv_opa_t, lv_color_t *, lv_opa_t *))lv_func_ptr)(bg_color, bg_opa, fg_color, fg_opa, res_color, res_opa);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_mix_with_alpha_obj, 6, mp_lv_color_mix_with_alpha, lv_color_mix_with_alpha);
    
/* Reusing lv_color_to1 for lv_color_brightness */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_brightness_obj, 1, mp_lv_color_to1, lv_color_brightness);
    

/*
 * lvgl extension definition for:
 * void lv_color_fill(lv_color_t *buf, lv_color_t color, uint32_t px_num)
 */
 
STATIC mp_obj_t mp_lv_color_fill(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t *buf = mp_write_ptr_lv_color32_t(mp_args[0]);
    lv_color_t color = mp_write_lv_color32_t(mp_args[1]);
    uint32_t px_num = (uint32_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_color_t *, lv_color_t, uint32_t))lv_func_ptr)(buf, color, px_num);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_fill_obj, 3, mp_lv_color_fill, lv_color_fill);
    

/*
 * lvgl extension definition for:
 * lv_color_t lv_color_lighten(lv_color_t c, lv_opa_t lvl)
 */
 
STATIC mp_obj_t mp_lv_color_lighten(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t c = mp_write_lv_color32_t(mp_args[0]);
    lv_opa_t lvl = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_color_t _res = ((lv_color_t (*)(lv_color_t, lv_opa_t))lv_func_ptr)(c, lvl);
    return mp_read_lv_color32_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_lighten_obj, 2, mp_lv_color_lighten, lv_color_lighten);
    
/* Reusing lv_color_lighten for lv_color_darken */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_darken_obj, 2, mp_lv_color_lighten, lv_color_darken);
    

/*
 * lvgl extension definition for:
 * lv_color_hsv_t lv_color_to_hsv(lv_color_t color)
 */
 
STATIC mp_obj_t mp_lv_color_to_hsv(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t color = mp_write_lv_color32_t(mp_args[0]);
    lv_color_hsv_t _res = ((lv_color_hsv_t (*)(lv_color_t))lv_func_ptr)(color);
    return mp_read_lv_color_hsv_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_color_to_hsv_obj, 1, mp_lv_color_to_hsv, lv_color_to_hsv);
    

STATIC const mp_rom_map_elem_t mp_lv_color32_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_color32_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_to1), MP_ROM_PTR(&mp_lv_color_to1_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_to8), MP_ROM_PTR(&mp_lv_color_to8_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_to16), MP_ROM_PTR(&mp_lv_color_to16_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_to32), MP_ROM_PTR(&mp_lv_color_to32_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_mix), MP_ROM_PTR(&mp_lv_color_mix_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_premult), MP_ROM_PTR(&mp_lv_color_premult_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_mix_with_alpha), MP_ROM_PTR(&mp_lv_color_mix_with_alpha_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_brightness), MP_ROM_PTR(&mp_lv_color_brightness_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_fill), MP_ROM_PTR(&mp_lv_color_fill_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_lighten), MP_ROM_PTR(&mp_lv_color_lighten_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_darken), MP_ROM_PTR(&mp_lv_color_darken_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_to_hsv), MP_ROM_PTR(&mp_lv_color_to_hsv_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_color32_t_locals_dict, mp_lv_color32_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_color32_ch_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_color32_ch_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_color32_ch_t_locals_dict, mp_lv_color32_ch_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static lv_coord_t lv_font_get_line_height(const lv_font_t *font_p)
 */
 
STATIC mp_obj_t mp_lv_font_get_line_height(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_font_t *font_p = mp_write_ptr_lv_font_t(mp_args[0]);
    lv_coord_t _res = ((lv_coord_t (*)(const lv_font_t *))lv_func_ptr)(font_p);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_font_get_line_height_obj, 1, mp_lv_font_get_line_height, lv_font_get_line_height);
    

/*
 * lvgl extension definition for:
 * const uint8_t *lv_font_get_glyph_bitmap(const lv_font_t *font_p, uint32_t letter)
 */
 
STATIC mp_obj_t mp_lv_font_get_glyph_bitmap(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_font_t *font_p = mp_write_ptr_lv_font_t(mp_args[0]);
    uint32_t letter = (uint32_t)mp_obj_get_int(mp_args[1]);
    const uint8_t * _res = ((const uint8_t *(*)(const lv_font_t *, uint32_t))lv_func_ptr)(font_p, letter);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_font_get_glyph_bitmap_obj, 2, mp_lv_font_get_glyph_bitmap, lv_font_get_glyph_bitmap);
    

/*
 * lvgl extension definition for:
 * bool lv_font_get_glyph_dsc(const lv_font_t *font_p, lv_font_glyph_dsc_t *dsc_out, uint32_t letter, uint32_t letter_next)
 */
 
STATIC mp_obj_t mp_lv_font_get_glyph_dsc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_font_t *font_p = mp_write_ptr_lv_font_t(mp_args[0]);
    lv_font_glyph_dsc_t *dsc_out = mp_write_ptr_lv_font_glyph_dsc_t(mp_args[1]);
    uint32_t letter = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint32_t letter_next = (uint32_t)mp_obj_get_int(mp_args[3]);
    bool _res = ((bool (*)(const lv_font_t *, lv_font_glyph_dsc_t *, uint32_t, uint32_t))lv_func_ptr)(font_p, dsc_out, letter, letter_next);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_font_get_glyph_dsc_obj, 4, mp_lv_font_get_glyph_dsc, lv_font_get_glyph_dsc);
    

/*
 * lvgl extension definition for:
 * uint16_t lv_font_get_glyph_width(const lv_font_t *font, uint32_t letter, uint32_t letter_next)
 */
 
STATIC mp_obj_t mp_lv_font_get_glyph_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_font_t *font = mp_write_ptr_lv_font_t(mp_args[0]);
    uint32_t letter = (uint32_t)mp_obj_get_int(mp_args[1]);
    uint32_t letter_next = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint16_t _res = ((uint16_t (*)(const lv_font_t *, uint32_t, uint32_t))lv_func_ptr)(font, letter, letter_next);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_font_get_glyph_width_obj, 3, mp_lv_font_get_glyph_width, lv_font_get_glyph_width);
    

/*
 * lvgl extension definition for:
 * void lv_font_free(lv_font_t *font)
 */
 
STATIC mp_obj_t mp_lv_font_free(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_font_t *font = mp_write_ptr_lv_font_t(mp_args[0]);
    ((void (*)(lv_font_t *))lv_func_ptr)(font);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_font_free_obj, 1, mp_lv_font_free, lv_font_free);
    
/* Reusing lv_font_get_glyph_bitmap for lv_font_get_bitmap_fmt_txt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_font_get_bitmap_fmt_txt_obj, 2, mp_lv_font_get_glyph_bitmap, lv_font_get_bitmap_fmt_txt);
    
/* Reusing lv_font_get_glyph_dsc for lv_font_get_glyph_dsc_fmt_txt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_font_get_glyph_dsc_fmt_txt_obj, 4, mp_lv_font_get_glyph_dsc, lv_font_get_glyph_dsc_fmt_txt);
    

STATIC const mp_rom_map_elem_t mp_lv_font_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_font_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_line_height), MP_ROM_PTR(&mp_lv_font_get_line_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_glyph_bitmap), MP_ROM_PTR(&mp_lv_font_get_glyph_bitmap_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_glyph_dsc), MP_ROM_PTR(&mp_lv_font_get_glyph_dsc_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_glyph_width), MP_ROM_PTR(&mp_lv_font_get_glyph_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_free), MP_ROM_PTR(&mp_lv_font_free_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_bitmap_fmt_txt), MP_ROM_PTR(&mp_lv_font_get_bitmap_fmt_txt_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_glyph_dsc_fmt_txt), MP_ROM_PTR(&mp_lv_font_get_glyph_dsc_fmt_txt_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_font_t_locals_dict, mp_lv_font_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_font_glyph_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_font_glyph_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_font_glyph_dsc_t_locals_dict, mp_lv_font_glyph_dsc_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static void lv_anim_path_init(lv_anim_path_t *path)
 */
 
STATIC mp_obj_t mp_lv_anim_path_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_path_t *path = mp_write_ptr_lv_anim_path_t(mp_args[0]);
    ((void (*)(lv_anim_path_t *))lv_func_ptr)(path);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_init_obj, 1, mp_lv_anim_path_init, lv_anim_path_init);
    

/*
 * Callback function lv_anim_path_t_cb
 * lv_anim_value_t lv_anim_path_cb_t(const struct _lv_anim_path_t *, const struct _lv_anim_t *)
 */

STATIC lv_anim_value_t lv_anim_path_t_cb_callback(const struct _lv_anim_path_t * arg0, const struct _lv_anim_t * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_anim_path_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_anim_t((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_anim_path_t_cb)) , 2, 0, mp_args);
    return (int16_t)mp_obj_get_int(callback_result);
}


/*
 * lvgl extension definition for:
 * inline static void lv_anim_path_set_cb(lv_anim_path_t *path, lv_anim_path_cb_t cb)
 */
 
STATIC mp_obj_t mp_lv_anim_path_set_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_path_t *path = mp_write_ptr_lv_anim_path_t(mp_args[0]);
    void *cb = mp_lv_callback(mp_args[1], &lv_anim_path_t_cb_callback, MP_QSTR_lv_anim_path_t_cb, &path->user_data);
    ((void (*)(lv_anim_path_t *, lv_anim_path_cb_t))lv_func_ptr)(path, cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_set_cb_obj, 2, mp_lv_anim_path_set_cb, lv_anim_path_set_cb);
    

/*
 * lvgl extension definition for:
 * inline static void lv_anim_path_set_user_data(lv_anim_path_t *path, void *user_data)
 */
 
STATIC mp_obj_t mp_lv_anim_path_set_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[1]);
    lv_anim_path_t *path = mp_write_ptr_lv_anim_path_t(mp_args[0]);
    ((void (*)(lv_anim_path_t *, void *))lv_func_ptr)(path, user_data);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_set_user_data_obj, 2, mp_lv_anim_path_set_user_data, lv_anim_path_set_user_data);
    

/*
 * lvgl extension definition for:
 * lv_anim_value_t lv_anim_path_linear(const lv_anim_path_t *path, const lv_anim_t *a)
 */
 
STATIC mp_obj_t mp_lv_anim_path_linear(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_anim_path_t *path = mp_write_ptr_lv_anim_path_t(mp_args[0]);
    const lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[1]);
    lv_anim_value_t _res = ((lv_anim_value_t (*)(const lv_anim_path_t *, const lv_anim_t *))lv_func_ptr)(path, a);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_linear_obj, 2, mp_lv_anim_path_linear, lv_anim_path_linear);
    
/* Reusing lv_anim_path_linear for lv_anim_path_ease_in */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_ease_in_obj, 2, mp_lv_anim_path_linear, lv_anim_path_ease_in);
    
/* Reusing lv_anim_path_linear for lv_anim_path_ease_out */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_ease_out_obj, 2, mp_lv_anim_path_linear, lv_anim_path_ease_out);
    
/* Reusing lv_anim_path_linear for lv_anim_path_ease_in_out */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_ease_in_out_obj, 2, mp_lv_anim_path_linear, lv_anim_path_ease_in_out);
    
/* Reusing lv_anim_path_linear for lv_anim_path_overshoot */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_overshoot_obj, 2, mp_lv_anim_path_linear, lv_anim_path_overshoot);
    
/* Reusing lv_anim_path_linear for lv_anim_path_bounce */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_bounce_obj, 2, mp_lv_anim_path_linear, lv_anim_path_bounce);
    
/* Reusing lv_anim_path_linear for lv_anim_path_step */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_path_step_obj, 2, mp_lv_anim_path_linear, lv_anim_path_step);
    

STATIC const mp_rom_map_elem_t mp_lv_anim_path_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_anim_path_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_anim_path_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_cb), MP_ROM_PTR(&mp_lv_anim_path_set_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_user_data), MP_ROM_PTR(&mp_lv_anim_path_set_user_data_obj) },
    { MP_ROM_QSTR(MP_QSTR_linear), MP_ROM_PTR(&mp_lv_anim_path_linear_obj) },
    { MP_ROM_QSTR(MP_QSTR_ease_in), MP_ROM_PTR(&mp_lv_anim_path_ease_in_obj) },
    { MP_ROM_QSTR(MP_QSTR_ease_out), MP_ROM_PTR(&mp_lv_anim_path_ease_out_obj) },
    { MP_ROM_QSTR(MP_QSTR_ease_in_out), MP_ROM_PTR(&mp_lv_anim_path_ease_in_out_obj) },
    { MP_ROM_QSTR(MP_QSTR_overshoot), MP_ROM_PTR(&mp_lv_anim_path_overshoot_obj) },
    { MP_ROM_QSTR(MP_QSTR_bounce), MP_ROM_PTR(&mp_lv_anim_path_bounce_obj) },
    { MP_ROM_QSTR(MP_QSTR_step), MP_ROM_PTR(&mp_lv_anim_path_step_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_anim_path_t_locals_dict, mp_lv_anim_path_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_var(lv_anim_t *a, void *var)
 */
 
STATIC mp_obj_t mp_lv_anim_set_var(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    void *var = mp_to_ptr(mp_args[1]);
    ((void (*)(lv_anim_t *, void *))lv_func_ptr)(a, var);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_var_obj, 2, mp_lv_anim_set_var, lv_anim_set_var);
    

/*
 * Function NOT generated:
 * Callback function 'lv_anim_exec_xcb_t exec_cb' must receive a struct pointer with user_data member as its first argument!
 * lv_anim_exec_xcb_t exec_cb
 */
    

/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_exec_cb(lv_anim_t *a, lv_anim_exec_xcb_t exec_cb)
 */
 
STATIC mp_obj_t mp_lv_anim_set_exec_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    lv_anim_exec_xcb_t exec_cb = mp_to_ptr(mp_args[1]);
    ((void (*)(lv_anim_t *, lv_anim_exec_xcb_t))lv_func_ptr)(a, exec_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_exec_cb_obj, 2, mp_lv_anim_set_exec_cb, lv_anim_set_exec_cb);
    

/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_time(lv_anim_t *a, uint32_t duration)
 */
 
STATIC mp_obj_t mp_lv_anim_set_time(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    uint32_t duration = (uint32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_anim_t *, uint32_t))lv_func_ptr)(a, duration);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_time_obj, 2, mp_lv_anim_set_time, lv_anim_set_time);
    
/* Reusing lv_anim_set_time for lv_anim_set_delay */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_delay_obj, 2, mp_lv_anim_set_time, lv_anim_set_delay);
    

/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_values(lv_anim_t *a, lv_anim_value_t start, lv_anim_value_t end)
 */
 
STATIC mp_obj_t mp_lv_anim_set_values(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    lv_anim_value_t start = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_anim_value_t end = (int16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_anim_t *, lv_anim_value_t, lv_anim_value_t))lv_func_ptr)(a, start, end);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_values_obj, 3, mp_lv_anim_set_values, lv_anim_set_values);
    

/*
 * Callback function lv_anim_t_exec_cb
 * void lv_anim_custom_exec_cb_t(struct _lv_anim_t *, lv_anim_value_t)
 */

STATIC void lv_anim_t_exec_cb_callback(struct _lv_anim_t * arg0, lv_anim_value_t arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_anim_t((void*)arg0);
    mp_args[1] = mp_obj_new_int(arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_anim_t_exec_cb)) , 2, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_custom_exec_cb(lv_anim_t *a, lv_anim_custom_exec_cb_t exec_cb)
 */
 
STATIC mp_obj_t mp_lv_anim_set_custom_exec_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    void *exec_cb = mp_lv_callback(mp_args[1], &lv_anim_t_exec_cb_callback, MP_QSTR_lv_anim_t_exec_cb, &a->user_data);
    ((void (*)(lv_anim_t *, lv_anim_custom_exec_cb_t))lv_func_ptr)(a, exec_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_custom_exec_cb_obj, 2, mp_lv_anim_set_custom_exec_cb, lv_anim_set_custom_exec_cb);
    

/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_path(lv_anim_t *a, const lv_anim_path_t *path)
 */
 
STATIC mp_obj_t mp_lv_anim_set_path(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    const lv_anim_path_t *path = mp_write_ptr_lv_anim_path_t(mp_args[1]);
    ((void (*)(lv_anim_t *, const lv_anim_path_t *))lv_func_ptr)(a, path);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_path_obj, 2, mp_lv_anim_set_path, lv_anim_set_path);
    

/*
 * Callback function lv_anim_t_start_cb
 * void lv_anim_ready_cb_t(struct _lv_anim_t *)
 */

STATIC void lv_anim_t_start_cb_callback(struct _lv_anim_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_anim_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_anim_t_start_cb)) , 1, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_start_cb(lv_anim_t *a, lv_anim_ready_cb_t start_cb)
 */
 
STATIC mp_obj_t mp_lv_anim_set_start_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    void *start_cb = mp_lv_callback(mp_args[1], &lv_anim_t_start_cb_callback, MP_QSTR_lv_anim_t_start_cb, &a->user_data);
    ((void (*)(lv_anim_t *, lv_anim_ready_cb_t))lv_func_ptr)(a, start_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_start_cb_obj, 2, mp_lv_anim_set_start_cb, lv_anim_set_start_cb);
    
/* Reusing lv_anim_set_start_cb for lv_anim_set_ready_cb */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_ready_cb_obj, 2, mp_lv_anim_set_start_cb, lv_anim_set_ready_cb);
    

/*
 * lvgl extension definition for:
 * inline static void lv_anim_set_playback_time(lv_anim_t *a, uint16_t time)
 */
 
STATIC mp_obj_t mp_lv_anim_set_playback_time(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    uint16_t time = (uint16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_anim_t *, uint16_t))lv_func_ptr)(a, time);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_playback_time_obj, 2, mp_lv_anim_set_playback_time, lv_anim_set_playback_time);
    
/* Reusing lv_anim_set_playback_time for lv_anim_set_playback_delay */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_playback_delay_obj, 2, mp_lv_anim_set_playback_time, lv_anim_set_playback_delay);
    
/* Reusing lv_anim_set_playback_time for lv_anim_set_repeat_count */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_repeat_count_obj, 2, mp_lv_anim_set_playback_time, lv_anim_set_repeat_count);
    
/* Reusing lv_anim_set_playback_time for lv_anim_set_repeat_delay */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_set_repeat_delay_obj, 2, mp_lv_anim_set_playback_time, lv_anim_set_repeat_delay);
    

/*
 * lvgl extension definition for:
 * inline static int32_t lv_anim_get_delay(lv_anim_t *a)
 */
 
STATIC mp_obj_t mp_lv_anim_get_delay(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    int32_t _res = ((int32_t (*)(lv_anim_t *))lv_func_ptr)(a);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_get_delay_obj, 1, mp_lv_anim_get_delay, lv_anim_get_delay);
    

/*
 * lvgl extension definition for:
 * inline static bool lv_anim_custom_del(lv_anim_t *a, lv_anim_custom_exec_cb_t exec_cb)
 */
 
STATIC mp_obj_t mp_lv_anim_custom_del(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_anim_t *a = mp_write_ptr_lv_anim_t(mp_args[0]);
    void *exec_cb = mp_lv_callback(mp_args[1], &lv_anim_t_exec_cb_callback, MP_QSTR_lv_anim_t_exec_cb, &a->user_data);
    bool _res = ((bool (*)(lv_anim_t *, lv_anim_custom_exec_cb_t))lv_func_ptr)(a, exec_cb);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_custom_del_obj, 2, mp_lv_anim_custom_del, lv_anim_custom_del);
    
/* Reusing lv_obj_del_anim_ready_cb for lv_anim_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_init_obj, 1, mp_lv_obj_del_anim_ready_cb, lv_anim_init);
    
/* Reusing lv_obj_del_anim_ready_cb for lv_anim_start */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_anim_start_obj, 1, mp_lv_obj_del_anim_ready_cb, lv_anim_start);
    

STATIC const mp_rom_map_elem_t mp_lv_anim_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_anim_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_var), MP_ROM_PTR(&mp_lv_anim_set_var_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_exec_cb), MP_ROM_PTR(&mp_lv_anim_set_exec_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_time), MP_ROM_PTR(&mp_lv_anim_set_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_delay), MP_ROM_PTR(&mp_lv_anim_set_delay_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_values), MP_ROM_PTR(&mp_lv_anim_set_values_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_custom_exec_cb), MP_ROM_PTR(&mp_lv_anim_set_custom_exec_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_path), MP_ROM_PTR(&mp_lv_anim_set_path_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_start_cb), MP_ROM_PTR(&mp_lv_anim_set_start_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_ready_cb), MP_ROM_PTR(&mp_lv_anim_set_ready_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_playback_time), MP_ROM_PTR(&mp_lv_anim_set_playback_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_playback_delay), MP_ROM_PTR(&mp_lv_anim_set_playback_delay_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_repeat_count), MP_ROM_PTR(&mp_lv_anim_set_repeat_count_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_repeat_delay), MP_ROM_PTR(&mp_lv_anim_set_repeat_delay_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_delay), MP_ROM_PTR(&mp_lv_anim_get_delay_obj) },
    { MP_ROM_QSTR(MP_QSTR_custom_del), MP_ROM_PTR(&mp_lv_anim_custom_del_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_anim_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_start), MP_ROM_PTR(&mp_lv_anim_start_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_anim_t_locals_dict, mp_lv_anim_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static void lv_area_copy(lv_area_t *dest, const lv_area_t *src)
 */
 
STATIC mp_obj_t mp_lv_area_copy(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_area_t *dest = mp_write_ptr_lv_area_t(mp_args[0]);
    const lv_area_t *src = mp_write_ptr_lv_area_t(mp_args[1]);
    ((void (*)(lv_area_t *, const lv_area_t *))lv_func_ptr)(dest, src);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_copy_obj, 2, mp_lv_area_copy, lv_area_copy);
    

/*
 * lvgl extension definition for:
 * inline static lv_coord_t lv_area_get_width(const lv_area_t *area_p)
 */
 
STATIC mp_obj_t mp_lv_area_get_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_area_t *area_p = mp_write_ptr_lv_area_t(mp_args[0]);
    lv_coord_t _res = ((lv_coord_t (*)(const lv_area_t *))lv_func_ptr)(area_p);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_get_width_obj, 1, mp_lv_area_get_width, lv_area_get_width);
    
/* Reusing lv_area_get_width for lv_area_get_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_get_height_obj, 1, mp_lv_area_get_width, lv_area_get_height);
    

/*
 * lvgl extension definition for:
 * void lv_area_set(lv_area_t *area_p, lv_coord_t x1, lv_coord_t y1, lv_coord_t x2, lv_coord_t y2)
 */
 
STATIC mp_obj_t mp_lv_area_set(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_area_t *area_p = mp_write_ptr_lv_area_t(mp_args[0]);
    lv_coord_t x1 = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t y1 = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t x2 = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t y2 = (int16_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(lv_area_t *, lv_coord_t, lv_coord_t, lv_coord_t, lv_coord_t))lv_func_ptr)(area_p, x1, y1, x2, y2);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_set_obj, 5, mp_lv_area_set, lv_area_set);
    

/*
 * lvgl extension definition for:
 * void lv_area_set_width(lv_area_t *area_p, lv_coord_t w)
 */
 
STATIC mp_obj_t mp_lv_area_set_width(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_area_t *area_p = mp_write_ptr_lv_area_t(mp_args[0]);
    lv_coord_t w = (int16_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_area_t *, lv_coord_t))lv_func_ptr)(area_p, w);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_set_width_obj, 2, mp_lv_area_set_width, lv_area_set_width);
    
/* Reusing lv_area_set_width for lv_area_set_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_set_height_obj, 2, mp_lv_area_set_width, lv_area_set_height);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_area_get_size(const lv_area_t *area_p)
 */
 
STATIC mp_obj_t mp_lv_area_get_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_area_t *area_p = mp_write_ptr_lv_area_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(const lv_area_t *))lv_func_ptr)(area_p);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_area_get_size_obj, 1, mp_lv_area_get_size, lv_area_get_size);
    

STATIC const mp_rom_map_elem_t mp_lv_area_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_area_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_copy), MP_ROM_PTR(&mp_lv_area_copy_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_width), MP_ROM_PTR(&mp_lv_area_get_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_height), MP_ROM_PTR(&mp_lv_area_get_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_set), MP_ROM_PTR(&mp_lv_area_set_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_width), MP_ROM_PTR(&mp_lv_area_set_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_height), MP_ROM_PTR(&mp_lv_area_set_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_size), MP_ROM_PTR(&mp_lv_area_get_size_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_area_t_locals_dict, mp_lv_area_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static void lv_style_set_radius(lv_style_t *style, lv_state_t state, lv_style_int_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_radius(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_int_t value = (int16_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_style_t *, lv_state_t, lv_style_int_t))lv_func_ptr)(style, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_radius_obj, 3, mp_lv_style_set_radius, lv_style_set_radius);
    

/*
 * lvgl extension definition for:
 * inline static void lv_style_set_clip_corner(lv_style_t *style, lv_state_t state, bool value)
 */
 
STATIC mp_obj_t mp_lv_style_set_clip_corner(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[1]);
    bool value = mp_obj_is_true(mp_args[2]);
    ((void (*)(lv_style_t *, lv_state_t, bool))lv_func_ptr)(style, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_clip_corner_obj, 3, mp_lv_style_set_clip_corner, lv_style_set_clip_corner);
    
/* Reusing lv_style_set_radius for lv_style_set_size */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_size_obj, 3, mp_lv_style_set_radius, lv_style_set_size);
    
/* Reusing lv_style_set_radius for lv_style_set_transform_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transform_width_obj, 3, mp_lv_style_set_radius, lv_style_set_transform_width);
    
/* Reusing lv_style_set_radius for lv_style_set_transform_height */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transform_height_obj, 3, mp_lv_style_set_radius, lv_style_set_transform_height);
    
/* Reusing lv_style_set_radius for lv_style_set_transform_angle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transform_angle_obj, 3, mp_lv_style_set_radius, lv_style_set_transform_angle);
    
/* Reusing lv_style_set_radius for lv_style_set_transform_zoom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transform_zoom_obj, 3, mp_lv_style_set_radius, lv_style_set_transform_zoom);
    

/*
 * lvgl extension definition for:
 * inline static void lv_style_set_opa_scale(lv_style_t *style, lv_state_t state, lv_opa_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_opa_scale(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_opa_t value = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_style_t *, lv_state_t, lv_opa_t))lv_func_ptr)(style, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_opa_scale_obj, 3, mp_lv_style_set_opa_scale, lv_style_set_opa_scale);
    
/* Reusing lv_style_set_radius for lv_style_set_pad_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_top_obj, 3, mp_lv_style_set_radius, lv_style_set_pad_top);
    
/* Reusing lv_style_set_radius for lv_style_set_pad_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_bottom_obj, 3, mp_lv_style_set_radius, lv_style_set_pad_bottom);
    
/* Reusing lv_style_set_radius for lv_style_set_pad_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_left_obj, 3, mp_lv_style_set_radius, lv_style_set_pad_left);
    
/* Reusing lv_style_set_radius for lv_style_set_pad_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_right_obj, 3, mp_lv_style_set_radius, lv_style_set_pad_right);
    
/* Reusing lv_style_set_radius for lv_style_set_pad_inner */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_inner_obj, 3, mp_lv_style_set_radius, lv_style_set_pad_inner);
    
/* Reusing lv_style_set_radius for lv_style_set_margin_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_margin_top_obj, 3, mp_lv_style_set_radius, lv_style_set_margin_top);
    
/* Reusing lv_style_set_radius for lv_style_set_margin_bottom */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_margin_bottom_obj, 3, mp_lv_style_set_radius, lv_style_set_margin_bottom);
    
/* Reusing lv_style_set_radius for lv_style_set_margin_left */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_margin_left_obj, 3, mp_lv_style_set_radius, lv_style_set_margin_left);
    
/* Reusing lv_style_set_radius for lv_style_set_margin_right */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_margin_right_obj, 3, mp_lv_style_set_radius, lv_style_set_margin_right);
    

/*
 * lvgl extension definition for:
 * inline static void lv_style_set_bg_blend_mode(lv_style_t *style, lv_state_t state, lv_blend_mode_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_bg_blend_mode(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_blend_mode_t value = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_style_t *, lv_state_t, lv_blend_mode_t))lv_func_ptr)(style, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_blend_mode_obj, 3, mp_lv_style_set_bg_blend_mode, lv_style_set_bg_blend_mode);
    
/* Reusing lv_style_set_radius for lv_style_set_bg_main_stop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_main_stop_obj, 3, mp_lv_style_set_radius, lv_style_set_bg_main_stop);
    
/* Reusing lv_style_set_radius for lv_style_set_bg_grad_stop */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_grad_stop_obj, 3, mp_lv_style_set_radius, lv_style_set_bg_grad_stop);
    

/*
 * lvgl extension definition for:
 * inline static void lv_style_set_bg_grad_dir(lv_style_t *style, lv_state_t state, lv_grad_dir_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_bg_grad_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_grad_dir_t value = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_style_t *, lv_state_t, lv_grad_dir_t))lv_func_ptr)(style, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_grad_dir_obj, 3, mp_lv_style_set_bg_grad_dir, lv_style_set_bg_grad_dir);
    

/*
 * lvgl extension definition for:
 * inline static void lv_style_set_bg_color(lv_style_t *style, lv_state_t state, lv_color_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_bg_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_color_t value = mp_write_lv_color32_t(mp_args[2]);
    ((void (*)(lv_style_t *, lv_state_t, lv_color_t))lv_func_ptr)(style, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_color_obj, 3, mp_lv_style_set_bg_color, lv_style_set_bg_color);
    
/* Reusing lv_style_set_bg_color for lv_style_set_bg_grad_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_grad_color_obj, 3, mp_lv_style_set_bg_color, lv_style_set_bg_grad_color);
    
/* Reusing lv_style_set_opa_scale for lv_style_set_bg_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_bg_opa_obj, 3, mp_lv_style_set_opa_scale, lv_style_set_bg_opa);
    
/* Reusing lv_style_set_radius for lv_style_set_border_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_border_width_obj, 3, mp_lv_style_set_radius, lv_style_set_border_width);
    

/*
 * lvgl extension definition for:
 * inline static void lv_style_set_border_side(lv_style_t *style, lv_state_t state, lv_border_side_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_border_side(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_border_side_t value = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_style_t *, lv_state_t, lv_border_side_t))lv_func_ptr)(style, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_border_side_obj, 3, mp_lv_style_set_border_side, lv_style_set_border_side);
    
/* Reusing lv_style_set_bg_blend_mode for lv_style_set_border_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_border_blend_mode_obj, 3, mp_lv_style_set_bg_blend_mode, lv_style_set_border_blend_mode);
    
/* Reusing lv_style_set_clip_corner for lv_style_set_border_post */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_border_post_obj, 3, mp_lv_style_set_clip_corner, lv_style_set_border_post);
    
/* Reusing lv_style_set_bg_color for lv_style_set_border_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_border_color_obj, 3, mp_lv_style_set_bg_color, lv_style_set_border_color);
    
/* Reusing lv_style_set_opa_scale for lv_style_set_border_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_border_opa_obj, 3, mp_lv_style_set_opa_scale, lv_style_set_border_opa);
    
/* Reusing lv_style_set_radius for lv_style_set_outline_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_outline_width_obj, 3, mp_lv_style_set_radius, lv_style_set_outline_width);
    
/* Reusing lv_style_set_radius for lv_style_set_outline_pad */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_outline_pad_obj, 3, mp_lv_style_set_radius, lv_style_set_outline_pad);
    
/* Reusing lv_style_set_bg_blend_mode for lv_style_set_outline_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_outline_blend_mode_obj, 3, mp_lv_style_set_bg_blend_mode, lv_style_set_outline_blend_mode);
    
/* Reusing lv_style_set_bg_color for lv_style_set_outline_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_outline_color_obj, 3, mp_lv_style_set_bg_color, lv_style_set_outline_color);
    
/* Reusing lv_style_set_opa_scale for lv_style_set_outline_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_outline_opa_obj, 3, mp_lv_style_set_opa_scale, lv_style_set_outline_opa);
    
/* Reusing lv_style_set_radius for lv_style_set_shadow_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_shadow_width_obj, 3, mp_lv_style_set_radius, lv_style_set_shadow_width);
    
/* Reusing lv_style_set_radius for lv_style_set_shadow_ofs_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_shadow_ofs_x_obj, 3, mp_lv_style_set_radius, lv_style_set_shadow_ofs_x);
    
/* Reusing lv_style_set_radius for lv_style_set_shadow_ofs_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_shadow_ofs_y_obj, 3, mp_lv_style_set_radius, lv_style_set_shadow_ofs_y);
    
/* Reusing lv_style_set_radius for lv_style_set_shadow_spread */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_shadow_spread_obj, 3, mp_lv_style_set_radius, lv_style_set_shadow_spread);
    
/* Reusing lv_style_set_bg_blend_mode for lv_style_set_shadow_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_shadow_blend_mode_obj, 3, mp_lv_style_set_bg_blend_mode, lv_style_set_shadow_blend_mode);
    
/* Reusing lv_style_set_bg_color for lv_style_set_shadow_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_shadow_color_obj, 3, mp_lv_style_set_bg_color, lv_style_set_shadow_color);
    
/* Reusing lv_style_set_opa_scale for lv_style_set_shadow_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_shadow_opa_obj, 3, mp_lv_style_set_opa_scale, lv_style_set_shadow_opa);
    
/* Reusing lv_style_set_clip_corner for lv_style_set_pattern_repeat */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pattern_repeat_obj, 3, mp_lv_style_set_clip_corner, lv_style_set_pattern_repeat);
    
/* Reusing lv_style_set_bg_blend_mode for lv_style_set_pattern_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pattern_blend_mode_obj, 3, mp_lv_style_set_bg_blend_mode, lv_style_set_pattern_blend_mode);
    
/* Reusing lv_style_set_bg_color for lv_style_set_pattern_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pattern_recolor_obj, 3, mp_lv_style_set_bg_color, lv_style_set_pattern_recolor);
    
/* Reusing lv_style_set_opa_scale for lv_style_set_pattern_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pattern_opa_obj, 3, mp_lv_style_set_opa_scale, lv_style_set_pattern_opa);
    
/* Reusing lv_style_set_opa_scale for lv_style_set_pattern_recolor_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pattern_recolor_opa_obj, 3, mp_lv_style_set_opa_scale, lv_style_set_pattern_recolor_opa);
    

/*
 * lvgl extension definition for:
 * inline static void lv_style_set_pattern_image(lv_style_t *style, lv_state_t state, const void *value)
 */
 
STATIC mp_obj_t mp_lv_style_set_pattern_image(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[1]);
    const void *value = mp_to_ptr(mp_args[2]);
    ((void (*)(lv_style_t *, lv_state_t, const void *))lv_func_ptr)(style, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pattern_image_obj, 3, mp_lv_style_set_pattern_image, lv_style_set_pattern_image);
    
/* Reusing lv_style_set_radius for lv_style_set_value_letter_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_value_letter_space_obj, 3, mp_lv_style_set_radius, lv_style_set_value_letter_space);
    
/* Reusing lv_style_set_radius for lv_style_set_value_line_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_value_line_space_obj, 3, mp_lv_style_set_radius, lv_style_set_value_line_space);
    
/* Reusing lv_style_set_bg_blend_mode for lv_style_set_value_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_value_blend_mode_obj, 3, mp_lv_style_set_bg_blend_mode, lv_style_set_value_blend_mode);
    
/* Reusing lv_style_set_radius for lv_style_set_value_ofs_x */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_value_ofs_x_obj, 3, mp_lv_style_set_radius, lv_style_set_value_ofs_x);
    
/* Reusing lv_style_set_radius for lv_style_set_value_ofs_y */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_value_ofs_y_obj, 3, mp_lv_style_set_radius, lv_style_set_value_ofs_y);
    

/*
 * lvgl extension definition for:
 * inline static void lv_style_set_value_align(lv_style_t *style, lv_state_t state, lv_align_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_value_align(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_align_t value = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_style_t *, lv_state_t, lv_align_t))lv_func_ptr)(style, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_value_align_obj, 3, mp_lv_style_set_value_align, lv_style_set_value_align);
    
/* Reusing lv_style_set_bg_color for lv_style_set_value_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_value_color_obj, 3, mp_lv_style_set_bg_color, lv_style_set_value_color);
    
/* Reusing lv_style_set_opa_scale for lv_style_set_value_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_value_opa_obj, 3, mp_lv_style_set_opa_scale, lv_style_set_value_opa);
    

/*
 * lvgl extension definition for:
 * inline static void lv_style_set_value_font(lv_style_t *style, lv_state_t state, const lv_font_t *value)
 */
 
STATIC mp_obj_t mp_lv_style_set_value_font(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[1]);
    const lv_font_t *value = mp_write_ptr_lv_font_t(mp_args[2]);
    ((void (*)(lv_style_t *, lv_state_t, const lv_font_t *))lv_func_ptr)(style, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_value_font_obj, 3, mp_lv_style_set_value_font, lv_style_set_value_font);
    

/*
 * lvgl extension definition for:
 * inline static void lv_style_set_value_str(lv_style_t *style, lv_state_t state, const char *value)
 */
 
STATIC mp_obj_t mp_lv_style_set_value_str(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[1]);
    const char *value = (char*)convert_from_str(mp_args[2]);
    ((void (*)(lv_style_t *, lv_state_t, const char *))lv_func_ptr)(style, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_value_str_obj, 3, mp_lv_style_set_value_str, lv_style_set_value_str);
    
/* Reusing lv_style_set_radius for lv_style_set_text_letter_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_text_letter_space_obj, 3, mp_lv_style_set_radius, lv_style_set_text_letter_space);
    
/* Reusing lv_style_set_radius for lv_style_set_text_line_space */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_text_line_space_obj, 3, mp_lv_style_set_radius, lv_style_set_text_line_space);
    

/*
 * lvgl extension definition for:
 * inline static void lv_style_set_text_decor(lv_style_t *style, lv_state_t state, lv_text_decor_t value)
 */
 
STATIC mp_obj_t mp_lv_style_set_text_decor(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_text_decor_t value = (uint8_t)mp_obj_get_int(mp_args[2]);
    ((void (*)(lv_style_t *, lv_state_t, lv_text_decor_t))lv_func_ptr)(style, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_text_decor_obj, 3, mp_lv_style_set_text_decor, lv_style_set_text_decor);
    
/* Reusing lv_style_set_bg_blend_mode for lv_style_set_text_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_text_blend_mode_obj, 3, mp_lv_style_set_bg_blend_mode, lv_style_set_text_blend_mode);
    
/* Reusing lv_style_set_bg_color for lv_style_set_text_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_text_color_obj, 3, mp_lv_style_set_bg_color, lv_style_set_text_color);
    
/* Reusing lv_style_set_bg_color for lv_style_set_text_sel_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_text_sel_color_obj, 3, mp_lv_style_set_bg_color, lv_style_set_text_sel_color);
    
/* Reusing lv_style_set_bg_color for lv_style_set_text_sel_bg_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_text_sel_bg_color_obj, 3, mp_lv_style_set_bg_color, lv_style_set_text_sel_bg_color);
    
/* Reusing lv_style_set_opa_scale for lv_style_set_text_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_text_opa_obj, 3, mp_lv_style_set_opa_scale, lv_style_set_text_opa);
    
/* Reusing lv_style_set_value_font for lv_style_set_text_font */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_text_font_obj, 3, mp_lv_style_set_value_font, lv_style_set_text_font);
    
/* Reusing lv_style_set_radius for lv_style_set_line_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_line_width_obj, 3, mp_lv_style_set_radius, lv_style_set_line_width);
    
/* Reusing lv_style_set_bg_blend_mode for lv_style_set_line_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_line_blend_mode_obj, 3, mp_lv_style_set_bg_blend_mode, lv_style_set_line_blend_mode);
    
/* Reusing lv_style_set_radius for lv_style_set_line_dash_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_line_dash_width_obj, 3, mp_lv_style_set_radius, lv_style_set_line_dash_width);
    
/* Reusing lv_style_set_radius for lv_style_set_line_dash_gap */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_line_dash_gap_obj, 3, mp_lv_style_set_radius, lv_style_set_line_dash_gap);
    
/* Reusing lv_style_set_clip_corner for lv_style_set_line_rounded */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_line_rounded_obj, 3, mp_lv_style_set_clip_corner, lv_style_set_line_rounded);
    
/* Reusing lv_style_set_bg_color for lv_style_set_line_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_line_color_obj, 3, mp_lv_style_set_bg_color, lv_style_set_line_color);
    
/* Reusing lv_style_set_opa_scale for lv_style_set_line_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_line_opa_obj, 3, mp_lv_style_set_opa_scale, lv_style_set_line_opa);
    
/* Reusing lv_style_set_bg_blend_mode for lv_style_set_image_blend_mode */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_image_blend_mode_obj, 3, mp_lv_style_set_bg_blend_mode, lv_style_set_image_blend_mode);
    
/* Reusing lv_style_set_bg_color for lv_style_set_image_recolor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_image_recolor_obj, 3, mp_lv_style_set_bg_color, lv_style_set_image_recolor);
    
/* Reusing lv_style_set_opa_scale for lv_style_set_image_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_image_opa_obj, 3, mp_lv_style_set_opa_scale, lv_style_set_image_opa);
    
/* Reusing lv_style_set_opa_scale for lv_style_set_image_recolor_opa */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_image_recolor_opa_obj, 3, mp_lv_style_set_opa_scale, lv_style_set_image_recolor_opa);
    
/* Reusing lv_style_set_radius for lv_style_set_transition_time */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transition_time_obj, 3, mp_lv_style_set_radius, lv_style_set_transition_time);
    
/* Reusing lv_style_set_radius for lv_style_set_transition_delay */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transition_delay_obj, 3, mp_lv_style_set_radius, lv_style_set_transition_delay);
    
/* Reusing lv_style_set_radius for lv_style_set_transition_prop_1 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transition_prop_1_obj, 3, mp_lv_style_set_radius, lv_style_set_transition_prop_1);
    
/* Reusing lv_style_set_radius for lv_style_set_transition_prop_2 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transition_prop_2_obj, 3, mp_lv_style_set_radius, lv_style_set_transition_prop_2);
    
/* Reusing lv_style_set_radius for lv_style_set_transition_prop_3 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transition_prop_3_obj, 3, mp_lv_style_set_radius, lv_style_set_transition_prop_3);
    
/* Reusing lv_style_set_radius for lv_style_set_transition_prop_4 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transition_prop_4_obj, 3, mp_lv_style_set_radius, lv_style_set_transition_prop_4);
    
/* Reusing lv_style_set_radius for lv_style_set_transition_prop_5 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transition_prop_5_obj, 3, mp_lv_style_set_radius, lv_style_set_transition_prop_5);
    
/* Reusing lv_style_set_radius for lv_style_set_transition_prop_6 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transition_prop_6_obj, 3, mp_lv_style_set_radius, lv_style_set_transition_prop_6);
    

/*
 * lvgl extension definition for:
 * inline static void lv_style_set_transition_path(lv_style_t *style, lv_state_t state, lv_anim_path_t *value)
 */
 
STATIC mp_obj_t mp_lv_style_set_transition_path(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_state_t state = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_anim_path_t *value = mp_write_ptr_lv_anim_path_t(mp_args[2]);
    ((void (*)(lv_style_t *, lv_state_t, lv_anim_path_t *))lv_func_ptr)(style, state, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_transition_path_obj, 3, mp_lv_style_set_transition_path, lv_style_set_transition_path);
    
/* Reusing lv_style_set_radius for lv_style_set_scale_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_scale_width_obj, 3, mp_lv_style_set_radius, lv_style_set_scale_width);
    
/* Reusing lv_style_set_radius for lv_style_set_scale_border_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_scale_border_width_obj, 3, mp_lv_style_set_radius, lv_style_set_scale_border_width);
    
/* Reusing lv_style_set_radius for lv_style_set_scale_end_border_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_scale_end_border_width_obj, 3, mp_lv_style_set_radius, lv_style_set_scale_end_border_width);
    
/* Reusing lv_style_set_radius for lv_style_set_scale_end_line_width */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_scale_end_line_width_obj, 3, mp_lv_style_set_radius, lv_style_set_scale_end_line_width);
    
/* Reusing lv_style_set_bg_color for lv_style_set_scale_grad_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_scale_grad_color_obj, 3, mp_lv_style_set_bg_color, lv_style_set_scale_grad_color);
    
/* Reusing lv_style_set_bg_color for lv_style_set_scale_end_color */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_scale_end_color_obj, 3, mp_lv_style_set_bg_color, lv_style_set_scale_end_color);
    
/* Reusing lv_style_set_radius for lv_style_set_pad_all */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_all_obj, 3, mp_lv_style_set_radius, lv_style_set_pad_all);
    
/* Reusing lv_style_set_radius for lv_style_set_pad_hor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_hor_obj, 3, mp_lv_style_set_radius, lv_style_set_pad_hor);
    
/* Reusing lv_style_set_radius for lv_style_set_pad_ver */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_pad_ver_obj, 3, mp_lv_style_set_radius, lv_style_set_pad_ver);
    
/* Reusing lv_style_set_radius for lv_style_set_margin_all */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_margin_all_obj, 3, mp_lv_style_set_radius, lv_style_set_margin_all);
    
/* Reusing lv_style_set_radius for lv_style_set_margin_hor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_margin_hor_obj, 3, mp_lv_style_set_radius, lv_style_set_margin_hor);
    
/* Reusing lv_style_set_radius for lv_style_set_margin_ver */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_set_margin_ver_obj, 3, mp_lv_style_set_radius, lv_style_set_margin_ver);
    
/* Reusing lv_obj_report_style_mod for lv_style_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_init_obj, 1, mp_lv_obj_report_style_mod, lv_style_init);
    

/*
 * lvgl extension definition for:
 * void lv_style_copy(lv_style_t *style_dest, const lv_style_t *style_src)
 */
 
STATIC mp_obj_t mp_lv_style_copy(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style_dest = mp_write_ptr_lv_style_t(mp_args[0]);
    const lv_style_t *style_src = mp_write_ptr_lv_style_t(mp_args[1]);
    ((void (*)(lv_style_t *, const lv_style_t *))lv_func_ptr)(style_dest, style_src);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_copy_obj, 2, mp_lv_style_copy, lv_style_copy);
    
/* Reusing lv_obj_report_style_mod for lv_style_reset */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_reset_obj, 1, mp_lv_obj_report_style_mod, lv_style_reset);
    

/*
 * lvgl extension definition for:
 * bool lv_style_remove_prop(lv_style_t *style, lv_style_property_t prop)
 */
 
STATIC mp_obj_t mp_lv_style_remove_prop(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    lv_style_property_t prop = (uint16_t)mp_obj_get_int(mp_args[1]);
    bool _res = ((bool (*)(lv_style_t *, lv_style_property_t))lv_func_ptr)(style, prop);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_remove_prop_obj, 2, mp_lv_style_remove_prop, lv_style_remove_prop);
    

STATIC const mp_rom_map_elem_t mp_lv_style_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_style_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_radius), MP_ROM_PTR(&mp_lv_style_set_radius_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_clip_corner), MP_ROM_PTR(&mp_lv_style_set_clip_corner_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_size), MP_ROM_PTR(&mp_lv_style_set_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_transform_width), MP_ROM_PTR(&mp_lv_style_set_transform_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_transform_height), MP_ROM_PTR(&mp_lv_style_set_transform_height_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_transform_angle), MP_ROM_PTR(&mp_lv_style_set_transform_angle_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_transform_zoom), MP_ROM_PTR(&mp_lv_style_set_transform_zoom_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_opa_scale), MP_ROM_PTR(&mp_lv_style_set_opa_scale_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_top), MP_ROM_PTR(&mp_lv_style_set_pad_top_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_bottom), MP_ROM_PTR(&mp_lv_style_set_pad_bottom_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_left), MP_ROM_PTR(&mp_lv_style_set_pad_left_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_right), MP_ROM_PTR(&mp_lv_style_set_pad_right_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_inner), MP_ROM_PTR(&mp_lv_style_set_pad_inner_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_margin_top), MP_ROM_PTR(&mp_lv_style_set_margin_top_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_margin_bottom), MP_ROM_PTR(&mp_lv_style_set_margin_bottom_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_margin_left), MP_ROM_PTR(&mp_lv_style_set_margin_left_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_margin_right), MP_ROM_PTR(&mp_lv_style_set_margin_right_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_blend_mode), MP_ROM_PTR(&mp_lv_style_set_bg_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_main_stop), MP_ROM_PTR(&mp_lv_style_set_bg_main_stop_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_grad_stop), MP_ROM_PTR(&mp_lv_style_set_bg_grad_stop_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_grad_dir), MP_ROM_PTR(&mp_lv_style_set_bg_grad_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_color), MP_ROM_PTR(&mp_lv_style_set_bg_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_grad_color), MP_ROM_PTR(&mp_lv_style_set_bg_grad_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_opa), MP_ROM_PTR(&mp_lv_style_set_bg_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_border_width), MP_ROM_PTR(&mp_lv_style_set_border_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_border_side), MP_ROM_PTR(&mp_lv_style_set_border_side_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_border_blend_mode), MP_ROM_PTR(&mp_lv_style_set_border_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_border_post), MP_ROM_PTR(&mp_lv_style_set_border_post_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_border_color), MP_ROM_PTR(&mp_lv_style_set_border_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_border_opa), MP_ROM_PTR(&mp_lv_style_set_border_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_outline_width), MP_ROM_PTR(&mp_lv_style_set_outline_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_outline_pad), MP_ROM_PTR(&mp_lv_style_set_outline_pad_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_outline_blend_mode), MP_ROM_PTR(&mp_lv_style_set_outline_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_outline_color), MP_ROM_PTR(&mp_lv_style_set_outline_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_outline_opa), MP_ROM_PTR(&mp_lv_style_set_outline_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_shadow_width), MP_ROM_PTR(&mp_lv_style_set_shadow_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_shadow_ofs_x), MP_ROM_PTR(&mp_lv_style_set_shadow_ofs_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_shadow_ofs_y), MP_ROM_PTR(&mp_lv_style_set_shadow_ofs_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_shadow_spread), MP_ROM_PTR(&mp_lv_style_set_shadow_spread_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_shadow_blend_mode), MP_ROM_PTR(&mp_lv_style_set_shadow_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_shadow_color), MP_ROM_PTR(&mp_lv_style_set_shadow_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_shadow_opa), MP_ROM_PTR(&mp_lv_style_set_shadow_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pattern_repeat), MP_ROM_PTR(&mp_lv_style_set_pattern_repeat_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pattern_blend_mode), MP_ROM_PTR(&mp_lv_style_set_pattern_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pattern_recolor), MP_ROM_PTR(&mp_lv_style_set_pattern_recolor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pattern_opa), MP_ROM_PTR(&mp_lv_style_set_pattern_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pattern_recolor_opa), MP_ROM_PTR(&mp_lv_style_set_pattern_recolor_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pattern_image), MP_ROM_PTR(&mp_lv_style_set_pattern_image_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_value_letter_space), MP_ROM_PTR(&mp_lv_style_set_value_letter_space_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_value_line_space), MP_ROM_PTR(&mp_lv_style_set_value_line_space_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_value_blend_mode), MP_ROM_PTR(&mp_lv_style_set_value_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_value_ofs_x), MP_ROM_PTR(&mp_lv_style_set_value_ofs_x_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_value_ofs_y), MP_ROM_PTR(&mp_lv_style_set_value_ofs_y_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_value_align), MP_ROM_PTR(&mp_lv_style_set_value_align_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_value_color), MP_ROM_PTR(&mp_lv_style_set_value_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_value_opa), MP_ROM_PTR(&mp_lv_style_set_value_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_value_font), MP_ROM_PTR(&mp_lv_style_set_value_font_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_value_str), MP_ROM_PTR(&mp_lv_style_set_value_str_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_letter_space), MP_ROM_PTR(&mp_lv_style_set_text_letter_space_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_line_space), MP_ROM_PTR(&mp_lv_style_set_text_line_space_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_decor), MP_ROM_PTR(&mp_lv_style_set_text_decor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_blend_mode), MP_ROM_PTR(&mp_lv_style_set_text_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_color), MP_ROM_PTR(&mp_lv_style_set_text_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_sel_color), MP_ROM_PTR(&mp_lv_style_set_text_sel_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_sel_bg_color), MP_ROM_PTR(&mp_lv_style_set_text_sel_bg_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_opa), MP_ROM_PTR(&mp_lv_style_set_text_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_text_font), MP_ROM_PTR(&mp_lv_style_set_text_font_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_line_width), MP_ROM_PTR(&mp_lv_style_set_line_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_line_blend_mode), MP_ROM_PTR(&mp_lv_style_set_line_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_line_dash_width), MP_ROM_PTR(&mp_lv_style_set_line_dash_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_line_dash_gap), MP_ROM_PTR(&mp_lv_style_set_line_dash_gap_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_line_rounded), MP_ROM_PTR(&mp_lv_style_set_line_rounded_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_line_color), MP_ROM_PTR(&mp_lv_style_set_line_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_line_opa), MP_ROM_PTR(&mp_lv_style_set_line_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_image_blend_mode), MP_ROM_PTR(&mp_lv_style_set_image_blend_mode_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_image_recolor), MP_ROM_PTR(&mp_lv_style_set_image_recolor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_image_opa), MP_ROM_PTR(&mp_lv_style_set_image_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_image_recolor_opa), MP_ROM_PTR(&mp_lv_style_set_image_recolor_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_transition_time), MP_ROM_PTR(&mp_lv_style_set_transition_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_transition_delay), MP_ROM_PTR(&mp_lv_style_set_transition_delay_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_transition_prop_1), MP_ROM_PTR(&mp_lv_style_set_transition_prop_1_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_transition_prop_2), MP_ROM_PTR(&mp_lv_style_set_transition_prop_2_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_transition_prop_3), MP_ROM_PTR(&mp_lv_style_set_transition_prop_3_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_transition_prop_4), MP_ROM_PTR(&mp_lv_style_set_transition_prop_4_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_transition_prop_5), MP_ROM_PTR(&mp_lv_style_set_transition_prop_5_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_transition_prop_6), MP_ROM_PTR(&mp_lv_style_set_transition_prop_6_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_transition_path), MP_ROM_PTR(&mp_lv_style_set_transition_path_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scale_width), MP_ROM_PTR(&mp_lv_style_set_scale_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scale_border_width), MP_ROM_PTR(&mp_lv_style_set_scale_border_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scale_end_border_width), MP_ROM_PTR(&mp_lv_style_set_scale_end_border_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scale_end_line_width), MP_ROM_PTR(&mp_lv_style_set_scale_end_line_width_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scale_grad_color), MP_ROM_PTR(&mp_lv_style_set_scale_grad_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_scale_end_color), MP_ROM_PTR(&mp_lv_style_set_scale_end_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_all), MP_ROM_PTR(&mp_lv_style_set_pad_all_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_hor), MP_ROM_PTR(&mp_lv_style_set_pad_hor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_pad_ver), MP_ROM_PTR(&mp_lv_style_set_pad_ver_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_margin_all), MP_ROM_PTR(&mp_lv_style_set_margin_all_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_margin_hor), MP_ROM_PTR(&mp_lv_style_set_margin_hor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_margin_ver), MP_ROM_PTR(&mp_lv_style_set_margin_ver_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_style_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_copy), MP_ROM_PTR(&mp_lv_style_copy_obj) },
    { MP_ROM_QSTR(MP_QSTR_reset), MP_ROM_PTR(&mp_lv_style_reset_obj) },
    { MP_ROM_QSTR(MP_QSTR_copy), MP_ROM_PTR(&mp_lv_style_copy_obj) },
    { MP_ROM_QSTR(MP_QSTR_remove_prop), MP_ROM_PTR(&mp_lv_style_remove_prop_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_style_t_locals_dict, mp_lv_style_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_disp_drv_update(lv_disp_t *disp, lv_disp_drv_t *new_drv)
 */
 
STATIC mp_obj_t mp_lv_disp_drv_update(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_disp_drv_t *new_drv = mp_write_ptr_lv_disp_drv_t(mp_args[1]);
    ((void (*)(lv_disp_t *, lv_disp_drv_t *))lv_func_ptr)(disp, new_drv);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_drv_update_obj, 2, mp_lv_disp_drv_update, lv_disp_drv_update);
    

/*
 * lvgl extension definition for:
 * void lv_disp_remove(lv_disp_t *disp)
 */
 
STATIC mp_obj_t mp_lv_disp_remove(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    ((void (*)(lv_disp_t *))lv_func_ptr)(disp);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_remove_obj, 1, mp_lv_disp_remove, lv_disp_remove);
    
/* Reusing lv_disp_remove for lv_disp_set_default */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_set_default_obj, 1, mp_lv_disp_remove, lv_disp_set_default);
    

/*
 * lvgl extension definition for:
 * lv_coord_t lv_disp_get_hor_res(lv_disp_t *disp)
 */
 
STATIC mp_obj_t mp_lv_disp_get_hor_res(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_coord_t _res = ((lv_coord_t (*)(lv_disp_t *))lv_func_ptr)(disp);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_hor_res_obj, 1, mp_lv_disp_get_hor_res, lv_disp_get_hor_res);
    
/* Reusing lv_disp_get_hor_res for lv_disp_get_ver_res */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_ver_res_obj, 1, mp_lv_disp_get_hor_res, lv_disp_get_ver_res);
    

/*
 * lvgl extension definition for:
 * bool lv_disp_get_antialiasing(lv_disp_t *disp)
 */
 
STATIC mp_obj_t mp_lv_disp_get_antialiasing(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    bool _res = ((bool (*)(lv_disp_t *))lv_func_ptr)(disp);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_antialiasing_obj, 1, mp_lv_disp_get_antialiasing, lv_disp_get_antialiasing);
    
/* Reusing lv_disp_get_hor_res for lv_disp_get_dpi */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_dpi_obj, 1, mp_lv_disp_get_hor_res, lv_disp_get_dpi);
    

/*
 * lvgl extension definition for:
 * lv_disp_size_t lv_disp_get_size_category(lv_disp_t *disp)
 */
 
STATIC mp_obj_t mp_lv_disp_get_size_category(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_disp_size_t _res = ((lv_disp_size_t (*)(lv_disp_t *))lv_func_ptr)(disp);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_size_category_obj, 1, mp_lv_disp_get_size_category, lv_disp_get_size_category);
    

/*
 * lvgl extension definition for:
 * lv_disp_t *lv_disp_get_next(lv_disp_t *disp)
 */
 
STATIC mp_obj_t mp_lv_disp_get_next(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_disp_t * _res = ((lv_disp_t *(*)(lv_disp_t *))lv_func_ptr)(disp);
    return mp_read_ptr_lv_disp_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_next_obj, 1, mp_lv_disp_get_next, lv_disp_get_next);
    

/*
 * lvgl extension definition for:
 * lv_disp_buf_t *lv_disp_get_buf(lv_disp_t *disp)
 */
 
STATIC mp_obj_t mp_lv_disp_get_buf(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_disp_buf_t * _res = ((lv_disp_buf_t *(*)(lv_disp_t *))lv_func_ptr)(disp);
    return mp_read_ptr_lv_disp_buf_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_buf_obj, 1, mp_lv_disp_get_buf, lv_disp_get_buf);
    

/*
 * lvgl extension definition for:
 * uint16_t lv_disp_get_inv_buf_size(lv_disp_t *disp)
 */
 
STATIC mp_obj_t mp_lv_disp_get_inv_buf_size(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    uint16_t _res = ((uint16_t (*)(lv_disp_t *))lv_func_ptr)(disp);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_inv_buf_size_obj, 1, mp_lv_disp_get_inv_buf_size, lv_disp_get_inv_buf_size);
    
/* Reusing lv_disp_get_antialiasing for lv_disp_is_double_buf */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_is_double_buf_obj, 1, mp_lv_disp_get_antialiasing, lv_disp_is_double_buf);
    
/* Reusing lv_disp_get_antialiasing for lv_disp_is_true_double_buf */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_is_true_double_buf_obj, 1, mp_lv_disp_get_antialiasing, lv_disp_is_true_double_buf);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_disp_get_scr_act(lv_disp_t *disp)
 */
 
STATIC mp_obj_t mp_lv_disp_get_scr_act(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_disp_t *))lv_func_ptr)(disp);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_scr_act_obj, 1, mp_lv_disp_get_scr_act, lv_disp_get_scr_act);
    
/* Reusing lv_disp_get_scr_act for lv_disp_get_scr_prev */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_scr_prev_obj, 1, mp_lv_disp_get_scr_act, lv_disp_get_scr_prev);
    
/* Reusing lv_disp_get_scr_act for lv_disp_get_layer_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_layer_top_obj, 1, mp_lv_disp_get_scr_act, lv_disp_get_layer_top);
    
/* Reusing lv_disp_get_scr_act for lv_disp_get_layer_sys */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_layer_sys_obj, 1, mp_lv_disp_get_scr_act, lv_disp_get_layer_sys);
    

/*
 * lvgl extension definition for:
 * void lv_disp_assign_screen(lv_disp_t *disp, lv_obj_t *scr)
 */
 
STATIC mp_obj_t mp_lv_disp_assign_screen(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_obj_t *scr = mp_to_lv(mp_args[1]);
    ((void (*)(lv_disp_t *, lv_obj_t *))lv_func_ptr)(disp, scr);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_assign_screen_obj, 2, mp_lv_disp_assign_screen, lv_disp_assign_screen);
    

/*
 * lvgl extension definition for:
 * void lv_disp_set_bg_color(lv_disp_t *disp, lv_color_t color)
 */
 
STATIC mp_obj_t mp_lv_disp_set_bg_color(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_color_t color = mp_write_lv_color32_t(mp_args[1]);
    ((void (*)(lv_disp_t *, lv_color_t))lv_func_ptr)(disp, color);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_set_bg_color_obj, 2, mp_lv_disp_set_bg_color, lv_disp_set_bg_color);
    

/*
 * lvgl extension definition for:
 * void lv_disp_set_bg_image(lv_disp_t *disp, const void *img_src)
 */
 
STATIC mp_obj_t mp_lv_disp_set_bg_image(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    const void *img_src = mp_to_ptr(mp_args[1]);
    ((void (*)(lv_disp_t *, const void *))lv_func_ptr)(disp, img_src);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_set_bg_image_obj, 2, mp_lv_disp_set_bg_image, lv_disp_set_bg_image);
    

/*
 * lvgl extension definition for:
 * void lv_disp_set_bg_opa(lv_disp_t *disp, lv_opa_t opa)
 */
 
STATIC mp_obj_t mp_lv_disp_set_bg_opa(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_opa_t opa = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_disp_t *, lv_opa_t))lv_func_ptr)(disp, opa);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_set_bg_opa_obj, 2, mp_lv_disp_set_bg_opa, lv_disp_set_bg_opa);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_disp_get_inactive_time(const lv_disp_t *disp)
 */
 
STATIC mp_obj_t mp_lv_disp_get_inactive_time(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_disp_t *disp = mp_write_ptr_lv_disp_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(const lv_disp_t *))lv_func_ptr)(disp);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_get_inactive_time_obj, 1, mp_lv_disp_get_inactive_time, lv_disp_get_inactive_time);
    
/* Reusing lv_disp_remove for lv_disp_trig_activity */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_trig_activity_obj, 1, mp_lv_disp_remove, lv_disp_trig_activity);
    
/* Reusing lv_disp_remove for lv_disp_clean_dcache */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_clean_dcache_obj, 1, mp_lv_disp_remove, lv_disp_clean_dcache);
    

STATIC const mp_rom_map_elem_t mp_lv_disp_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_disp_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_drv_update), MP_ROM_PTR(&mp_lv_disp_drv_update_obj) },
    { MP_ROM_QSTR(MP_QSTR_remove), MP_ROM_PTR(&mp_lv_disp_remove_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_default), MP_ROM_PTR(&mp_lv_disp_set_default_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_hor_res), MP_ROM_PTR(&mp_lv_disp_get_hor_res_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_ver_res), MP_ROM_PTR(&mp_lv_disp_get_ver_res_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_antialiasing), MP_ROM_PTR(&mp_lv_disp_get_antialiasing_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_dpi), MP_ROM_PTR(&mp_lv_disp_get_dpi_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_size_category), MP_ROM_PTR(&mp_lv_disp_get_size_category_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_next), MP_ROM_PTR(&mp_lv_disp_get_next_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_buf), MP_ROM_PTR(&mp_lv_disp_get_buf_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_inv_buf_size), MP_ROM_PTR(&mp_lv_disp_get_inv_buf_size_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_double_buf), MP_ROM_PTR(&mp_lv_disp_is_double_buf_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_true_double_buf), MP_ROM_PTR(&mp_lv_disp_is_true_double_buf_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scr_act), MP_ROM_PTR(&mp_lv_disp_get_scr_act_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_scr_prev), MP_ROM_PTR(&mp_lv_disp_get_scr_prev_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_layer_top), MP_ROM_PTR(&mp_lv_disp_get_layer_top_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_layer_sys), MP_ROM_PTR(&mp_lv_disp_get_layer_sys_obj) },
    { MP_ROM_QSTR(MP_QSTR_assign_screen), MP_ROM_PTR(&mp_lv_disp_assign_screen_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_color), MP_ROM_PTR(&mp_lv_disp_set_bg_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_image), MP_ROM_PTR(&mp_lv_disp_set_bg_image_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_bg_opa), MP_ROM_PTR(&mp_lv_disp_set_bg_opa_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_inactive_time), MP_ROM_PTR(&mp_lv_disp_get_inactive_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_trig_activity), MP_ROM_PTR(&mp_lv_disp_trig_activity_obj) },
    { MP_ROM_QSTR(MP_QSTR_clean_dcache), MP_ROM_PTR(&mp_lv_disp_clean_dcache_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_disp_t_locals_dict, mp_lv_disp_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_disp_drv_init(lv_disp_drv_t *driver)
 */
 
STATIC mp_obj_t mp_lv_disp_drv_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_drv_t *driver = mp_write_ptr_lv_disp_drv_t(mp_args[0]);
    ((void (*)(lv_disp_drv_t *))lv_func_ptr)(driver);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_drv_init_obj, 1, mp_lv_disp_drv_init, lv_disp_drv_init);
    

/*
 * lvgl extension definition for:
 * lv_disp_t *lv_disp_drv_register(lv_disp_drv_t *driver)
 */
 
STATIC mp_obj_t mp_lv_disp_drv_register(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_drv_t *driver = mp_write_ptr_lv_disp_drv_t(mp_args[0]);
    lv_disp_t * _res = ((lv_disp_t *(*)(lv_disp_drv_t *))lv_func_ptr)(driver);
    return mp_read_ptr_lv_disp_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_drv_register_obj, 1, mp_lv_disp_drv_register, lv_disp_drv_register);
    
/* Reusing lv_disp_drv_init for lv_disp_flush_ready */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_flush_ready_obj, 1, mp_lv_disp_drv_init, lv_disp_flush_ready);
    

/*
 * lvgl extension definition for:
 * bool lv_disp_flush_is_last(lv_disp_drv_t *disp_drv)
 */
 
STATIC mp_obj_t mp_lv_disp_flush_is_last(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_drv_t *disp_drv = mp_write_ptr_lv_disp_drv_t(mp_args[0]);
    bool _res = ((bool (*)(lv_disp_drv_t *))lv_func_ptr)(disp_drv);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_flush_is_last_obj, 1, mp_lv_disp_flush_is_last, lv_disp_flush_is_last);
    

STATIC const mp_rom_map_elem_t mp_lv_disp_drv_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_disp_drv_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_disp_drv_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_register), MP_ROM_PTR(&mp_lv_disp_drv_register_obj) },
    { MP_ROM_QSTR(MP_QSTR_flush_ready), MP_ROM_PTR(&mp_lv_disp_flush_ready_obj) },
    { MP_ROM_QSTR(MP_QSTR_flush_is_last), MP_ROM_PTR(&mp_lv_disp_flush_is_last_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_disp_drv_t_locals_dict, mp_lv_disp_drv_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_disp_buf_init(lv_disp_buf_t *disp_buf, void *buf1, void *buf2, uint32_t size_in_px_cnt)
 */
 
STATIC mp_obj_t mp_lv_disp_buf_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_buf_t *disp_buf = mp_write_ptr_lv_disp_buf_t(mp_args[0]);
    void *buf1 = mp_to_ptr(mp_args[1]);
    void *buf2 = mp_to_ptr(mp_args[2]);
    uint32_t size_in_px_cnt = (uint32_t)mp_obj_get_int(mp_args[3]);
    ((void (*)(lv_disp_buf_t *, void *, void *, uint32_t))lv_func_ptr)(disp_buf, buf1, buf2, size_in_px_cnt);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_buf_init_obj, 4, mp_lv_disp_buf_init, lv_disp_buf_init);
    

STATIC const mp_rom_map_elem_t mp_lv_disp_buf_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_disp_buf_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_disp_buf_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_disp_buf_t_locals_dict, mp_lv_disp_buf_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_task_del(lv_task_t *task)
 */
 
STATIC mp_obj_t mp_lv_task_del(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_task_t *task = mp_write_ptr_lv_task_t(mp_args[0]);
    ((void (*)(lv_task_t *))lv_func_ptr)(task);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_task_del_obj, 1, mp_lv_task_del, lv_task_del);
    

/*
 * Callback function lv_task_t_task_cb
 * void lv_task_cb_t(struct _lv_task_t *)
 */

STATIC void lv_task_t_task_cb_callback(struct _lv_task_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_task_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_task_t_task_cb)) , 1, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * void lv_task_set_cb(lv_task_t *task, lv_task_cb_t task_cb)
 */
 
STATIC mp_obj_t mp_lv_task_set_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_task_t *task = mp_write_ptr_lv_task_t(mp_args[0]);
    void *task_cb = mp_lv_callback(mp_args[1], &lv_task_t_task_cb_callback, MP_QSTR_lv_task_t_task_cb, &task->user_data);
    ((void (*)(lv_task_t *, lv_task_cb_t))lv_func_ptr)(task, task_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_task_set_cb_obj, 2, mp_lv_task_set_cb, lv_task_set_cb);
    

/*
 * lvgl extension definition for:
 * void lv_task_set_prio(lv_task_t *task, lv_task_prio_t prio)
 */
 
STATIC mp_obj_t mp_lv_task_set_prio(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_task_t *task = mp_write_ptr_lv_task_t(mp_args[0]);
    lv_task_prio_t prio = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_task_t *, lv_task_prio_t))lv_func_ptr)(task, prio);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_task_set_prio_obj, 2, mp_lv_task_set_prio, lv_task_set_prio);
    

/*
 * lvgl extension definition for:
 * void lv_task_set_period(lv_task_t *task, uint32_t period)
 */
 
STATIC mp_obj_t mp_lv_task_set_period(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_task_t *task = mp_write_ptr_lv_task_t(mp_args[0]);
    uint32_t period = (uint32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_task_t *, uint32_t))lv_func_ptr)(task, period);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_task_set_period_obj, 2, mp_lv_task_set_period, lv_task_set_period);
    
/* Reusing lv_task_del for lv_task_ready */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_task_ready_obj, 1, mp_lv_task_del, lv_task_ready);
    

/*
 * lvgl extension definition for:
 * void lv_task_set_repeat_count(lv_task_t *task, int32_t repeat_count)
 */
 
STATIC mp_obj_t mp_lv_task_set_repeat_count(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_task_t *task = mp_write_ptr_lv_task_t(mp_args[0]);
    int32_t repeat_count = (int32_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_task_t *, int32_t))lv_func_ptr)(task, repeat_count);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_task_set_repeat_count_obj, 2, mp_lv_task_set_repeat_count, lv_task_set_repeat_count);
    
/* Reusing lv_task_del for lv_task_reset */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_task_reset_obj, 1, mp_lv_task_del, lv_task_reset);
    

/*
 * lvgl extension definition for:
 * lv_task_t *lv_task_get_next(lv_task_t *task)
 */
 
STATIC mp_obj_t mp_lv_task_get_next(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_task_t *task = mp_write_ptr_lv_task_t(mp_args[0]);
    lv_task_t * _res = ((lv_task_t *(*)(lv_task_t *))lv_func_ptr)(task);
    return mp_read_ptr_lv_task_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_task_get_next_obj, 1, mp_lv_task_get_next, lv_task_get_next);
    

STATIC const mp_rom_map_elem_t mp_lv_task_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_task_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR__del), MP_ROM_PTR(&mp_lv_task_del_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_cb), MP_ROM_PTR(&mp_lv_task_set_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_prio), MP_ROM_PTR(&mp_lv_task_set_prio_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_period), MP_ROM_PTR(&mp_lv_task_set_period_obj) },
    { MP_ROM_QSTR(MP_QSTR_ready), MP_ROM_PTR(&mp_lv_task_ready_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_repeat_count), MP_ROM_PTR(&mp_lv_task_set_repeat_count_obj) },
    { MP_ROM_QSTR(MP_QSTR_reset), MP_ROM_PTR(&mp_lv_task_reset_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_next), MP_ROM_PTR(&mp_lv_task_get_next_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_task_t_locals_dict, mp_lv_task_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_ll_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_ll_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_ll_t_locals_dict, mp_lv_ll_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * inline static lv_style_t *lv_style_list_get_style(lv_style_list_t *list, uint8_t id)
 */
 
STATIC mp_obj_t mp_lv_style_list_get_style(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_list_t *list = mp_write_ptr_lv_style_list_t(mp_args[0]);
    uint8_t id = (uint8_t)mp_obj_get_int(mp_args[1]);
    lv_style_t * _res = ((lv_style_t *(*)(lv_style_list_t *, uint8_t))lv_func_ptr)(list, id);
    return mp_read_ptr_lv_style_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_list_get_style_obj, 2, mp_lv_style_list_get_style, lv_style_list_get_style);
    

/*
 * lvgl extension definition for:
 * void lv_style_list_init(lv_style_list_t *list)
 */
 
STATIC mp_obj_t mp_lv_style_list_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_list_t *list = mp_write_ptr_lv_style_list_t(mp_args[0]);
    ((void (*)(lv_style_list_t *))lv_func_ptr)(list);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_list_init_obj, 1, mp_lv_style_list_init, lv_style_list_init);
    

/*
 * lvgl extension definition for:
 * void lv_style_list_copy(lv_style_list_t *list_dest, const lv_style_list_t *list_src)
 */
 
STATIC mp_obj_t mp_lv_style_list_copy(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_list_t *list_dest = mp_write_ptr_lv_style_list_t(mp_args[0]);
    const lv_style_list_t *list_src = mp_write_ptr_lv_style_list_t(mp_args[1]);
    ((void (*)(lv_style_list_t *, const lv_style_list_t *))lv_func_ptr)(list_dest, list_src);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_list_copy_obj, 2, mp_lv_style_list_copy, lv_style_list_copy);
    

/*
 * lvgl extension definition for:
 * lv_style_t *lv_style_list_get_local_style(lv_style_list_t *list)
 */
 
STATIC mp_obj_t mp_lv_style_list_get_local_style(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_style_list_t *list = mp_write_ptr_lv_style_list_t(mp_args[0]);
    lv_style_t * _res = ((lv_style_t *(*)(lv_style_list_t *))lv_func_ptr)(list);
    return mp_read_ptr_lv_style_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_style_list_get_local_style_obj, 1, mp_lv_style_list_get_local_style, lv_style_list_get_local_style);
    

STATIC const mp_rom_map_elem_t mp_lv_style_list_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_style_list_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_style), MP_ROM_PTR(&mp_lv_style_list_get_style_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_style_list_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_copy), MP_ROM_PTR(&mp_lv_style_list_copy_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_local_style), MP_ROM_PTR(&mp_lv_style_list_get_local_style_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_style_list_t_locals_dict, mp_lv_style_list_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_point_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_point_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_point_t_locals_dict, mp_lv_point_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_obj_type_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_obj_type_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_handle_get_type_signal), MP_ROM_PTR(&mp_lv_obj_handle_get_type_signal_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_obj_type_t_locals_dict, mp_lv_obj_type_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_rect_dsc_init(lv_draw_rect_dsc_t *dsc)
 */
 
STATIC mp_obj_t mp_lv_draw_rect_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_rect_dsc_t *dsc = mp_write_ptr_lv_draw_rect_dsc_t(mp_args[0]);
    ((void (*)(lv_draw_rect_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_rect_dsc_init_obj, 1, mp_lv_draw_rect_dsc_init, lv_draw_rect_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_rect_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_rect_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_rect_dsc_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_rect_dsc_t_locals_dict, mp_lv_draw_rect_dsc_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_label_dsc_init(lv_draw_label_dsc_t *dsc)
 */
 
STATIC mp_obj_t mp_lv_draw_label_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_label_dsc_t *dsc = mp_write_ptr_lv_draw_label_dsc_t(mp_args[0]);
    ((void (*)(lv_draw_label_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_label_dsc_init_obj, 1, mp_lv_draw_label_dsc_init, lv_draw_label_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_label_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_label_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_label_dsc_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_label_dsc_t_locals_dict, mp_lv_draw_label_dsc_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_img_dsc_init(lv_draw_img_dsc_t *dsc)
 */
 
STATIC mp_obj_t mp_lv_draw_img_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_img_dsc_t *dsc = mp_write_ptr_lv_draw_img_dsc_t(mp_args[0]);
    ((void (*)(lv_draw_img_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_img_dsc_init_obj, 1, mp_lv_draw_img_dsc_init, lv_draw_img_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_img_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_img_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_img_dsc_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_img_dsc_t_locals_dict, mp_lv_draw_img_dsc_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_line_dsc_init(lv_draw_line_dsc_t *dsc)
 */
 
STATIC mp_obj_t mp_lv_draw_line_dsc_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_line_dsc_t *dsc = mp_write_ptr_lv_draw_line_dsc_t(mp_args[0]);
    ((void (*)(lv_draw_line_dsc_t *))lv_func_ptr)(dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_line_dsc_init_obj, 1, mp_lv_draw_line_dsc_init, lv_draw_line_dsc_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_line_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_line_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_line_dsc_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_line_dsc_t_locals_dict, mp_lv_draw_line_dsc_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_img_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_img_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_get_px_color), MP_ROM_PTR(&mp_lv_img_buf_get_px_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_get_px_alpha), MP_ROM_PTR(&mp_lv_img_buf_get_px_alpha_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_set_px_color), MP_ROM_PTR(&mp_lv_img_buf_set_px_color_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_set_px_alpha), MP_ROM_PTR(&mp_lv_img_buf_set_px_alpha_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_set_palette), MP_ROM_PTR(&mp_lv_img_buf_set_palette_obj) },
    { MP_ROM_QSTR(MP_QSTR_buf_free), MP_ROM_PTR(&mp_lv_img_buf_free_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_img_dsc_t_locals_dict, mp_lv_img_dsc_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_img_header_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_img_header_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_img_header_t_locals_dict, mp_lv_img_header_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_img_decoder_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_img_decoder_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_open), MP_ROM_PTR(&mp_lv_img_decoder_open_obj) },
    { MP_ROM_QSTR(MP_QSTR_read_line), MP_ROM_PTR(&mp_lv_img_decoder_read_line_obj) },
    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_lv_img_decoder_close_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_img_decoder_dsc_t_locals_dict, mp_lv_img_decoder_dsc_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_img_decoder_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_img_decoder_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_delete), MP_ROM_PTR(&mp_lv_img_decoder_delete_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_info_cb), MP_ROM_PTR(&mp_lv_img_decoder_set_info_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_open_cb), MP_ROM_PTR(&mp_lv_img_decoder_set_open_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_read_line_cb), MP_ROM_PTR(&mp_lv_img_decoder_set_read_line_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_close_cb), MP_ROM_PTR(&mp_lv_img_decoder_set_close_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_built_in_info), MP_ROM_PTR(&mp_lv_img_decoder_built_in_info_obj) },
    { MP_ROM_QSTR(MP_QSTR_built_in_open), MP_ROM_PTR(&mp_lv_img_decoder_built_in_open_obj) },
    { MP_ROM_QSTR(MP_QSTR_built_in_read_line), MP_ROM_PTR(&mp_lv_img_decoder_built_in_read_line_obj) },
    { MP_ROM_QSTR(MP_QSTR_built_in_close), MP_ROM_PTR(&mp_lv_img_decoder_built_in_close_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_img_decoder_t_locals_dict, mp_lv_img_decoder_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_chart_series_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_chart_series_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_x_start_point), MP_ROM_PTR(&mp_lv_chart_get_x_start_point_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_chart_series_t_locals_dict, mp_lv_chart_series_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_chart_cursor_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_chart_cursor_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_chart_cursor_t_locals_dict, mp_lv_chart_cursor_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_color_hsv_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_color_hsv_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_color_hsv_t_locals_dict, mp_lv_color_hsv_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_objmask_mask_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_objmask_mask_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_objmask_mask_t_locals_dict, mp_lv_objmask_mask_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_calendar_date_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_calendar_date_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_calendar_date_t_locals_dict, mp_lv_calendar_date_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_mem_monitor(lv_mem_monitor_t *mon_p)
 */
 
STATIC mp_obj_t mp_lv_mem_monitor(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_mem_monitor_t *mon_p = mp_write_ptr_lv_mem_monitor_t(mp_args[0]);
    ((void (*)(lv_mem_monitor_t *))lv_func_ptr)(mon_p);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_mem_monitor_obj, 1, mp_lv_mem_monitor, lv_mem_monitor);
    

STATIC const mp_rom_map_elem_t mp_lv_mem_monitor_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_mem_monitor_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_monitor), MP_ROM_PTR(&mp_lv_mem_monitor_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_mem_monitor_t_locals_dict, mp_lv_mem_monitor_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_indev_drv_init(lv_indev_drv_t *driver)
 */
 
STATIC mp_obj_t mp_lv_indev_drv_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_drv_t *driver = mp_write_ptr_lv_indev_drv_t(mp_args[0]);
    ((void (*)(lv_indev_drv_t *))lv_func_ptr)(driver);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_drv_init_obj, 1, mp_lv_indev_drv_init, lv_indev_drv_init);
    

/*
 * lvgl extension definition for:
 * lv_indev_t *lv_indev_drv_register(lv_indev_drv_t *driver)
 */
 
STATIC mp_obj_t mp_lv_indev_drv_register(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_drv_t *driver = mp_write_ptr_lv_indev_drv_t(mp_args[0]);
    lv_indev_t * _res = ((lv_indev_t *(*)(lv_indev_drv_t *))lv_func_ptr)(driver);
    return mp_read_ptr_lv_indev_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_drv_register_obj, 1, mp_lv_indev_drv_register, lv_indev_drv_register);
    

STATIC const mp_rom_map_elem_t mp_lv_indev_drv_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_indev_drv_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_indev_drv_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_register), MP_ROM_PTR(&mp_lv_indev_drv_register_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_indev_drv_t_locals_dict, mp_lv_indev_drv_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_indev_data_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_indev_data_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_indev_data_t_locals_dict, mp_lv_indev_data_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_indev_drv_update(lv_indev_t *indev, lv_indev_drv_t *new_drv)
 */
 
STATIC mp_obj_t mp_lv_indev_drv_update(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_indev_drv_t *new_drv = mp_write_ptr_lv_indev_drv_t(mp_args[1]);
    ((void (*)(lv_indev_t *, lv_indev_drv_t *))lv_func_ptr)(indev, new_drv);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_drv_update_obj, 2, mp_lv_indev_drv_update, lv_indev_drv_update);
    

/*
 * lvgl extension definition for:
 * lv_indev_t *lv_indev_get_next(lv_indev_t *indev)
 */
 
STATIC mp_obj_t mp_lv_indev_get_next(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_indev_t * _res = ((lv_indev_t *(*)(lv_indev_t *))lv_func_ptr)(indev);
    return mp_read_ptr_lv_indev_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_next_obj, 1, mp_lv_indev_get_next, lv_indev_get_next);
    

/*
 * lvgl extension definition for:
 * lv_indev_type_t lv_indev_get_type(const lv_indev_t *indev)
 */
 
STATIC mp_obj_t mp_lv_indev_get_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_indev_type_t _res = ((lv_indev_type_t (*)(const lv_indev_t *))lv_func_ptr)(indev);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_type_obj, 1, mp_lv_indev_get_type, lv_indev_get_type);
    

/*
 * lvgl extension definition for:
 * void lv_indev_reset(lv_indev_t *indev, lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_indev_reset(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_obj_t *obj = mp_to_lv(mp_args[1]);
    ((void (*)(lv_indev_t *, lv_obj_t *))lv_func_ptr)(indev, obj);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_reset_obj, 2, mp_lv_indev_reset, lv_indev_reset);
    

/*
 * lvgl extension definition for:
 * void lv_indev_reset_long_press(lv_indev_t *indev)
 */
 
STATIC mp_obj_t mp_lv_indev_reset_long_press(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    ((void (*)(lv_indev_t *))lv_func_ptr)(indev);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_reset_long_press_obj, 1, mp_lv_indev_reset_long_press, lv_indev_reset_long_press);
    

/*
 * lvgl extension definition for:
 * void lv_indev_enable(lv_indev_t *indev, bool en)
 */
 
STATIC mp_obj_t mp_lv_indev_enable(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    bool en = mp_obj_is_true(mp_args[1]);
    ((void (*)(lv_indev_t *, bool))lv_func_ptr)(indev, en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_enable_obj, 2, mp_lv_indev_enable, lv_indev_enable);
    
/* Reusing lv_indev_reset for lv_indev_set_cursor */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_set_cursor_obj, 2, mp_lv_indev_reset, lv_indev_set_cursor);
    

/*
 * lvgl extension definition for:
 * void lv_indev_set_group(lv_indev_t *indev, lv_group_t *group)
 */
 
STATIC mp_obj_t mp_lv_indev_set_group(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[1]);
    ((void (*)(lv_indev_t *, lv_group_t *))lv_func_ptr)(indev, group);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_set_group_obj, 2, mp_lv_indev_set_group, lv_indev_set_group);
    

/*
 * lvgl extension definition for:
 * void lv_indev_set_button_points(lv_indev_t *indev, const lv_point_t points[])
 */
 
STATIC mp_obj_t mp_lv_indev_set_button_points(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    const lv_point_t *points = mp_arr_to_lv_point_t_____(mp_args[1]);
    ((void (*)(lv_indev_t *, const lv_point_t []))lv_func_ptr)(indev, points);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_set_button_points_obj, 2, mp_lv_indev_set_button_points, lv_indev_set_button_points);
    

/*
 * lvgl extension definition for:
 * void lv_indev_get_point(const lv_indev_t *indev, lv_point_t *point)
 */
 
STATIC mp_obj_t mp_lv_indev_get_point(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_point_t *point = mp_write_ptr_lv_point_t(mp_args[1]);
    ((void (*)(const lv_indev_t *, lv_point_t *))lv_func_ptr)(indev, point);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_point_obj, 2, mp_lv_indev_get_point, lv_indev_get_point);
    

/*
 * lvgl extension definition for:
 * lv_gesture_dir_t lv_indev_get_gesture_dir(const lv_indev_t *indev)
 */
 
STATIC mp_obj_t mp_lv_indev_get_gesture_dir(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_gesture_dir_t _res = ((lv_gesture_dir_t (*)(const lv_indev_t *))lv_func_ptr)(indev);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_gesture_dir_obj, 1, mp_lv_indev_get_gesture_dir, lv_indev_get_gesture_dir);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_indev_get_key(const lv_indev_t *indev)
 */
 
STATIC mp_obj_t mp_lv_indev_get_key(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(const lv_indev_t *))lv_func_ptr)(indev);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_key_obj, 1, mp_lv_indev_get_key, lv_indev_get_key);
    

/*
 * lvgl extension definition for:
 * bool lv_indev_is_dragging(const lv_indev_t *indev)
 */
 
STATIC mp_obj_t mp_lv_indev_is_dragging(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    bool _res = ((bool (*)(const lv_indev_t *))lv_func_ptr)(indev);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_is_dragging_obj, 1, mp_lv_indev_is_dragging, lv_indev_is_dragging);
    
/* Reusing lv_indev_get_point for lv_indev_get_vect */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_get_vect_obj, 2, mp_lv_indev_get_point, lv_indev_get_vect);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_indev_finish_drag(lv_indev_t *indev)
 */
 
STATIC mp_obj_t mp_lv_indev_finish_drag(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_indev_t *indev = mp_write_ptr_lv_indev_t(mp_args[0]);
    lv_res_t _res = ((lv_res_t (*)(lv_indev_t *))lv_func_ptr)(indev);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_finish_drag_obj, 1, mp_lv_indev_finish_drag, lv_indev_finish_drag);
    
/* Reusing lv_indev_reset_long_press for lv_indev_wait_release */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_wait_release_obj, 1, mp_lv_indev_reset_long_press, lv_indev_wait_release);
    

STATIC const mp_rom_map_elem_t mp_lv_indev_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_indev_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_drv_update), MP_ROM_PTR(&mp_lv_indev_drv_update_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_next), MP_ROM_PTR(&mp_lv_indev_get_next_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_type), MP_ROM_PTR(&mp_lv_indev_get_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_reset), MP_ROM_PTR(&mp_lv_indev_reset_obj) },
    { MP_ROM_QSTR(MP_QSTR_reset_long_press), MP_ROM_PTR(&mp_lv_indev_reset_long_press_obj) },
    { MP_ROM_QSTR(MP_QSTR_enable), MP_ROM_PTR(&mp_lv_indev_enable_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_cursor), MP_ROM_PTR(&mp_lv_indev_set_cursor_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_group), MP_ROM_PTR(&mp_lv_indev_set_group_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_button_points), MP_ROM_PTR(&mp_lv_indev_set_button_points_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_point), MP_ROM_PTR(&mp_lv_indev_get_point_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_gesture_dir), MP_ROM_PTR(&mp_lv_indev_get_gesture_dir_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_key), MP_ROM_PTR(&mp_lv_indev_get_key_obj) },
    { MP_ROM_QSTR(MP_QSTR_is_dragging), MP_ROM_PTR(&mp_lv_indev_is_dragging_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_vect), MP_ROM_PTR(&mp_lv_indev_get_vect_obj) },
    { MP_ROM_QSTR(MP_QSTR_finish_drag), MP_ROM_PTR(&mp_lv_indev_finish_drag_obj) },
    { MP_ROM_QSTR(MP_QSTR_wait_release), MP_ROM_PTR(&mp_lv_indev_wait_release_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_indev_t_locals_dict, mp_lv_indev_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_indev_proc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_indev_proc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_indev_proc_t_locals_dict, mp_lv_indev_proc_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_indev_proc_types_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_indev_proc_types_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_indev_proc_types_t_locals_dict, mp_lv_indev_proc_types_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_indev_proc_types_pointer_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_indev_proc_types_pointer_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_indev_proc_types_pointer_t_locals_dict, mp_lv_indev_proc_types_pointer_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_indev_proc_types_keypad_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_indev_proc_types_keypad_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_indev_proc_types_keypad_t_locals_dict, mp_lv_indev_proc_types_keypad_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_group_del(lv_group_t *group)
 */
 
STATIC mp_obj_t mp_lv_group_del(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    ((void (*)(lv_group_t *))lv_func_ptr)(group);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_del_obj, 1, mp_lv_group_del, lv_group_del);
    

/*
 * lvgl extension definition for:
 * void lv_group_add_obj(lv_group_t *group, lv_obj_t *obj)
 */
 
STATIC mp_obj_t mp_lv_group_add_obj(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    lv_obj_t *obj = mp_to_lv(mp_args[1]);
    ((void (*)(lv_group_t *, lv_obj_t *))lv_func_ptr)(group, obj);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_add_obj_obj, 2, mp_lv_group_add_obj, lv_group_add_obj);
    
/* Reusing lv_group_del for lv_group_remove_all_objs */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_remove_all_objs_obj, 1, mp_lv_group_del, lv_group_remove_all_objs);
    
/* Reusing lv_group_del for lv_group_focus_next */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_focus_next_obj, 1, mp_lv_group_del, lv_group_focus_next);
    
/* Reusing lv_group_del for lv_group_focus_prev */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_focus_prev_obj, 1, mp_lv_group_del, lv_group_focus_prev);
    

/*
 * lvgl extension definition for:
 * void lv_group_focus_freeze(lv_group_t *group, bool en)
 */
 
STATIC mp_obj_t mp_lv_group_focus_freeze(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    bool en = mp_obj_is_true(mp_args[1]);
    ((void (*)(lv_group_t *, bool))lv_func_ptr)(group, en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_focus_freeze_obj, 2, mp_lv_group_focus_freeze, lv_group_focus_freeze);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_group_send_data(lv_group_t *group, uint32_t c)
 */
 
STATIC mp_obj_t mp_lv_group_send_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    uint32_t c = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_res_t _res = ((lv_res_t (*)(lv_group_t *, uint32_t))lv_func_ptr)(group, c);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_send_data_obj, 2, mp_lv_group_send_data, lv_group_send_data);
    

/*
 * Callback function lv_group_t_focus_cb
 * void lv_group_focus_cb_t(struct _lv_group_t *)
 */

STATIC void lv_group_t_focus_cb_callback(struct _lv_group_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_group_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_group_t_focus_cb)) , 1, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * void lv_group_set_focus_cb(lv_group_t *group, lv_group_focus_cb_t focus_cb)
 */
 
STATIC mp_obj_t mp_lv_group_set_focus_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    void *focus_cb = mp_lv_callback(mp_args[1], &lv_group_t_focus_cb_callback, MP_QSTR_lv_group_t_focus_cb, &group->user_data);
    ((void (*)(lv_group_t *, lv_group_focus_cb_t))lv_func_ptr)(group, focus_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_set_focus_cb_obj, 2, mp_lv_group_set_focus_cb, lv_group_set_focus_cb);
    

/*
 * lvgl extension definition for:
 * void lv_group_set_refocus_policy(lv_group_t *group, lv_group_refocus_policy_t policy)
 */
 
STATIC mp_obj_t mp_lv_group_set_refocus_policy(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    lv_group_refocus_policy_t policy = (uint8_t)mp_obj_get_int(mp_args[1]);
    ((void (*)(lv_group_t *, lv_group_refocus_policy_t))lv_func_ptr)(group, policy);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_set_refocus_policy_obj, 2, mp_lv_group_set_refocus_policy, lv_group_set_refocus_policy);
    
/* Reusing lv_group_focus_freeze for lv_group_set_editing */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_set_editing_obj, 2, mp_lv_group_focus_freeze, lv_group_set_editing);
    
/* Reusing lv_group_focus_freeze for lv_group_set_click_focus */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_set_click_focus_obj, 2, mp_lv_group_focus_freeze, lv_group_set_click_focus);
    
/* Reusing lv_group_focus_freeze for lv_group_set_wrap */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_set_wrap_obj, 2, mp_lv_group_focus_freeze, lv_group_set_wrap);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_group_get_focused(const lv_group_t *group)
 */
 
STATIC mp_obj_t mp_lv_group_get_focused(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    lv_obj_t * _res = ((lv_obj_t *(*)(const lv_group_t *))lv_func_ptr)(group);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_get_focused_obj, 1, mp_lv_group_get_focused, lv_group_get_focused);
    

/*
 * lvgl extension definition for:
 * lv_group_user_data_t *lv_group_get_user_data(lv_group_t *group)
 */
 
STATIC mp_obj_t mp_lv_group_get_user_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    lv_group_user_data_t * _res = ((lv_group_user_data_t *(*)(lv_group_t *))lv_func_ptr)(group);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_get_user_data_obj, 1, mp_lv_group_get_user_data, lv_group_get_user_data);
    

/*
 * lvgl extension definition for:
 * lv_group_focus_cb_t lv_group_get_focus_cb(const lv_group_t *group)
 */
 
STATIC mp_obj_t mp_lv_group_get_focus_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    lv_group_focus_cb_t _res = ((lv_group_focus_cb_t (*)(const lv_group_t *))lv_func_ptr)(group);
    return mp_lv_funcptr_lv_group_focus_cb_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_get_focus_cb_obj, 1, mp_lv_group_get_focus_cb, lv_group_get_focus_cb);
    

/*
 * lvgl extension definition for:
 * bool lv_group_get_editing(const lv_group_t *group)
 */
 
STATIC mp_obj_t mp_lv_group_get_editing(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    bool _res = ((bool (*)(const lv_group_t *))lv_func_ptr)(group);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_get_editing_obj, 1, mp_lv_group_get_editing, lv_group_get_editing);
    
/* Reusing lv_group_get_editing for lv_group_get_click_focus */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_get_click_focus_obj, 1, mp_lv_group_get_editing, lv_group_get_click_focus);
    

/*
 * lvgl extension definition for:
 * bool lv_group_get_wrap(lv_group_t *group)
 */
 
STATIC mp_obj_t mp_lv_group_get_wrap(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_group_t *group = mp_write_ptr_lv_group_t(mp_args[0]);
    bool _res = ((bool (*)(lv_group_t *))lv_func_ptr)(group);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_get_wrap_obj, 1, mp_lv_group_get_wrap, lv_group_get_wrap);
    

STATIC const mp_rom_map_elem_t mp_lv_group_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_group_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR__del), MP_ROM_PTR(&mp_lv_group_del_obj) },
    { MP_ROM_QSTR(MP_QSTR_add_obj), MP_ROM_PTR(&mp_lv_group_add_obj_obj) },
    { MP_ROM_QSTR(MP_QSTR_remove_all_objs), MP_ROM_PTR(&mp_lv_group_remove_all_objs_obj) },
    { MP_ROM_QSTR(MP_QSTR_focus_next), MP_ROM_PTR(&mp_lv_group_focus_next_obj) },
    { MP_ROM_QSTR(MP_QSTR_focus_prev), MP_ROM_PTR(&mp_lv_group_focus_prev_obj) },
    { MP_ROM_QSTR(MP_QSTR_focus_freeze), MP_ROM_PTR(&mp_lv_group_focus_freeze_obj) },
    { MP_ROM_QSTR(MP_QSTR_send_data), MP_ROM_PTR(&mp_lv_group_send_data_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_focus_cb), MP_ROM_PTR(&mp_lv_group_set_focus_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_refocus_policy), MP_ROM_PTR(&mp_lv_group_set_refocus_policy_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_editing), MP_ROM_PTR(&mp_lv_group_set_editing_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_click_focus), MP_ROM_PTR(&mp_lv_group_set_click_focus_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_wrap), MP_ROM_PTR(&mp_lv_group_set_wrap_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_focused), MP_ROM_PTR(&mp_lv_group_get_focused_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_user_data), MP_ROM_PTR(&mp_lv_group_get_user_data_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_focus_cb), MP_ROM_PTR(&mp_lv_group_get_focus_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_editing), MP_ROM_PTR(&mp_lv_group_get_editing_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_click_focus), MP_ROM_PTR(&mp_lv_group_get_click_focus_obj) },
    { MP_ROM_QSTR(MP_QSTR_get_wrap), MP_ROM_PTR(&mp_lv_group_get_wrap_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_group_t_locals_dict, mp_lv_group_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_mask_line_points_init(lv_draw_mask_line_param_t *param, lv_coord_t p1x, lv_coord_t p1y, lv_coord_t p2x, lv_coord_t p2y, lv_draw_mask_line_side_t side)
 */
 
STATIC mp_obj_t mp_lv_draw_mask_line_points_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_mask_line_param_t *param = mp_write_ptr_lv_draw_mask_line_param_t(mp_args[0]);
    lv_coord_t p1x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t p1y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t p2x = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t p2y = (int16_t)mp_obj_get_int(mp_args[4]);
    lv_draw_mask_line_side_t side = (uint8_t)mp_obj_get_int(mp_args[5]);
    ((void (*)(lv_draw_mask_line_param_t *, lv_coord_t, lv_coord_t, lv_coord_t, lv_coord_t, lv_draw_mask_line_side_t))lv_func_ptr)(param, p1x, p1y, p2x, p2y, side);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_mask_line_points_init_obj, 6, mp_lv_draw_mask_line_points_init, lv_draw_mask_line_points_init);
    

/*
 * lvgl extension definition for:
 * void lv_draw_mask_line_angle_init(lv_draw_mask_line_param_t *param, lv_coord_t p1x, lv_coord_t py, int16_t angle, lv_draw_mask_line_side_t side)
 */
 
STATIC mp_obj_t mp_lv_draw_mask_line_angle_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_mask_line_param_t *param = mp_write_ptr_lv_draw_mask_line_param_t(mp_args[0]);
    lv_coord_t p1x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t py = (int16_t)mp_obj_get_int(mp_args[2]);
    int16_t angle = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_draw_mask_line_side_t side = (uint8_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(lv_draw_mask_line_param_t *, lv_coord_t, lv_coord_t, int16_t, lv_draw_mask_line_side_t))lv_func_ptr)(param, p1x, py, angle, side);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_mask_line_angle_init_obj, 5, mp_lv_draw_mask_line_angle_init, lv_draw_mask_line_angle_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_line_param_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_line_param_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_points_init), MP_ROM_PTR(&mp_lv_draw_mask_line_points_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_angle_init), MP_ROM_PTR(&mp_lv_draw_mask_line_angle_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_line_param_t_locals_dict, mp_lv_draw_mask_line_param_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_common_dsc_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_common_dsc_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_common_dsc_t_locals_dict, mp_lv_draw_mask_common_dsc_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_line_param_cfg_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_line_param_cfg_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_line_param_cfg_t_locals_dict, mp_lv_draw_mask_line_param_cfg_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_mask_angle_init(lv_draw_mask_angle_param_t *param, lv_coord_t vertex_x, lv_coord_t vertex_y, lv_coord_t start_angle, lv_coord_t end_angle)
 */
 
STATIC mp_obj_t mp_lv_draw_mask_angle_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_mask_angle_param_t *param = mp_write_ptr_lv_draw_mask_angle_param_t(mp_args[0]);
    lv_coord_t vertex_x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t vertex_y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t start_angle = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_coord_t end_angle = (int16_t)mp_obj_get_int(mp_args[4]);
    ((void (*)(lv_draw_mask_angle_param_t *, lv_coord_t, lv_coord_t, lv_coord_t, lv_coord_t))lv_func_ptr)(param, vertex_x, vertex_y, start_angle, end_angle);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_mask_angle_init_obj, 5, mp_lv_draw_mask_angle_init, lv_draw_mask_angle_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_angle_param_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_angle_param_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_mask_angle_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_angle_param_t_locals_dict, mp_lv_draw_mask_angle_param_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_angle_param_cfg_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_angle_param_cfg_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_angle_param_cfg_t_locals_dict, mp_lv_draw_mask_angle_param_cfg_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_mask_radius_init(lv_draw_mask_radius_param_t *param, const lv_area_t *rect, lv_coord_t radius, bool inv)
 */
 
STATIC mp_obj_t mp_lv_draw_mask_radius_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_mask_radius_param_t *param = mp_write_ptr_lv_draw_mask_radius_param_t(mp_args[0]);
    const lv_area_t *rect = mp_write_ptr_lv_area_t(mp_args[1]);
    lv_coord_t radius = (int16_t)mp_obj_get_int(mp_args[2]);
    bool inv = mp_obj_is_true(mp_args[3]);
    ((void (*)(lv_draw_mask_radius_param_t *, const lv_area_t *, lv_coord_t, bool))lv_func_ptr)(param, rect, radius, inv);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_mask_radius_init_obj, 4, mp_lv_draw_mask_radius_init, lv_draw_mask_radius_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_radius_param_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_radius_param_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_mask_radius_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_radius_param_t_locals_dict, mp_lv_draw_mask_radius_param_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_radius_param_cfg_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_radius_param_cfg_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_radius_param_cfg_t_locals_dict, mp_lv_draw_mask_radius_param_cfg_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_sqrt_res_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_sqrt_res_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_sqrt_res_t_locals_dict, mp_lv_sqrt_res_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_mask_fade_init(lv_draw_mask_fade_param_t *param, const lv_area_t *coords, lv_opa_t opa_top, lv_coord_t y_top, lv_opa_t opa_bottom, lv_coord_t y_bottom)
 */
 
STATIC mp_obj_t mp_lv_draw_mask_fade_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_mask_fade_param_t *param = mp_write_ptr_lv_draw_mask_fade_param_t(mp_args[0]);
    const lv_area_t *coords = mp_write_ptr_lv_area_t(mp_args[1]);
    lv_opa_t opa_top = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t y_top = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_opa_t opa_bottom = (uint8_t)mp_obj_get_int(mp_args[4]);
    lv_coord_t y_bottom = (int16_t)mp_obj_get_int(mp_args[5]);
    ((void (*)(lv_draw_mask_fade_param_t *, const lv_area_t *, lv_opa_t, lv_coord_t, lv_opa_t, lv_coord_t))lv_func_ptr)(param, coords, opa_top, y_top, opa_bottom, y_bottom);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_mask_fade_init_obj, 6, mp_lv_draw_mask_fade_init, lv_draw_mask_fade_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_fade_param_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_fade_param_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_mask_fade_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_fade_param_t_locals_dict, mp_lv_draw_mask_fade_param_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_fade_param_cfg_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_fade_param_cfg_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_fade_param_cfg_t_locals_dict, mp_lv_draw_mask_fade_param_cfg_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_mask_map_init(lv_draw_mask_map_param_t *param, const lv_area_t *coords, const lv_opa_t *map)
 */
 
STATIC mp_obj_t mp_lv_draw_mask_map_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_draw_mask_map_param_t *param = mp_write_ptr_lv_draw_mask_map_param_t(mp_args[0]);
    const lv_area_t *coords = mp_write_ptr_lv_area_t(mp_args[1]);
    const lv_opa_t *map = mp_to_ptr(mp_args[2]);
    ((void (*)(lv_draw_mask_map_param_t *, const lv_area_t *, const lv_opa_t *))lv_func_ptr)(param, coords, map);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_draw_mask_map_init_obj, 3, mp_lv_draw_mask_map_init, lv_draw_mask_map_init);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_map_param_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_map_param_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_draw_mask_map_init_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_map_param_t_locals_dict, mp_lv_draw_mask_map_param_t_locals_dict_table);
        

STATIC const mp_rom_map_elem_t mp_lv_draw_mask_map_param_cfg_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_mask_map_param_cfg_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_mask_map_param_cfg_t_locals_dict, mp_lv_draw_mask_map_param_cfg_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_fs_drv_init(lv_fs_drv_t *drv)
 */
 
STATIC mp_obj_t mp_lv_fs_drv_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_drv_t *drv = mp_write_ptr_lv_fs_drv_t(mp_args[0]);
    ((void (*)(lv_fs_drv_t *))lv_func_ptr)(drv);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_drv_init_obj, 1, mp_lv_fs_drv_init, lv_fs_drv_init);
    
/* Reusing lv_fs_drv_init for lv_fs_drv_register */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_drv_register_obj, 1, mp_lv_fs_drv_init, lv_fs_drv_register);
    

STATIC const mp_rom_map_elem_t mp_lv_fs_drv_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_fs_drv_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_fs_drv_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_register), MP_ROM_PTR(&mp_lv_fs_drv_register_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_fs_drv_t_locals_dict, mp_lv_fs_drv_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_open(lv_fs_file_t *file_p, const char *path, lv_fs_mode_t mode)
 */
 
STATIC mp_obj_t mp_lv_fs_open(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_file_t *file_p = mp_write_ptr_lv_fs_file_t(mp_args[0]);
    const char *path = (char*)convert_from_str(mp_args[1]);
    lv_fs_mode_t mode = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_file_t *, const char *, lv_fs_mode_t))lv_func_ptr)(file_p, path, mode);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_open_obj, 3, mp_lv_fs_open, lv_fs_open);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_close(lv_fs_file_t *file_p)
 */
 
STATIC mp_obj_t mp_lv_fs_close(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_file_t *file_p = mp_write_ptr_lv_fs_file_t(mp_args[0]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_file_t *))lv_func_ptr)(file_p);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_close_obj, 1, mp_lv_fs_close, lv_fs_close);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_read(lv_fs_file_t *file_p, void *buf, uint32_t btr, uint32_t *br)
 */
 
STATIC mp_obj_t mp_lv_fs_read(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_file_t *file_p = mp_write_ptr_lv_fs_file_t(mp_args[0]);
    void *buf = mp_to_ptr(mp_args[1]);
    uint32_t btr = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint32_t *br = mp_to_ptr(mp_args[3]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_file_t *, void *, uint32_t, uint32_t *))lv_func_ptr)(file_p, buf, btr, br);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_read_obj, 4, mp_lv_fs_read, lv_fs_read);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_write(lv_fs_file_t *file_p, const void *buf, uint32_t btw, uint32_t *bw)
 */
 
STATIC mp_obj_t mp_lv_fs_write(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_file_t *file_p = mp_write_ptr_lv_fs_file_t(mp_args[0]);
    const void *buf = mp_to_ptr(mp_args[1]);
    uint32_t btw = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint32_t *bw = mp_to_ptr(mp_args[3]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_file_t *, const void *, uint32_t, uint32_t *))lv_func_ptr)(file_p, buf, btw, bw);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_write_obj, 4, mp_lv_fs_write, lv_fs_write);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_seek(lv_fs_file_t *file_p, uint32_t pos)
 */
 
STATIC mp_obj_t mp_lv_fs_seek(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_file_t *file_p = mp_write_ptr_lv_fs_file_t(mp_args[0]);
    uint32_t pos = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_file_t *, uint32_t))lv_func_ptr)(file_p, pos);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_seek_obj, 2, mp_lv_fs_seek, lv_fs_seek);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_tell(lv_fs_file_t *file_p, uint32_t *pos)
 */
 
STATIC mp_obj_t mp_lv_fs_tell(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_file_t *file_p = mp_write_ptr_lv_fs_file_t(mp_args[0]);
    uint32_t *pos = mp_to_ptr(mp_args[1]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_file_t *, uint32_t *))lv_func_ptr)(file_p, pos);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_tell_obj, 2, mp_lv_fs_tell, lv_fs_tell);
    
/* Reusing lv_fs_close for lv_fs_trunc */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_trunc_obj, 1, mp_lv_fs_close, lv_fs_trunc);
    
/* Reusing lv_fs_tell for lv_fs_size */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_size_obj, 2, mp_lv_fs_tell, lv_fs_size);
    

STATIC const mp_rom_map_elem_t mp_lv_fs_file_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_fs_file_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_open), MP_ROM_PTR(&mp_lv_fs_open_obj) },
    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_lv_fs_close_obj) },
    { MP_ROM_QSTR(MP_QSTR_read), MP_ROM_PTR(&mp_lv_fs_read_obj) },
    { MP_ROM_QSTR(MP_QSTR_write), MP_ROM_PTR(&mp_lv_fs_write_obj) },
    { MP_ROM_QSTR(MP_QSTR_seek), MP_ROM_PTR(&mp_lv_fs_seek_obj) },
    { MP_ROM_QSTR(MP_QSTR_tell), MP_ROM_PTR(&mp_lv_fs_tell_obj) },
    { MP_ROM_QSTR(MP_QSTR_trunc), MP_ROM_PTR(&mp_lv_fs_trunc_obj) },
    { MP_ROM_QSTR(MP_QSTR_size), MP_ROM_PTR(&mp_lv_fs_size_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_fs_file_t_locals_dict, mp_lv_fs_file_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_dir_open(lv_fs_dir_t *rddir_p, const char *path)
 */
 
STATIC mp_obj_t mp_lv_fs_dir_open(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_dir_t *rddir_p = mp_write_ptr_lv_fs_dir_t(mp_args[0]);
    const char *path = (char*)convert_from_str(mp_args[1]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_dir_t *, const char *))lv_func_ptr)(rddir_p, path);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_dir_open_obj, 2, mp_lv_fs_dir_open, lv_fs_dir_open);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_dir_read(lv_fs_dir_t *rddir_p, char *fn)
 */
 
STATIC mp_obj_t mp_lv_fs_dir_read(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_dir_t *rddir_p = mp_write_ptr_lv_fs_dir_t(mp_args[0]);
    char *fn = (char*)convert_from_str(mp_args[1]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_dir_t *, char *))lv_func_ptr)(rddir_p, fn);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_dir_read_obj, 2, mp_lv_fs_dir_read, lv_fs_dir_read);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_dir_close(lv_fs_dir_t *rddir_p)
 */
 
STATIC mp_obj_t mp_lv_fs_dir_close(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_fs_dir_t *rddir_p = mp_write_ptr_lv_fs_dir_t(mp_args[0]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(lv_fs_dir_t *))lv_func_ptr)(rddir_p);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_fs_dir_close_obj, 1, mp_lv_fs_dir_close, lv_fs_dir_close);
    

STATIC const mp_rom_map_elem_t mp_lv_fs_dir_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_fs_dir_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_open), MP_ROM_PTR(&mp_lv_fs_dir_open_obj) },
    { MP_ROM_QSTR(MP_QSTR_read), MP_ROM_PTR(&mp_lv_fs_dir_read_obj) },
    { MP_ROM_QSTR(MP_QSTR_close), MP_ROM_PTR(&mp_lv_fs_dir_close_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_fs_dir_t_locals_dict, mp_lv_fs_dir_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_theme_set_act(lv_theme_t *th)
 */
 
STATIC mp_obj_t mp_lv_theme_set_act(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_theme_t *th = mp_write_ptr_lv_theme_t(mp_args[0]);
    ((void (*)(lv_theme_t *))lv_func_ptr)(th);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_theme_set_act_obj, 1, mp_lv_theme_set_act, lv_theme_set_act);
    

/*
 * lvgl extension definition for:
 * void lv_theme_copy(lv_theme_t *theme, const lv_theme_t *copy)
 */
 
STATIC mp_obj_t mp_lv_theme_copy(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_theme_t *theme = mp_write_ptr_lv_theme_t(mp_args[0]);
    const lv_theme_t *copy = mp_write_ptr_lv_theme_t(mp_args[1]);
    ((void (*)(lv_theme_t *, const lv_theme_t *))lv_func_ptr)(theme, copy);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_theme_copy_obj, 2, mp_lv_theme_copy, lv_theme_copy);
    

/*
 * lvgl extension definition for:
 * void lv_theme_set_base(lv_theme_t *new_theme, lv_theme_t *base)
 */
 
STATIC mp_obj_t mp_lv_theme_set_base(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_theme_t *new_theme = mp_write_ptr_lv_theme_t(mp_args[0]);
    lv_theme_t *base = mp_write_ptr_lv_theme_t(mp_args[1]);
    ((void (*)(lv_theme_t *, lv_theme_t *))lv_func_ptr)(new_theme, base);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_theme_set_base_obj, 2, mp_lv_theme_set_base, lv_theme_set_base);
    

/*
 * Callback function lv_theme_t_apply_cb
 * void lv_theme_apply_cb_t(struct _lv_theme_t *, lv_obj_t *, lv_theme_style_t)
 */

STATIC void lv_theme_t_apply_cb_callback(struct _lv_theme_t * arg0, lv_obj_t * arg1, lv_theme_style_t arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_theme_t((void*)arg0);
    mp_args[1] = lv_to_mp((void*)arg1);
    mp_args[2] = mp_obj_new_int(arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_theme_t_apply_cb)) , 3, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * void lv_theme_set_apply_cb(lv_theme_t *theme, lv_theme_apply_cb_t apply_cb)
 */
 
STATIC mp_obj_t mp_lv_theme_set_apply_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_theme_t *theme = mp_write_ptr_lv_theme_t(mp_args[0]);
    void *apply_cb = mp_lv_callback(mp_args[1], &lv_theme_t_apply_cb_callback, MP_QSTR_lv_theme_t_apply_cb, &theme->user_data);
    ((void (*)(lv_theme_t *, lv_theme_apply_cb_t))lv_func_ptr)(theme, apply_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_theme_set_apply_cb_obj, 2, mp_lv_theme_set_apply_cb, lv_theme_set_apply_cb);
    

STATIC const mp_rom_map_elem_t mp_lv_theme_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_theme_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_act), MP_ROM_PTR(&mp_lv_theme_set_act_obj) },
    { MP_ROM_QSTR(MP_QSTR_copy), MP_ROM_PTR(&mp_lv_theme_copy_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_base), MP_ROM_PTR(&mp_lv_theme_set_base_obj) },
    { MP_ROM_QSTR(MP_QSTR_set_apply_cb), MP_ROM_PTR(&mp_lv_theme_set_apply_cb_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_theme_t_locals_dict, mp_lv_theme_t_locals_dict_table);
        

/* 
 *
 * Global Module Functions
 *
 */


/*
 * lvgl extension definition for:
 * inline static lv_color_t lv_color_mix_premult(uint16_t *premult_c1, lv_color_t c2, uint8_t mix)
 */
 
STATIC mp_obj_t mp_lv_color_mix_premult(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint16_t *premult_c1 = mp_to_ptr(mp_args[0]);
    lv_color_t c2 = mp_write_lv_color32_t(mp_args[1]);
    uint8_t mix = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_color_t _res = ((lv_color_t (*)(uint16_t *, lv_color_t, uint8_t))lv_func_ptr)(premult_c1, c2, mix);
    return mp_read_lv_color32_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_mix_premult_obj, 3, mp_lv_color_mix_premult, lv_color_mix_premult);
    

/*
 * lvgl extension definition for:
 * inline static lv_color_t lv_color_make(uint8_t r, uint8_t g, uint8_t b)
 */
 
STATIC mp_obj_t mp_lv_color_make(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint8_t r = (uint8_t)mp_obj_get_int(mp_args[0]);
    uint8_t g = (uint8_t)mp_obj_get_int(mp_args[1]);
    uint8_t b = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_color_t _res = ((lv_color_t (*)(uint8_t, uint8_t, uint8_t))lv_func_ptr)(r, g, b);
    return mp_read_lv_color32_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_make_obj, 3, mp_lv_color_make, lv_color_make);
    

/*
 * lvgl extension definition for:
 * inline static lv_color_t lv_color_hex(uint32_t c)
 */
 
STATIC mp_obj_t mp_lv_color_hex(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint32_t c = (uint32_t)mp_obj_get_int(mp_args[0]);
    lv_color_t _res = ((lv_color_t (*)(uint32_t))lv_func_ptr)(c);
    return mp_read_lv_color32_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_hex_obj, 1, mp_lv_color_hex, lv_color_hex);
    
/* Reusing lv_color_hex for lv_color_hex3 */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_hex3_obj, 1, mp_lv_color_hex, lv_color_hex3);
    

/*
 * lvgl extension definition for:
 * inline static lv_obj_t *lv_scr_act(void)
 */
 
STATIC mp_obj_t mp_lv_scr_act(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_obj_t * _res = ((lv_obj_t *(*)(void))lv_func_ptr)();
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_scr_act_obj, 0, mp_lv_scr_act, lv_scr_act);
    
/* Reusing lv_scr_act for lv_layer_top */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_layer_top_obj, 0, mp_lv_scr_act, lv_layer_top);
    
/* Reusing lv_scr_act for lv_layer_sys */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_layer_sys_obj, 0, mp_lv_scr_act, lv_layer_sys);
    
/* Reusing lv_obj_clean for lv_scr_load */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scr_load_obj, 1, mp_lv_obj_clean, lv_scr_load);
    

/*
 * lvgl extension definition for:
 * inline static lv_coord_t lv_dpx(lv_coord_t n)
 */
 
STATIC mp_obj_t mp_lv_dpx(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_coord_t n = (int16_t)mp_obj_get_int(mp_args[0]);
    lv_coord_t _res = ((lv_coord_t (*)(lv_coord_t))lv_func_ptr)(n);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_dpx_obj, 1, mp_lv_dpx, lv_dpx);
    

/*
 * Callback function lv_log_print_g_cb_t_print_cb
 * void lv_log_print_g_cb_t(lv_log_level_t level, const char *, uint32_t, const char *, const char *)
 */

STATIC void lv_log_print_g_cb_t_print_cb_callback(lv_log_level_t arg0, const char * arg1, uint32_t arg2, const char * arg3, const char * arg4)
{
    mp_obj_t mp_args[5];
    mp_args[0] = mp_obj_new_int(arg0);
    mp_args[1] = convert_to_str((void*)arg1);
    mp_args[2] = mp_obj_new_int_from_uint(arg2);
    mp_args[3] = convert_to_str((void*)arg3);
    mp_args[4] = convert_to_str((void*)arg4);
    mp_obj_t callbacks = get_callback_dict_from_user_data(MP_STATE_PORT(mp_lv_user_data));
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_log_print_g_cb_t_print_cb)) , 5, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * void lv_log_register_print_cb(lv_log_print_g_cb_t print_cb)
 */
 
STATIC mp_obj_t mp_lv_log_register_print_cb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *print_cb = mp_lv_callback(mp_args[0], &lv_log_print_g_cb_t_print_cb_callback, MP_QSTR_lv_log_print_g_cb_t_print_cb, &MP_STATE_PORT(mp_lv_user_data));
    ((void (*)(lv_log_print_g_cb_t))lv_func_ptr)(print_cb);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_log_register_print_cb_obj, 1, mp_lv_log_register_print_cb, lv_log_register_print_cb);
    

/*
 * lvgl extension definition for:
 * void *lv_mem_alloc(size_t size)
 */
 
STATIC mp_obj_t mp_lv_mem_alloc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    size_t size = (size_t)mp_obj_get_int(mp_args[0]);
    void * _res = ((void *(*)(size_t))lv_func_ptr)(size);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mem_alloc_obj, 1, mp_lv_mem_alloc, lv_mem_alloc);
    
/* Reusing lv_img_cache_invalidate_src for lv_mem_free */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mem_free_obj, 1, mp_lv_img_cache_invalidate_src, lv_mem_free);
    

/*
 * lvgl extension definition for:
 * void *lv_mem_realloc(void *data_p, size_t new_size)
 */
 
STATIC mp_obj_t mp_lv_mem_realloc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *data_p = mp_to_ptr(mp_args[0]);
    size_t new_size = (size_t)mp_obj_get_int(mp_args[1]);
    void * _res = ((void *(*)(void *, size_t))lv_func_ptr)(data_p, new_size);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mem_realloc_obj, 2, mp_lv_mem_realloc, lv_mem_realloc);
    

/*
 * lvgl extension definition for:
 * void lv_mem_defrag(void)
 */
 
STATIC mp_obj_t mp_lv_mem_defrag(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    ((void (*)(void))lv_func_ptr)();
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mem_defrag_obj, 0, mp_lv_mem_defrag, lv_mem_defrag);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_mem_test(void)
 */
 
STATIC mp_obj_t mp_lv_mem_test(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_res_t _res = ((lv_res_t (*)(void))lv_func_ptr)();
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_mem_test_obj, 0, mp_lv_mem_test, lv_mem_test);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_task_handler(void)
 */
 
STATIC mp_obj_t mp_lv_task_handler(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    uint32_t _res = ((uint32_t (*)(void))lv_func_ptr)();
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_task_handler_obj, 0, mp_lv_task_handler, lv_task_handler);
    

/*
 * lvgl extension definition for:
 * lv_task_t *lv_task_create_basic(void)
 */
 
STATIC mp_obj_t mp_lv_task_create_basic(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_task_t * _res = ((lv_task_t *(*)(void))lv_func_ptr)();
    return mp_read_ptr_lv_task_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_task_create_basic_obj, 0, mp_lv_task_create_basic, lv_task_create_basic);
    

/*
 * Callback function task_xcb
 * void lv_task_cb_t(struct _lv_task_t *)
 */

STATIC void task_xcb_callback(struct _lv_task_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_task_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_task_xcb)) , 1, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * lv_task_t *lv_task_create(lv_task_cb_t task_xcb, uint32_t period, lv_task_prio_t prio, void *user_data)
 */
 
STATIC mp_obj_t mp_lv_task_create(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[3]);
    uint32_t period = (uint32_t)mp_obj_get_int(mp_args[1]);
    lv_task_prio_t prio = (uint8_t)mp_obj_get_int(mp_args[2]);
    void *task_xcb = mp_lv_callback(mp_args[0], &task_xcb_callback, MP_QSTR_task_xcb, &user_data);
    lv_task_t * _res = ((lv_task_t *(*)(lv_task_cb_t, uint32_t, lv_task_prio_t, void *))lv_func_ptr)(task_xcb, period, prio, user_data);
    return mp_read_ptr_lv_task_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_task_create_obj, 4, mp_lv_task_create, lv_task_create);
    

/*
 * lvgl extension definition for:
 * void lv_task_enable(bool en)
 */
 
STATIC mp_obj_t mp_lv_task_enable(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    bool en = mp_obj_is_true(mp_args[0]);
    ((void (*)(bool))lv_func_ptr)(en);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_task_enable_obj, 1, mp_lv_task_enable, lv_task_enable);
    

/*
 * lvgl extension definition for:
 * uint8_t lv_task_get_idle(void)
 */
 
STATIC mp_obj_t mp_lv_task_get_idle(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    uint8_t _res = ((uint8_t (*)(void))lv_func_ptr)();
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_task_get_idle_obj, 0, mp_lv_task_get_idle, lv_task_get_idle);
    

/*
 * Callback function async_xcb
 * void lv_async_cb_t(void *)
 */

STATIC void async_xcb_callback(void * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = ptr_to_mp((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_async_xcb)) , 1, 0, mp_args);
    return;
}


/*
 * lvgl extension definition for:
 * lv_res_t lv_async_call(lv_async_cb_t async_xcb, void *user_data)
 */
 
STATIC mp_obj_t mp_lv_async_call(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *user_data = mp_to_ptr(mp_args[1]);
    void *async_xcb = mp_lv_callback(mp_args[0], &async_xcb_callback, MP_QSTR_async_xcb, &user_data);
    lv_res_t _res = ((lv_res_t (*)(lv_async_cb_t, void *))lv_func_ptr)(async_xcb, user_data);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_async_call_obj, 2, mp_lv_async_call, lv_async_call);
    

/*
 * lvgl extension definition for:
 * lv_color_t lv_color_hsv_to_rgb(uint16_t h, uint8_t s, uint8_t v)
 */
 
STATIC mp_obj_t mp_lv_color_hsv_to_rgb(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint16_t h = (uint16_t)mp_obj_get_int(mp_args[0]);
    uint8_t s = (uint8_t)mp_obj_get_int(mp_args[1]);
    uint8_t v = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_color_t _res = ((lv_color_t (*)(uint16_t, uint8_t, uint8_t))lv_func_ptr)(h, s, v);
    return mp_read_lv_color32_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_hsv_to_rgb_obj, 3, mp_lv_color_hsv_to_rgb, lv_color_hsv_to_rgb);
    

/*
 * lvgl extension definition for:
 * lv_color_hsv_t lv_color_rgb_to_hsv(uint8_t r8, uint8_t g8, uint8_t b8)
 */
 
STATIC mp_obj_t mp_lv_color_rgb_to_hsv(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint8_t r8 = (uint8_t)mp_obj_get_int(mp_args[0]);
    uint8_t g8 = (uint8_t)mp_obj_get_int(mp_args[1]);
    uint8_t b8 = (uint8_t)mp_obj_get_int(mp_args[2]);
    lv_color_hsv_t _res = ((lv_color_hsv_t (*)(uint8_t, uint8_t, uint8_t))lv_func_ptr)(r8, g8, b8);
    return mp_read_lv_color_hsv_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_color_rgb_to_hsv_obj, 3, mp_lv_color_rgb_to_hsv, lv_color_rgb_to_hsv);
    

/*
 * lvgl extension definition for:
 * lv_disp_t *lv_disp_get_default(void)
 */
 
STATIC mp_obj_t mp_lv_disp_get_default(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_disp_t * _res = ((lv_disp_t *(*)(void))lv_func_ptr)();
    return mp_read_ptr_lv_disp_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_disp_get_default_obj, 0, mp_lv_disp_get_default, lv_disp_get_default);
    

/*
 * lvgl extension definition for:
 * void lv_tick_inc(uint32_t tick_period)
 */
 
STATIC mp_obj_t mp_lv_tick_inc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint32_t tick_period = (uint32_t)mp_obj_get_int(mp_args[0]);
    ((void (*)(uint32_t))lv_func_ptr)(tick_period);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_tick_inc_obj, 1, mp_lv_tick_inc, lv_tick_inc);
    
/* Reusing lv_task_handler for lv_tick_get */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_tick_get_obj, 0, mp_lv_task_handler, lv_tick_get);
    

/*
 * lvgl extension definition for:
 * uint32_t lv_tick_elaps(uint32_t prev_tick)
 */
 
STATIC mp_obj_t mp_lv_tick_elaps(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint32_t prev_tick = (uint32_t)mp_obj_get_int(mp_args[0]);
    uint32_t _res = ((uint32_t (*)(uint32_t))lv_func_ptr)(prev_tick);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_tick_elaps_obj, 1, mp_lv_tick_elaps, lv_tick_elaps);
    

/*
 * Function NOT generated:
 * Callback function 'lv_anim_exec_xcb_t exec_cb' must receive a struct pointer with user_data member as its first argument!
 * lv_anim_exec_xcb_t exec_cb
 */
    

/*
 * lvgl extension definition for:
 * bool lv_anim_del(void *var, lv_anim_exec_xcb_t exec_cb)
 */
 
STATIC mp_obj_t mp_lv_anim_del(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *var = mp_to_ptr(mp_args[0]);
    lv_anim_exec_xcb_t exec_cb = mp_to_ptr(mp_args[1]);
    bool _res = ((bool (*)(void *, lv_anim_exec_xcb_t))lv_func_ptr)(var, exec_cb);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_del_obj, 2, mp_lv_anim_del, lv_anim_del);
    

/*
 * Function NOT generated:
 * Callback function 'lv_anim_exec_xcb_t exec_cb' must receive a struct pointer with user_data member as its first argument!
 * lv_anim_exec_xcb_t exec_cb
 */
    

/*
 * lvgl extension definition for:
 * lv_anim_t *lv_anim_get(void *var, lv_anim_exec_xcb_t exec_cb)
 */
 
STATIC mp_obj_t mp_lv_anim_get(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *var = mp_to_ptr(mp_args[0]);
    lv_anim_exec_xcb_t exec_cb = mp_to_ptr(mp_args[1]);
    lv_anim_t * _res = ((lv_anim_t *(*)(void *, lv_anim_exec_xcb_t))lv_func_ptr)(var, exec_cb);
    return mp_read_ptr_lv_anim_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_get_obj, 2, mp_lv_anim_get, lv_anim_get);
    

/*
 * lvgl extension definition for:
 * uint16_t lv_anim_count_running(void)
 */
 
STATIC mp_obj_t mp_lv_anim_count_running(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    uint16_t _res = ((uint16_t (*)(void))lv_func_ptr)();
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_count_running_obj, 0, mp_lv_anim_count_running, lv_anim_count_running);
    

/*
 * lvgl extension definition for:
 * uint16_t lv_anim_speed_to_time(uint16_t speed, lv_anim_value_t start, lv_anim_value_t end)
 */
 
STATIC mp_obj_t mp_lv_anim_speed_to_time(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    uint16_t speed = (uint16_t)mp_obj_get_int(mp_args[0]);
    lv_anim_value_t start = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_anim_value_t end = (int16_t)mp_obj_get_int(mp_args[2]);
    uint16_t _res = ((uint16_t (*)(uint16_t, lv_anim_value_t, lv_anim_value_t))lv_func_ptr)(speed, start, end);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_speed_to_time_obj, 3, mp_lv_anim_speed_to_time, lv_anim_speed_to_time);
    
/* Reusing lv_mem_defrag for lv_anim_refr_now */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_anim_refr_now_obj, 0, mp_lv_mem_defrag, lv_anim_refr_now);
    

/*
 * lvgl extension definition for:
 * bool lv_debug_check_null(const void *p)
 */
 
STATIC mp_obj_t mp_lv_debug_check_null(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const void *p = mp_to_ptr(mp_args[0]);
    bool _res = ((bool (*)(const void *))lv_func_ptr)(p);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_debug_check_null_obj, 1, mp_lv_debug_check_null, lv_debug_check_null);
    

/*
 * lvgl extension definition for:
 * bool lv_debug_check_mem_integrity(void)
 */
 
STATIC mp_obj_t mp_lv_debug_check_mem_integrity(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    bool _res = ((bool (*)(void))lv_func_ptr)();
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_debug_check_mem_integrity_obj, 0, mp_lv_debug_check_mem_integrity, lv_debug_check_mem_integrity);
    
/* Reusing lv_debug_check_null for lv_debug_check_str */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_debug_check_str_obj, 1, mp_lv_debug_check_null, lv_debug_check_str);
    

/*
 * lvgl extension definition for:
 * void lv_debug_log_error(const char *msg, uint64_t value)
 */
 
STATIC mp_obj_t mp_lv_debug_log_error(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const char *msg = (char*)convert_from_str(mp_args[0]);
    uint64_t value = (uint64_t)mp_obj_get_ull(mp_args[1]);
    ((void (*)(const char *, uint64_t))lv_func_ptr)(msg, value);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_debug_log_error_obj, 2, mp_lv_debug_log_error, lv_debug_log_error);
    

/*
 * lvgl extension definition for:
 * int16_t lv_draw_mask_add(void *param, void *custom_id)
 */
 
STATIC mp_obj_t mp_lv_draw_mask_add(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *param = mp_to_ptr(mp_args[0]);
    void *custom_id = mp_to_ptr(mp_args[1]);
    int16_t _res = ((int16_t (*)(void *, void *))lv_func_ptr)(param, custom_id);
    return mp_obj_new_int(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_mask_add_obj, 2, mp_lv_draw_mask_add, lv_draw_mask_add);
    

/*
 * lvgl extension definition for:
 * lv_draw_mask_res_t lv_draw_mask_apply(lv_opa_t *mask_buf, lv_coord_t abs_x, lv_coord_t abs_y, lv_coord_t len)
 */
 
STATIC mp_obj_t mp_lv_draw_mask_apply(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_opa_t *mask_buf = mp_to_ptr(mp_args[0]);
    lv_coord_t abs_x = (int16_t)mp_obj_get_int(mp_args[1]);
    lv_coord_t abs_y = (int16_t)mp_obj_get_int(mp_args[2]);
    lv_coord_t len = (int16_t)mp_obj_get_int(mp_args[3]);
    lv_draw_mask_res_t _res = ((lv_draw_mask_res_t (*)(lv_opa_t *, lv_coord_t, lv_coord_t, lv_coord_t))lv_func_ptr)(mask_buf, abs_x, abs_y, len);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_mask_apply_obj, 4, mp_lv_draw_mask_apply, lv_draw_mask_apply);
    

/*
 * lvgl extension definition for:
 * void *lv_draw_mask_remove_id(int16_t id)
 */
 
STATIC mp_obj_t mp_lv_draw_mask_remove_id(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    int16_t id = (int16_t)mp_obj_get_int(mp_args[0]);
    void * _res = ((void *(*)(int16_t))lv_func_ptr)(id);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_mask_remove_id_obj, 1, mp_lv_draw_mask_remove_id, lv_draw_mask_remove_id);
    

/*
 * lvgl extension definition for:
 * void *lv_draw_mask_remove_custom(void *custom_id)
 */
 
STATIC mp_obj_t mp_lv_draw_mask_remove_custom(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    void *custom_id = mp_to_ptr(mp_args[0]);
    void * _res = ((void *(*)(void *))lv_func_ptr)(custom_id);
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_mask_remove_custom_obj, 1, mp_lv_draw_mask_remove_custom, lv_draw_mask_remove_custom);
    
/* Reusing lv_task_get_idle for lv_draw_mask_get_cnt */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_mask_get_cnt_obj, 0, mp_lv_task_get_idle, lv_draw_mask_get_cnt);
    

/*
 * lvgl extension definition for:
 * bool lv_debug_check_style(const lv_style_t *style)
 */
 
STATIC mp_obj_t mp_lv_debug_check_style(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[0]);
    bool _res = ((bool (*)(const lv_style_t *))lv_func_ptr)(style);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_debug_check_style_obj, 1, mp_lv_debug_check_style, lv_debug_check_style);
    

/*
 * lvgl extension definition for:
 * bool lv_debug_check_style_list(const lv_style_list_t *list)
 */
 
STATIC mp_obj_t mp_lv_debug_check_style_list(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_style_list_t *list = mp_write_ptr_lv_style_list_t(mp_args[0]);
    bool _res = ((bool (*)(const lv_style_list_t *))lv_func_ptr)(list);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_debug_check_style_list_obj, 1, mp_lv_debug_check_style_list, lv_debug_check_style_list);
    

/*
 * lvgl extension definition for:
 * void lv_draw_rect(const lv_area_t *coords, const lv_area_t *mask, const lv_draw_rect_dsc_t *dsc)
 */
 
STATIC mp_obj_t mp_lv_draw_rect(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_area_t *coords = mp_write_ptr_lv_area_t(mp_args[0]);
    const lv_area_t *mask = mp_write_ptr_lv_area_t(mp_args[1]);
    const lv_draw_rect_dsc_t *dsc = mp_write_ptr_lv_draw_rect_dsc_t(mp_args[2]);
    ((void (*)(const lv_area_t *, const lv_area_t *, const lv_draw_rect_dsc_t *))lv_func_ptr)(coords, mask, dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_rect_obj, 3, mp_lv_draw_rect, lv_draw_rect);
    

/*
 * lvgl extension definition for:
 * void lv_draw_px(const lv_point_t *point, const lv_area_t *clip_area, const lv_style_t *style)
 */
 
STATIC mp_obj_t mp_lv_draw_px(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_point_t *point = mp_write_ptr_lv_point_t(mp_args[0]);
    const lv_area_t *clip_area = mp_write_ptr_lv_area_t(mp_args[1]);
    const lv_style_t *style = mp_write_ptr_lv_style_t(mp_args[2]);
    ((void (*)(const lv_point_t *, const lv_area_t *, const lv_style_t *))lv_func_ptr)(point, clip_area, style);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_px_obj, 3, mp_lv_draw_px, lv_draw_px);
    

/*
 * Struct lv_draw_label_hint_t
 */

STATIC inline const mp_obj_type_t *get_mp_lv_draw_label_hint_t_type();

STATIC inline lv_draw_label_hint_t* mp_write_ptr_lv_draw_label_hint_t(mp_obj_t self_in)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(cast(self_in, get_mp_lv_draw_label_hint_t_type()));
    return (lv_draw_label_hint_t*)self->data;
}

#define mp_write_lv_draw_label_hint_t(struct_obj) *mp_write_ptr_lv_draw_label_hint_t(struct_obj)

STATIC inline mp_obj_t mp_read_ptr_lv_draw_label_hint_t(lv_draw_label_hint_t *field)
{
    return lv_to_mp_struct(get_mp_lv_draw_label_hint_t_type(), (void*)field);
}

#define mp_read_lv_draw_label_hint_t(field) mp_read_ptr_lv_draw_label_hint_t(copy_buffer(&field, sizeof(lv_draw_label_hint_t)))
#define mp_read_byref_lv_draw_label_hint_t(field) mp_read_ptr_lv_draw_label_hint_t(&field)

STATIC void mp_lv_draw_label_hint_t_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest)
{
    mp_lv_struct_t *self = MP_OBJ_TO_PTR(self_in);
    lv_draw_label_hint_t *data = (lv_draw_label_hint_t*)self->data;

    if (dest[0] == MP_OBJ_NULL) {
        // load attribute
        switch(attr)
        {
            case MP_QSTR_line_start: dest[0] = mp_obj_new_int(data->line_start); break; // converting from int32_t;
            case MP_QSTR_y: dest[0] = mp_obj_new_int(data->y); break; // converting from int32_t;
            case MP_QSTR_coord_y: dest[0] = mp_obj_new_int(data->coord_y); break; // converting from int32_t;
            default: call_parent_methods(self_in, attr, dest); // fallback to locals_dict lookup
        }
    } else {
        if (dest[1])
        {
            // store attribute
            switch(attr)
            {
                case MP_QSTR_line_start: data->line_start = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_y: data->y = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                case MP_QSTR_coord_y: data->coord_y = (int32_t)mp_obj_get_int(dest[1]); break; // converting to int32_t;
                default: return;
            }

            dest[0] = MP_OBJ_NULL; // indicate success
        }
    }
}

STATIC void mp_lv_draw_label_hint_t_print(const mp_print_t *print,
    mp_obj_t self_in,
    mp_print_kind_t kind)
{
    mp_printf(print, "struct lv_draw_label_hint_t");
}

STATIC const mp_obj_dict_t mp_lv_draw_label_hint_t_locals_dict;

STATIC const mp_obj_type_t mp_lv_draw_label_hint_t_type = {
    { &mp_type_type },
    .name = MP_QSTR_lv_draw_label_hint_t,
    .print = mp_lv_draw_label_hint_t_print,
    .make_new = make_new_lv_struct,
    .attr = mp_lv_draw_label_hint_t_attr,
    .locals_dict = (mp_obj_dict_t*)&mp_lv_draw_label_hint_t_locals_dict,
    .buffer_p = { .get_buffer = mp_blob_get_buffer }
};

STATIC inline const mp_obj_type_t *get_mp_lv_draw_label_hint_t_type()
{
    return &mp_lv_draw_label_hint_t_type;
}
    

/*
 * lvgl extension definition for:
 * void lv_draw_label(const lv_area_t *coords, const lv_area_t *mask, const lv_draw_label_dsc_t *dsc, const char *txt, lv_draw_label_hint_t *hint)
 */
 
STATIC mp_obj_t mp_lv_draw_label(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_area_t *coords = mp_write_ptr_lv_area_t(mp_args[0]);
    const lv_area_t *mask = mp_write_ptr_lv_area_t(mp_args[1]);
    const lv_draw_label_dsc_t *dsc = mp_write_ptr_lv_draw_label_dsc_t(mp_args[2]);
    const char *txt = (char*)convert_from_str(mp_args[3]);
    lv_draw_label_hint_t *hint = mp_write_ptr_lv_draw_label_hint_t(mp_args[4]);
    ((void (*)(const lv_area_t *, const lv_area_t *, const lv_draw_label_dsc_t *, const char *, lv_draw_label_hint_t *))lv_func_ptr)(coords, mask, dsc, txt, hint);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_label_obj, 5, mp_lv_draw_label, lv_draw_label);
    

STATIC const mp_rom_map_elem_t mp_lv_draw_label_hint_t_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_SIZE), MP_ROM_PTR(MP_ROM_INT(sizeof(lv_draw_label_hint_t))) },
    { MP_ROM_QSTR(MP_QSTR_cast), MP_ROM_PTR(&mp_lv_cast_class_method) },
    { MP_ROM_QSTR(MP_QSTR_cast_instance), MP_ROM_PTR(&mp_lv_cast_instance_obj) },
    { MP_ROM_QSTR(MP_QSTR___dereference__), MP_ROM_PTR(&mp_lv_dereference_obj) },
    
};

STATIC MP_DEFINE_CONST_DICT(mp_lv_draw_label_hint_t_locals_dict, mp_lv_draw_label_hint_t_locals_dict_table);
        

/*
 * lvgl extension definition for:
 * void lv_draw_line(const lv_point_t *point1, const lv_point_t *point2, const lv_area_t *clip, const lv_draw_line_dsc_t *dsc)
 */
 
STATIC mp_obj_t mp_lv_draw_line(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_point_t *point1 = mp_write_ptr_lv_point_t(mp_args[0]);
    const lv_point_t *point2 = mp_write_ptr_lv_point_t(mp_args[1]);
    const lv_area_t *clip = mp_write_ptr_lv_area_t(mp_args[2]);
    const lv_draw_line_dsc_t *dsc = mp_write_ptr_lv_draw_line_dsc_t(mp_args[3]);
    ((void (*)(const lv_point_t *, const lv_point_t *, const lv_area_t *, const lv_draw_line_dsc_t *))lv_func_ptr)(point1, point2, clip, dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_line_obj, 4, mp_lv_draw_line, lv_draw_line);
    

/*
 * lvgl extension definition for:
 * lv_fs_drv_t *lv_fs_get_drv(char letter)
 */
 
STATIC mp_obj_t mp_lv_fs_get_drv(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    char letter = (char)mp_obj_get_int(mp_args[0]);
    lv_fs_drv_t * _res = ((lv_fs_drv_t *(*)(char))lv_func_ptr)(letter);
    return mp_read_ptr_lv_fs_drv_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_fs_get_drv_obj, 1, mp_lv_fs_get_drv, lv_fs_get_drv);
    

/*
 * lvgl extension definition for:
 * bool lv_fs_is_ready(char letter)
 */
 
STATIC mp_obj_t mp_lv_fs_is_ready(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    char letter = (char)mp_obj_get_int(mp_args[0]);
    bool _res = ((bool (*)(char))lv_func_ptr)(letter);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_fs_is_ready_obj, 1, mp_lv_fs_is_ready, lv_fs_is_ready);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_remove(const char *path)
 */
 
STATIC mp_obj_t mp_lv_fs_remove(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const char *path = (char*)convert_from_str(mp_args[0]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(const char *))lv_func_ptr)(path);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_fs_remove_obj, 1, mp_lv_fs_remove, lv_fs_remove);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_rename(const char *oldname, const char *newname)
 */
 
STATIC mp_obj_t mp_lv_fs_rename(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const char *oldname = (char*)convert_from_str(mp_args[0]);
    const char *newname = (char*)convert_from_str(mp_args[1]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(const char *, const char *))lv_func_ptr)(oldname, newname);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_fs_rename_obj, 2, mp_lv_fs_rename, lv_fs_rename);
    

/*
 * lvgl extension definition for:
 * lv_fs_res_t lv_fs_free_space(char letter, uint32_t *total_p, uint32_t *free_p)
 */
 
STATIC mp_obj_t mp_lv_fs_free_space(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    char letter = (char)mp_obj_get_int(mp_args[0]);
    uint32_t *total_p = mp_to_ptr(mp_args[1]);
    uint32_t *free_p = mp_to_ptr(mp_args[2]);
    lv_fs_res_t _res = ((lv_fs_res_t (*)(char, uint32_t *, uint32_t *))lv_func_ptr)(letter, total_p, free_p);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_fs_free_space_obj, 3, mp_lv_fs_free_space, lv_fs_free_space);
    

/*
 * lvgl extension definition for:
 * char *lv_fs_get_letters(char *buf)
 */
 
STATIC mp_obj_t mp_lv_fs_get_letters(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    char *buf = (char*)convert_from_str(mp_args[0]);
    char * _res = ((char *(*)(char *))lv_func_ptr)(buf);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_fs_get_letters_obj, 1, mp_lv_fs_get_letters, lv_fs_get_letters);
    

/*
 * lvgl extension definition for:
 * const char *lv_fs_get_ext(const char *fn)
 */
 
STATIC mp_obj_t mp_lv_fs_get_ext(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const char *fn = (char*)convert_from_str(mp_args[0]);
    const char * _res = ((const char *(*)(const char *))lv_func_ptr)(fn);
    return convert_to_str((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_fs_get_ext_obj, 1, mp_lv_fs_get_ext, lv_fs_get_ext);
    
/* Reusing lv_fs_get_letters for lv_fs_up */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_fs_up_obj, 1, mp_lv_fs_get_letters, lv_fs_up);
    
/* Reusing lv_fs_get_ext for lv_fs_get_last */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_fs_get_last_obj, 1, mp_lv_fs_get_ext, lv_fs_get_last);
    

/*
 * lvgl extension definition for:
 * void lv_draw_img(const lv_area_t *coords, const lv_area_t *mask, const void *src, const lv_draw_img_dsc_t *dsc)
 */
 
STATIC mp_obj_t mp_lv_draw_img(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_area_t *coords = mp_write_ptr_lv_area_t(mp_args[0]);
    const lv_area_t *mask = mp_write_ptr_lv_area_t(mp_args[1]);
    const void *src = mp_to_ptr(mp_args[2]);
    const lv_draw_img_dsc_t *dsc = mp_write_ptr_lv_draw_img_dsc_t(mp_args[3]);
    ((void (*)(const lv_area_t *, const lv_area_t *, const void *, const lv_draw_img_dsc_t *))lv_func_ptr)(coords, mask, src, dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_img_obj, 4, mp_lv_draw_img, lv_draw_img);
    
/* Reusing lv_mem_defrag for lv_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_init_obj, 0, mp_lv_mem_defrag, lv_init);
    
/* Reusing lv_mem_defrag for lv_deinit */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_deinit_obj, 0, mp_lv_mem_defrag, lv_deinit);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_event_send(lv_obj_t *obj, lv_event_t event, const void *data)
 */
 
STATIC mp_obj_t mp_lv_event_send(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_event_t event = (uint8_t)mp_obj_get_int(mp_args[1]);
    const void *data = mp_to_ptr(mp_args[2]);
    lv_res_t _res = ((lv_res_t (*)(lv_obj_t *, lv_event_t, const void *))lv_func_ptr)(obj, event, data);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_send_obj, 3, mp_lv_event_send, lv_event_send);
    
/* Reusing lv_obj_del for lv_event_send_refresh */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_send_refresh_obj, 1, mp_lv_obj_del, lv_event_send_refresh);
    
/* Reusing lv_obj_clean for lv_event_send_refresh_recursive */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_event_send_refresh_recursive_obj, 1, mp_lv_obj_clean, lv_event_send_refresh_recursive);
    

/*
 * Function NOT generated:
 * Callback argument 'lv_event_cb_t event_xcb' cannot be the first argument! We assume the first argument contains the user_data
 * lv_event_cb_t event_xcb
 */
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_event_send_func(lv_event_cb_t event_xcb, lv_obj_t *obj, lv_event_t event, const void *data)
 */
 
STATIC mp_obj_t mp_lv_event_send_func(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_event_cb_t event_xcb = mp_to_ptr(mp_args[0]);
    lv_obj_t *obj = mp_to_lv(mp_args[1]);
    lv_event_t event = (uint8_t)mp_obj_get_int(mp_args[2]);
    const void *data = mp_to_ptr(mp_args[3]);
    lv_res_t _res = ((lv_res_t (*)(lv_event_cb_t, lv_obj_t *, lv_event_t, const void *))lv_func_ptr)(event_xcb, obj, event, data);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_event_send_func_obj, 4, mp_lv_event_send_func, lv_event_send_func);
    

/*
 * lvgl extension definition for:
 * const void *lv_event_get_data(void)
 */
 
STATIC mp_obj_t mp_lv_event_get_data(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    const void * _res = ((const void *(*)(void))lv_func_ptr)();
    return ptr_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_event_get_data_obj, 0, mp_lv_event_get_data, lv_event_get_data);
    

/*
 * lvgl extension definition for:
 * lv_res_t lv_signal_send(lv_obj_t *obj, lv_signal_t signal, void *param)
 */
 
STATIC mp_obj_t mp_lv_signal_send(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_signal_t signal = (uint8_t)mp_obj_get_int(mp_args[1]);
    void *param = mp_to_ptr(mp_args[2]);
    lv_res_t _res = ((lv_res_t (*)(lv_obj_t *, lv_signal_t, void *))lv_func_ptr)(obj, signal, param);
    return mp_obj_new_int_from_uint(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_signal_send_obj, 3, mp_lv_signal_send, lv_signal_send);
    

/*
 * lvgl extension definition for:
 * bool lv_debug_check_obj_type(const lv_obj_t *obj, const char *obj_type)
 */
 
STATIC mp_obj_t mp_lv_debug_check_obj_type(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_obj_t *obj = mp_to_lv(mp_args[0]);
    const char *obj_type = (char*)convert_from_str(mp_args[1]);
    bool _res = ((bool (*)(const lv_obj_t *, const char *))lv_func_ptr)(obj, obj_type);
    return convert_to_bool(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_debug_check_obj_type_obj, 2, mp_lv_debug_check_obj_type, lv_debug_check_obj_type);
    
/* Reusing lv_obj_is_visible for lv_debug_check_obj_valid */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_debug_check_obj_valid_obj, 1, mp_lv_obj_is_visible, lv_debug_check_obj_valid);
    

/*
 * lvgl extension definition for:
 * lv_group_t *lv_group_create(void)
 */
 
STATIC mp_obj_t mp_lv_group_create(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_group_t * _res = ((lv_group_t *(*)(void))lv_func_ptr)();
    return mp_read_ptr_lv_group_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_group_create_obj, 0, mp_lv_group_create, lv_group_create);
    
/* Reusing lv_obj_clean for lv_group_remove_obj */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_remove_obj_obj, 1, mp_lv_obj_clean, lv_group_remove_obj);
    
/* Reusing lv_obj_clean for lv_group_focus_obj */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_group_focus_obj_obj, 1, mp_lv_obj_clean, lv_group_focus_obj);
    

/*
 * lvgl extension definition for:
 * lv_indev_t *lv_indev_get_act(void)
 */
 
STATIC mp_obj_t mp_lv_indev_get_act(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_indev_t * _res = ((lv_indev_t *(*)(void))lv_func_ptr)();
    return mp_read_ptr_lv_indev_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_indev_get_act_obj, 0, mp_lv_indev_get_act, lv_indev_get_act);
    
/* Reusing lv_scr_act for lv_indev_get_obj_act */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_indev_get_obj_act_obj, 0, mp_lv_scr_act, lv_indev_get_obj_act);
    

/*
 * lvgl extension definition for:
 * lv_obj_t *lv_indev_search_obj(lv_obj_t *obj, lv_point_t *point)
 */
 
STATIC mp_obj_t mp_lv_indev_search_obj(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *obj = mp_to_lv(mp_args[0]);
    lv_point_t *point = mp_write_ptr_lv_point_t(mp_args[1]);
    lv_obj_t * _res = ((lv_obj_t *(*)(lv_obj_t *, lv_point_t *))lv_func_ptr)(obj, point);
    return lv_to_mp((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_indev_search_obj_obj, 2, mp_lv_indev_search_obj, lv_indev_search_obj);
    

/*
 * lvgl extension definition for:
 * lv_task_t *lv_indev_get_read_task(lv_disp_t *indev)
 */
 
STATIC mp_obj_t mp_lv_indev_get_read_task(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_disp_t *indev = mp_write_ptr_lv_disp_t(mp_args[0]);
    lv_task_t * _res = ((lv_task_t *(*)(lv_disp_t *))lv_func_ptr)(indev);
    return mp_read_ptr_lv_task_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_indev_get_read_task_obj, 1, mp_lv_indev_get_read_task, lv_indev_get_read_task);
    
/* Reusing lv_disp_remove for lv_refr_now */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_refr_now_obj, 1, mp_lv_disp_remove, lv_refr_now);
    
/* Reusing lv_obj_clean for lv_disp_load_scr */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_disp_load_scr_obj, 1, mp_lv_obj_clean, lv_disp_load_scr);
    

/*
 * lvgl extension definition for:
 * void lv_scr_load_anim(lv_obj_t *scr, lv_scr_load_anim_t anim_type, uint32_t time, uint32_t delay, bool auto_del)
 */
 
STATIC mp_obj_t mp_lv_scr_load_anim(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_obj_t *scr = mp_to_lv(mp_args[0]);
    lv_scr_load_anim_t anim_type = (int)mp_obj_get_int(mp_args[1]);
    uint32_t time = (uint32_t)mp_obj_get_int(mp_args[2]);
    uint32_t delay = (uint32_t)mp_obj_get_int(mp_args[3]);
    bool auto_del = mp_obj_is_true(mp_args[4]);
    ((void (*)(lv_obj_t *, lv_scr_load_anim_t, uint32_t, uint32_t, bool))lv_func_ptr)(scr, anim_type, time, delay, auto_del);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_scr_load_anim_obj, 5, mp_lv_scr_load_anim, lv_scr_load_anim);
    

/*
 * lvgl extension definition for:
 * lv_theme_t *lv_theme_get_act(void)
 */
 
STATIC mp_obj_t mp_lv_theme_get_act(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_theme_t * _res = ((lv_theme_t *(*)(void))lv_func_ptr)();
    return mp_read_ptr_lv_theme_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_theme_get_act_obj, 0, mp_lv_theme_get_act, lv_theme_get_act);
    
/* Reusing funcptr_lv_theme_apply_xcb_t for lv_theme_apply */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_VAR(mp_lv_theme_apply_obj, 2, mp_funcptr_lv_theme_apply_xcb_t, lv_theme_apply);
    

/*
 * lvgl extension definition for:
 * const lv_font_t *lv_theme_get_font_small(void)
 */
 
STATIC mp_obj_t mp_lv_theme_get_font_small(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    const lv_font_t * _res = ((const lv_font_t *(*)(void))lv_func_ptr)();
    return mp_read_ptr_lv_font_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_theme_get_font_small_obj, 0, mp_lv_theme_get_font_small, lv_theme_get_font_small);
    
/* Reusing lv_theme_get_font_small for lv_theme_get_font_normal */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_theme_get_font_normal_obj, 0, mp_lv_theme_get_font_small, lv_theme_get_font_normal);
    
/* Reusing lv_theme_get_font_small for lv_theme_get_font_subtitle */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_theme_get_font_subtitle_obj, 0, mp_lv_theme_get_font_small, lv_theme_get_font_subtitle);
    
/* Reusing lv_theme_get_font_small for lv_theme_get_font_title */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_theme_get_font_title_obj, 0, mp_lv_theme_get_font_small, lv_theme_get_font_title);
    

/*
 * lvgl extension definition for:
 * lv_color_t lv_theme_get_color_primary(void)
 */
 
STATIC mp_obj_t mp_lv_theme_get_color_primary(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    
    lv_color_t _res = ((lv_color_t (*)(void))lv_func_ptr)();
    return mp_read_lv_color32_t(_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_theme_get_color_primary_obj, 0, mp_lv_theme_get_color_primary, lv_theme_get_color_primary);
    
/* Reusing lv_theme_get_color_primary for lv_theme_get_color_secondary */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_theme_get_color_secondary_obj, 0, mp_lv_theme_get_color_primary, lv_theme_get_color_secondary);
    
/* Reusing lv_task_handler for lv_theme_get_flags */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_theme_get_flags_obj, 0, mp_lv_task_handler, lv_theme_get_flags);
    

/*
 * lvgl extension definition for:
 * lv_theme_t *lv_theme_empty_init(lv_color_t color_primary, lv_color_t color_secondary, uint32_t flags, const lv_font_t *font_small, const lv_font_t *font_normal, const lv_font_t *font_subtitle, const lv_font_t *font_title)
 */
 
STATIC mp_obj_t mp_lv_theme_empty_init(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_color_t color_primary = mp_write_lv_color32_t(mp_args[0]);
    lv_color_t color_secondary = mp_write_lv_color32_t(mp_args[1]);
    uint32_t flags = (uint32_t)mp_obj_get_int(mp_args[2]);
    const lv_font_t *font_small = mp_write_ptr_lv_font_t(mp_args[3]);
    const lv_font_t *font_normal = mp_write_ptr_lv_font_t(mp_args[4]);
    const lv_font_t *font_subtitle = mp_write_ptr_lv_font_t(mp_args[5]);
    const lv_font_t *font_title = mp_write_ptr_lv_font_t(mp_args[6]);
    lv_theme_t * _res = ((lv_theme_t *(*)(lv_color_t, lv_color_t, uint32_t, const lv_font_t *, const lv_font_t *, const lv_font_t *, const lv_font_t *))lv_func_ptr)(color_primary, color_secondary, flags, font_small, font_normal, font_subtitle, font_title);
    return mp_read_ptr_lv_theme_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_theme_empty_init_obj, 7, mp_lv_theme_empty_init, lv_theme_empty_init);
    
/* Reusing lv_theme_empty_init for lv_theme_template_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_theme_template_init_obj, 7, mp_lv_theme_empty_init, lv_theme_template_init);
    
/* Reusing lv_theme_empty_init for lv_theme_material_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_theme_material_init_obj, 7, mp_lv_theme_empty_init, lv_theme_material_init);
    
/* Reusing lv_theme_empty_init for lv_theme_mono_init */

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_theme_mono_init_obj, 7, mp_lv_theme_empty_init, lv_theme_mono_init);
    

/*
 * lvgl extension definition for:
 * lv_font_t *lv_font_load(const char *fontName)
 */
 
STATIC mp_obj_t mp_lv_font_load(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const char *fontName = (char*)convert_from_str(mp_args[0]);
    lv_font_t * _res = ((lv_font_t *(*)(const char *))lv_func_ptr)(fontName);
    return mp_read_ptr_lv_font_t((void*)_res);
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_font_load_obj, 1, mp_lv_font_load, lv_font_load);
    

/*
 * lvgl extension definition for:
 * void lv_draw_triangle(const lv_point_t points[], const lv_area_t *clip, const lv_draw_rect_dsc_t *draw_dsc)
 */
 
STATIC mp_obj_t mp_lv_draw_triangle(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_point_t *points = mp_arr_to_lv_point_t_____(mp_args[0]);
    const lv_area_t *clip = mp_write_ptr_lv_area_t(mp_args[1]);
    const lv_draw_rect_dsc_t *draw_dsc = mp_write_ptr_lv_draw_rect_dsc_t(mp_args[2]);
    ((void (*)(const lv_point_t [], const lv_area_t *, const lv_draw_rect_dsc_t *))lv_func_ptr)(points, clip, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_triangle_obj, 3, mp_lv_draw_triangle, lv_draw_triangle);
    

/*
 * lvgl extension definition for:
 * void lv_draw_polygon(const lv_point_t points[], uint16_t point_cnt, const lv_area_t *mask, const lv_draw_rect_dsc_t *draw_dsc)
 */
 
STATIC mp_obj_t mp_lv_draw_polygon(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    const lv_point_t *points = mp_arr_to_lv_point_t_____(mp_args[0]);
    uint16_t point_cnt = (uint16_t)mp_obj_get_int(mp_args[1]);
    const lv_area_t *mask = mp_write_ptr_lv_area_t(mp_args[2]);
    const lv_draw_rect_dsc_t *draw_dsc = mp_write_ptr_lv_draw_rect_dsc_t(mp_args[3]);
    ((void (*)(const lv_point_t [], uint16_t, const lv_area_t *, const lv_draw_rect_dsc_t *))lv_func_ptr)(points, point_cnt, mask, draw_dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_polygon_obj, 4, mp_lv_draw_polygon, lv_draw_polygon);
    

/*
 * lvgl extension definition for:
 * void lv_draw_arc(lv_coord_t center_x, lv_coord_t center_y, uint16_t radius, uint16_t start_angle, uint16_t end_angle, const lv_area_t *clip_area, const lv_draw_line_dsc_t *dsc)
 */
 
STATIC mp_obj_t mp_lv_draw_arc(size_t mp_n_args, const mp_obj_t *mp_args, void *lv_func_ptr)
{
    lv_coord_t center_x = (int16_t)mp_obj_get_int(mp_args[0]);
    lv_coord_t center_y = (int16_t)mp_obj_get_int(mp_args[1]);
    uint16_t radius = (uint16_t)mp_obj_get_int(mp_args[2]);
    uint16_t start_angle = (uint16_t)mp_obj_get_int(mp_args[3]);
    uint16_t end_angle = (uint16_t)mp_obj_get_int(mp_args[4]);
    const lv_area_t *clip_area = mp_write_ptr_lv_area_t(mp_args[5]);
    const lv_draw_line_dsc_t *dsc = mp_write_ptr_lv_draw_line_dsc_t(mp_args[6]);
    ((void (*)(lv_coord_t, lv_coord_t, uint16_t, uint16_t, uint16_t, const lv_area_t *, const lv_draw_line_dsc_t *))lv_func_ptr)(center_x, center_y, radius, start_angle, end_angle, clip_area, dsc);
    return mp_const_none;
}

 

STATIC MP_DEFINE_CONST_LV_FUN_OBJ_STATIC_VAR(mp_lv_draw_arc_obj, 7, mp_lv_draw_arc, lv_draw_arc);
    

/*
 * Function NOT generated:
 * Missing conversion to lv_mem_buf_arr_t when generating global _lv_mem_buf
 * _lv_mem_buf
 */
    

/*
 * lvgl lv_font_montserrat_14 global definitions
 */

STATIC const mp_lv_struct_t mp_lv_font_montserrat_14 = {
    { &mp_lv_font_t_type },
    (lv_font_t*)&lv_font_montserrat_14
};
    

/*
 * lvgl lv_font_montserrat_16 global definitions
 */

STATIC const mp_lv_struct_t mp_lv_font_montserrat_16 = {
    { &mp_lv_font_t_type },
    (lv_font_t*)&lv_font_montserrat_16
};
    

/*
 * lvgl lv_font_dejavu_16_persian_hebrew global definitions
 */

STATIC const mp_lv_struct_t mp_lv_font_dejavu_16_persian_hebrew = {
    { &mp_lv_font_t_type },
    (lv_font_t*)&lv_font_dejavu_16_persian_hebrew
};
    

/*
 * lvgl lv_anim_path_def global definitions
 */

STATIC const mp_lv_struct_t mp_lv_anim_path_def = {
    { &mp_lv_anim_path_t_type },
    (lv_anim_path_t*)&lv_anim_path_def
};
    

/*
 * Callback function lv_font_t_get_glyph_dsc
 * bool get_glyph_dsc(const struct _lv_font_struct *, lv_font_glyph_dsc_t *, uint32_t letter, uint32_t letter_next)
 */

STATIC bool lv_font_t_get_glyph_dsc_callback(const struct _lv_font_struct * arg0, lv_font_glyph_dsc_t * arg1, uint32_t arg2, uint32_t arg3)
{
    mp_obj_t mp_args[4];
    mp_args[0] = mp_read_ptr_lv_font_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_font_glyph_dsc_t((void*)arg1);
    mp_args[2] = mp_obj_new_int_from_uint(arg2);
    mp_args[3] = mp_obj_new_int_from_uint(arg3);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_font_t_get_glyph_dsc)) , 4, 0, mp_args);
    return mp_obj_is_true(callback_result);
}


/*
 * Callback function lv_font_t_get_glyph_bitmap
 * const uint8_t *get_glyph_bitmap(const struct _lv_font_struct *, uint32_t)
 */

STATIC const uint8_t * lv_font_t_get_glyph_bitmap_callback(const struct _lv_font_struct * arg0, uint32_t arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_font_t((void*)arg0);
    mp_args[1] = mp_obj_new_int_from_uint(arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_font_t_get_glyph_bitmap)) , 2, 0, mp_args);
    return mp_to_ptr(callback_result);
}


/*
 * Callback function lv_anim_t_ready_cb
 * void lv_anim_ready_cb_t(struct _lv_anim_t *)
 */

STATIC void lv_anim_t_ready_cb_callback(struct _lv_anim_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_anim_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_anim_t_ready_cb)) , 1, 0, mp_args);
    return;
}


/*
 * Callback function lv_disp_drv_t_flush_cb
 * void flush_cb(struct _disp_drv_t *disp_drv, const lv_area_t *area, lv_color_t *color_p)
 */

STATIC void lv_disp_drv_t_flush_cb_callback(struct _disp_drv_t * arg0, const lv_area_t * arg1, lv_color_t * arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_disp_drv_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_area_t((void*)arg1);
    mp_args[2] = mp_read_ptr_lv_color32_t((void*)arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_disp_drv_t_flush_cb)) , 3, 0, mp_args);
    return;
}


/*
 * Callback function lv_disp_drv_t_rounder_cb
 * void rounder_cb(struct _disp_drv_t *disp_drv, lv_area_t *area)
 */

STATIC void lv_disp_drv_t_rounder_cb_callback(struct _disp_drv_t * arg0, lv_area_t * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_disp_drv_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_area_t((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_disp_drv_t_rounder_cb)) , 2, 0, mp_args);
    return;
}


/*
 * Callback function lv_disp_drv_t_set_px_cb
 * void set_px_cb(struct _disp_drv_t *disp_drv, uint8_t *buf, lv_coord_t buf_w, lv_coord_t x, lv_coord_t y, lv_color_t color, lv_opa_t opa)
 */

STATIC void lv_disp_drv_t_set_px_cb_callback(struct _disp_drv_t * arg0, uint8_t * arg1, lv_coord_t arg2, lv_coord_t arg3, lv_coord_t arg4, lv_color_t arg5, lv_opa_t arg6)
{
    mp_obj_t mp_args[7];
    mp_args[0] = mp_read_ptr_lv_disp_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = mp_obj_new_int(arg2);
    mp_args[3] = mp_obj_new_int(arg3);
    mp_args[4] = mp_obj_new_int(arg4);
    mp_args[5] = mp_read_lv_color32_t(arg5);
    mp_args[6] = mp_obj_new_int_from_uint(arg6);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_disp_drv_t_set_px_cb)) , 7, 0, mp_args);
    return;
}


/*
 * Callback function lv_disp_drv_t_monitor_cb
 * void monitor_cb(struct _disp_drv_t *disp_drv, uint32_t time, uint32_t px)
 */

STATIC void lv_disp_drv_t_monitor_cb_callback(struct _disp_drv_t * arg0, uint32_t arg1, uint32_t arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_disp_drv_t((void*)arg0);
    mp_args[1] = mp_obj_new_int_from_uint(arg1);
    mp_args[2] = mp_obj_new_int_from_uint(arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_disp_drv_t_monitor_cb)) , 3, 0, mp_args);
    return;
}


/*
 * Callback function lv_disp_drv_t_wait_cb
 * void wait_cb(struct _disp_drv_t *disp_drv)
 */

STATIC void lv_disp_drv_t_wait_cb_callback(struct _disp_drv_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_disp_drv_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_disp_drv_t_wait_cb)) , 1, 0, mp_args);
    return;
}


/*
 * Callback function lv_disp_drv_t_clean_dcache_cb
 * void clean_dcache_cb(struct _disp_drv_t *disp_drv)
 */

STATIC void lv_disp_drv_t_clean_dcache_cb_callback(struct _disp_drv_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_disp_drv_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_disp_drv_t_clean_dcache_cb)) , 1, 0, mp_args);
    return;
}


/*
 * Callback function lv_disp_drv_t_gpu_wait_cb
 * void gpu_wait_cb(struct _disp_drv_t *disp_drv)
 */

STATIC void lv_disp_drv_t_gpu_wait_cb_callback(struct _disp_drv_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_disp_drv_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_disp_drv_t_gpu_wait_cb)) , 1, 0, mp_args);
    return;
}


/*
 * Callback function lv_disp_drv_t_gpu_blend_cb
 * void gpu_blend_cb(struct _disp_drv_t *disp_drv, lv_color_t *dest, const lv_color_t *src, uint32_t length, lv_opa_t opa)
 */

STATIC void lv_disp_drv_t_gpu_blend_cb_callback(struct _disp_drv_t * arg0, lv_color_t * arg1, const lv_color_t * arg2, uint32_t arg3, lv_opa_t arg4)
{
    mp_obj_t mp_args[5];
    mp_args[0] = mp_read_ptr_lv_disp_drv_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_color32_t((void*)arg1);
    mp_args[2] = mp_read_ptr_lv_color32_t((void*)arg2);
    mp_args[3] = mp_obj_new_int_from_uint(arg3);
    mp_args[4] = mp_obj_new_int_from_uint(arg4);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_disp_drv_t_gpu_blend_cb)) , 5, 0, mp_args);
    return;
}


/*
 * Callback function lv_disp_drv_t_gpu_fill_cb
 * void gpu_fill_cb(struct _disp_drv_t *disp_drv, lv_color_t *dest_buf, lv_coord_t dest_width, const lv_area_t *fill_area, lv_color_t color)
 */

STATIC void lv_disp_drv_t_gpu_fill_cb_callback(struct _disp_drv_t * arg0, lv_color_t * arg1, lv_coord_t arg2, const lv_area_t * arg3, lv_color_t arg4)
{
    mp_obj_t mp_args[5];
    mp_args[0] = mp_read_ptr_lv_disp_drv_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_color32_t((void*)arg1);
    mp_args[2] = mp_obj_new_int(arg2);
    mp_args[3] = mp_read_ptr_lv_area_t((void*)arg3);
    mp_args[4] = mp_read_lv_color32_t(arg4);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_disp_drv_t_gpu_fill_cb)) , 5, 0, mp_args);
    return;
}


/*
 * Callback function lv_indev_drv_t_read_cb
 * bool read_cb(struct _lv_indev_drv_t *indev_drv, lv_indev_data_t *data)
 */

STATIC bool lv_indev_drv_t_read_cb_callback(struct _lv_indev_drv_t * arg0, lv_indev_data_t * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_indev_drv_t((void*)arg0);
    mp_args[1] = mp_read_ptr_lv_indev_data_t((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_indev_drv_t_read_cb)) , 2, 0, mp_args);
    return mp_obj_is_true(callback_result);
}


/*
 * Callback function lv_indev_drv_t_feedback_cb
 * void feedback_cb(struct _lv_indev_drv_t *, uint8_t)
 */

STATIC void lv_indev_drv_t_feedback_cb_callback(struct _lv_indev_drv_t * arg0, uint8_t arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_indev_drv_t((void*)arg0);
    mp_args[1] = mp_obj_new_int_from_uint(arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_indev_drv_t_feedback_cb)) , 2, 0, mp_args);
    return;
}


/*
 * Function NOT generated:
 * Callback: user_data NOT FOUND! lv_draw_mask_res_t lv_draw_mask_xcb_t(lv_opa_t *mask_buf, lv_coord_t abs_x, lv_coord_t abs_y, lv_coord_t len, void *p)
 * lv_draw_mask_res_t lv_draw_mask_xcb_t(lv_opa_t *mask_buf, lv_coord_t abs_x, lv_coord_t abs_y, lv_coord_t len, void *p)
 */
    

/*
 * Callback function lv_fs_drv_t_ready_cb
 * bool ready_cb(struct _lv_fs_drv_t *drv)
 */

STATIC bool lv_fs_drv_t_ready_cb_callback(struct _lv_fs_drv_t * arg0)
{
    mp_obj_t mp_args[1];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_ready_cb)) , 1, 0, mp_args);
    return mp_obj_is_true(callback_result);
}


/*
 * Callback function lv_fs_drv_t_open_cb
 * lv_fs_res_t open_cb(struct _lv_fs_drv_t *drv, void *file_p, const char *path, lv_fs_mode_t mode)
 */

STATIC lv_fs_res_t lv_fs_drv_t_open_cb_callback(struct _lv_fs_drv_t * arg0, void * arg1, const char * arg2, lv_fs_mode_t arg3)
{
    mp_obj_t mp_args[4];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = convert_to_str((void*)arg2);
    mp_args[3] = mp_obj_new_int_from_uint(arg3);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_open_cb)) , 4, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_close_cb
 * lv_fs_res_t close_cb(struct _lv_fs_drv_t *drv, void *file_p)
 */

STATIC lv_fs_res_t lv_fs_drv_t_close_cb_callback(struct _lv_fs_drv_t * arg0, void * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_close_cb)) , 2, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_remove_cb
 * lv_fs_res_t remove_cb(struct _lv_fs_drv_t *drv, const char *fn)
 */

STATIC lv_fs_res_t lv_fs_drv_t_remove_cb_callback(struct _lv_fs_drv_t * arg0, const char * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = convert_to_str((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_remove_cb)) , 2, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_read_cb
 * lv_fs_res_t read_cb(struct _lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btr, uint32_t *br)
 */

STATIC lv_fs_res_t lv_fs_drv_t_read_cb_callback(struct _lv_fs_drv_t * arg0, void * arg1, void * arg2, uint32_t arg3, uint32_t * arg4)
{
    mp_obj_t mp_args[5];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = ptr_to_mp((void*)arg2);
    mp_args[3] = mp_obj_new_int_from_uint(arg3);
    mp_args[4] = ptr_to_mp((void*)arg4);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_read_cb)) , 5, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_write_cb
 * lv_fs_res_t write_cb(struct _lv_fs_drv_t *drv, void *file_p, const void *buf, uint32_t btw, uint32_t *bw)
 */

STATIC lv_fs_res_t lv_fs_drv_t_write_cb_callback(struct _lv_fs_drv_t * arg0, void * arg1, const void * arg2, uint32_t arg3, uint32_t * arg4)
{
    mp_obj_t mp_args[5];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = ptr_to_mp((void*)arg2);
    mp_args[3] = mp_obj_new_int_from_uint(arg3);
    mp_args[4] = ptr_to_mp((void*)arg4);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_write_cb)) , 5, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_seek_cb
 * lv_fs_res_t seek_cb(struct _lv_fs_drv_t *drv, void *file_p, uint32_t pos)
 */

STATIC lv_fs_res_t lv_fs_drv_t_seek_cb_callback(struct _lv_fs_drv_t * arg0, void * arg1, uint32_t arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = mp_obj_new_int_from_uint(arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_seek_cb)) , 3, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_tell_cb
 * lv_fs_res_t tell_cb(struct _lv_fs_drv_t *drv, void *file_p, uint32_t *pos_p)
 */

STATIC lv_fs_res_t lv_fs_drv_t_tell_cb_callback(struct _lv_fs_drv_t * arg0, void * arg1, uint32_t * arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = ptr_to_mp((void*)arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_tell_cb)) , 3, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_trunc_cb
 * lv_fs_res_t trunc_cb(struct _lv_fs_drv_t *drv, void *file_p)
 */

STATIC lv_fs_res_t lv_fs_drv_t_trunc_cb_callback(struct _lv_fs_drv_t * arg0, void * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_trunc_cb)) , 2, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_size_cb
 * lv_fs_res_t size_cb(struct _lv_fs_drv_t *drv, void *file_p, uint32_t *size_p)
 */

STATIC lv_fs_res_t lv_fs_drv_t_size_cb_callback(struct _lv_fs_drv_t * arg0, void * arg1, uint32_t * arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = ptr_to_mp((void*)arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_size_cb)) , 3, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_rename_cb
 * lv_fs_res_t rename_cb(struct _lv_fs_drv_t *drv, const char *oldname, const char *newname)
 */

STATIC lv_fs_res_t lv_fs_drv_t_rename_cb_callback(struct _lv_fs_drv_t * arg0, const char * arg1, const char * arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = convert_to_str((void*)arg1);
    mp_args[2] = convert_to_str((void*)arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_rename_cb)) , 3, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_free_space_cb
 * lv_fs_res_t free_space_cb(struct _lv_fs_drv_t *drv, uint32_t *total_p, uint32_t *free_p)
 */

STATIC lv_fs_res_t lv_fs_drv_t_free_space_cb_callback(struct _lv_fs_drv_t * arg0, uint32_t * arg1, uint32_t * arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = ptr_to_mp((void*)arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_free_space_cb)) , 3, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_dir_open_cb
 * lv_fs_res_t dir_open_cb(struct _lv_fs_drv_t *drv, void *rddir_p, const char *path)
 */

STATIC lv_fs_res_t lv_fs_drv_t_dir_open_cb_callback(struct _lv_fs_drv_t * arg0, void * arg1, const char * arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = convert_to_str((void*)arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_dir_open_cb)) , 3, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_dir_read_cb
 * lv_fs_res_t dir_read_cb(struct _lv_fs_drv_t *drv, void *rddir_p, char *fn)
 */

STATIC lv_fs_res_t lv_fs_drv_t_dir_read_cb_callback(struct _lv_fs_drv_t * arg0, void * arg1, char * arg2)
{
    mp_obj_t mp_args[3];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_args[2] = convert_to_str((void*)arg2);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_dir_read_cb)) , 3, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_fs_drv_t_dir_close_cb
 * lv_fs_res_t dir_close_cb(struct _lv_fs_drv_t *drv, void *rddir_p)
 */

STATIC lv_fs_res_t lv_fs_drv_t_dir_close_cb_callback(struct _lv_fs_drv_t * arg0, void * arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = mp_read_ptr_lv_fs_drv_t((void*)arg0);
    mp_args[1] = ptr_to_mp((void*)arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_obj_t callback_result = mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_fs_drv_t_dir_close_cb)) , 2, 0, mp_args);
    return (uint8_t)mp_obj_get_int(callback_result);
}


/*
 * Callback function lv_theme_t_apply_xcb
 * void lv_theme_apply_xcb_t(lv_obj_t *, lv_theme_style_t)
 */

STATIC void lv_theme_t_apply_xcb_callback(lv_obj_t * arg0, lv_theme_style_t arg1)
{
    mp_obj_t mp_args[2];
    mp_args[0] = lv_to_mp((void*)arg0);
    mp_args[1] = mp_obj_new_int(arg1);
    mp_obj_t callbacks = get_callback_dict_from_user_data(arg0->user_data);
    mp_call_function_n_kw(mp_obj_dict_get(callbacks, MP_OBJ_NEW_QSTR(MP_QSTR_lv_theme_t_apply_xcb)) , 2, 0, mp_args);
    return;
}



/*
 * lvgl module definitions
 */

STATIC const mp_rom_map_elem_t lvgl_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_lvgl) },
    { MP_ROM_QSTR(MP_QSTR_obj), MP_ROM_PTR(&mp_obj_type) },
    { MP_ROM_QSTR(MP_QSTR_cont), MP_ROM_PTR(&mp_cont_type) },
    { MP_ROM_QSTR(MP_QSTR_btn), MP_ROM_PTR(&mp_btn_type) },
    { MP_ROM_QSTR(MP_QSTR_imgbtn), MP_ROM_PTR(&mp_imgbtn_type) },
    { MP_ROM_QSTR(MP_QSTR_label), MP_ROM_PTR(&mp_label_type) },
    { MP_ROM_QSTR(MP_QSTR_img), MP_ROM_PTR(&mp_img_type) },
    { MP_ROM_QSTR(MP_QSTR_line), MP_ROM_PTR(&mp_line_type) },
    { MP_ROM_QSTR(MP_QSTR_page), MP_ROM_PTR(&mp_page_type) },
    { MP_ROM_QSTR(MP_QSTR_list), MP_ROM_PTR(&mp_list_type) },
    { MP_ROM_QSTR(MP_QSTR_chart), MP_ROM_PTR(&mp_chart_type) },
    { MP_ROM_QSTR(MP_QSTR_table), MP_ROM_PTR(&mp_table_type) },
    { MP_ROM_QSTR(MP_QSTR_checkbox), MP_ROM_PTR(&mp_checkbox_type) },
    { MP_ROM_QSTR(MP_QSTR_cpicker), MP_ROM_PTR(&mp_cpicker_type) },
    { MP_ROM_QSTR(MP_QSTR_bar), MP_ROM_PTR(&mp_bar_type) },
    { MP_ROM_QSTR(MP_QSTR_slider), MP_ROM_PTR(&mp_slider_type) },
    { MP_ROM_QSTR(MP_QSTR_led), MP_ROM_PTR(&mp_led_type) },
    { MP_ROM_QSTR(MP_QSTR_btnmatrix), MP_ROM_PTR(&mp_btnmatrix_type) },
    { MP_ROM_QSTR(MP_QSTR_keyboard), MP_ROM_PTR(&mp_keyboard_type) },
    { MP_ROM_QSTR(MP_QSTR_dropdown), MP_ROM_PTR(&mp_dropdown_type) },
    { MP_ROM_QSTR(MP_QSTR_roller), MP_ROM_PTR(&mp_roller_type) },
    { MP_ROM_QSTR(MP_QSTR_textarea), MP_ROM_PTR(&mp_textarea_type) },
    { MP_ROM_QSTR(MP_QSTR_canvas), MP_ROM_PTR(&mp_canvas_type) },
    { MP_ROM_QSTR(MP_QSTR_win), MP_ROM_PTR(&mp_win_type) },
    { MP_ROM_QSTR(MP_QSTR_tabview), MP_ROM_PTR(&mp_tabview_type) },
    { MP_ROM_QSTR(MP_QSTR_tileview), MP_ROM_PTR(&mp_tileview_type) },
    { MP_ROM_QSTR(MP_QSTR_msgbox), MP_ROM_PTR(&mp_msgbox_type) },
    { MP_ROM_QSTR(MP_QSTR_objmask), MP_ROM_PTR(&mp_objmask_type) },
    { MP_ROM_QSTR(MP_QSTR_linemeter), MP_ROM_PTR(&mp_linemeter_type) },
    { MP_ROM_QSTR(MP_QSTR_gauge), MP_ROM_PTR(&mp_gauge_type) },
    { MP_ROM_QSTR(MP_QSTR_switch), MP_ROM_PTR(&mp_switch_type) },
    { MP_ROM_QSTR(MP_QSTR_arc), MP_ROM_PTR(&mp_arc_type) },
    { MP_ROM_QSTR(MP_QSTR_spinner), MP_ROM_PTR(&mp_spinner_type) },
    { MP_ROM_QSTR(MP_QSTR_calendar), MP_ROM_PTR(&mp_calendar_type) },
    { MP_ROM_QSTR(MP_QSTR_spinbox), MP_ROM_PTR(&mp_spinbox_type) },
    
    { MP_ROM_QSTR(MP_QSTR_color_mix_premult), MP_ROM_PTR(&mp_lv_color_mix_premult_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_make), MP_ROM_PTR(&mp_lv_color_make_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_hex), MP_ROM_PTR(&mp_lv_color_hex_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_hex3), MP_ROM_PTR(&mp_lv_color_hex3_obj) },
    { MP_ROM_QSTR(MP_QSTR_scr_act), MP_ROM_PTR(&mp_lv_scr_act_obj) },
    { MP_ROM_QSTR(MP_QSTR_layer_top), MP_ROM_PTR(&mp_lv_layer_top_obj) },
    { MP_ROM_QSTR(MP_QSTR_layer_sys), MP_ROM_PTR(&mp_lv_layer_sys_obj) },
    { MP_ROM_QSTR(MP_QSTR_scr_load), MP_ROM_PTR(&mp_lv_scr_load_obj) },
    { MP_ROM_QSTR(MP_QSTR_dpx), MP_ROM_PTR(&mp_lv_dpx_obj) },
    { MP_ROM_QSTR(MP_QSTR_log_register_print_cb), MP_ROM_PTR(&mp_lv_log_register_print_cb_obj) },
    { MP_ROM_QSTR(MP_QSTR_mem_alloc), MP_ROM_PTR(&mp_lv_mem_alloc_obj) },
    { MP_ROM_QSTR(MP_QSTR_mem_free), MP_ROM_PTR(&mp_lv_mem_free_obj) },
    { MP_ROM_QSTR(MP_QSTR_mem_realloc), MP_ROM_PTR(&mp_lv_mem_realloc_obj) },
    { MP_ROM_QSTR(MP_QSTR_mem_defrag), MP_ROM_PTR(&mp_lv_mem_defrag_obj) },
    { MP_ROM_QSTR(MP_QSTR_mem_test), MP_ROM_PTR(&mp_lv_mem_test_obj) },
    { MP_ROM_QSTR(MP_QSTR_task_handler), MP_ROM_PTR(&mp_lv_task_handler_obj) },
    { MP_ROM_QSTR(MP_QSTR_task_create_basic), MP_ROM_PTR(&mp_lv_task_create_basic_obj) },
    { MP_ROM_QSTR(MP_QSTR_task_create), MP_ROM_PTR(&mp_lv_task_create_obj) },
    { MP_ROM_QSTR(MP_QSTR_task_enable), MP_ROM_PTR(&mp_lv_task_enable_obj) },
    { MP_ROM_QSTR(MP_QSTR_task_get_idle), MP_ROM_PTR(&mp_lv_task_get_idle_obj) },
    { MP_ROM_QSTR(MP_QSTR_async_call), MP_ROM_PTR(&mp_lv_async_call_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_hsv_to_rgb), MP_ROM_PTR(&mp_lv_color_hsv_to_rgb_obj) },
    { MP_ROM_QSTR(MP_QSTR_color_rgb_to_hsv), MP_ROM_PTR(&mp_lv_color_rgb_to_hsv_obj) },
    { MP_ROM_QSTR(MP_QSTR_disp_get_default), MP_ROM_PTR(&mp_lv_disp_get_default_obj) },
    { MP_ROM_QSTR(MP_QSTR_tick_inc), MP_ROM_PTR(&mp_lv_tick_inc_obj) },
    { MP_ROM_QSTR(MP_QSTR_tick_get), MP_ROM_PTR(&mp_lv_tick_get_obj) },
    { MP_ROM_QSTR(MP_QSTR_tick_elaps), MP_ROM_PTR(&mp_lv_tick_elaps_obj) },
    { MP_ROM_QSTR(MP_QSTR_anim_del), MP_ROM_PTR(&mp_lv_anim_del_obj) },
    { MP_ROM_QSTR(MP_QSTR_anim_get), MP_ROM_PTR(&mp_lv_anim_get_obj) },
    { MP_ROM_QSTR(MP_QSTR_anim_count_running), MP_ROM_PTR(&mp_lv_anim_count_running_obj) },
    { MP_ROM_QSTR(MP_QSTR_anim_speed_to_time), MP_ROM_PTR(&mp_lv_anim_speed_to_time_obj) },
    { MP_ROM_QSTR(MP_QSTR_anim_refr_now), MP_ROM_PTR(&mp_lv_anim_refr_now_obj) },
    { MP_ROM_QSTR(MP_QSTR_debug_check_null), MP_ROM_PTR(&mp_lv_debug_check_null_obj) },
    { MP_ROM_QSTR(MP_QSTR_debug_check_mem_integrity), MP_ROM_PTR(&mp_lv_debug_check_mem_integrity_obj) },
    { MP_ROM_QSTR(MP_QSTR_debug_check_str), MP_ROM_PTR(&mp_lv_debug_check_str_obj) },
    { MP_ROM_QSTR(MP_QSTR_debug_log_error), MP_ROM_PTR(&mp_lv_debug_log_error_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_add), MP_ROM_PTR(&mp_lv_draw_mask_add_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_apply), MP_ROM_PTR(&mp_lv_draw_mask_apply_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_remove_id), MP_ROM_PTR(&mp_lv_draw_mask_remove_id_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_remove_custom), MP_ROM_PTR(&mp_lv_draw_mask_remove_custom_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_get_cnt), MP_ROM_PTR(&mp_lv_draw_mask_get_cnt_obj) },
    { MP_ROM_QSTR(MP_QSTR_debug_check_style), MP_ROM_PTR(&mp_lv_debug_check_style_obj) },
    { MP_ROM_QSTR(MP_QSTR_debug_check_style_list), MP_ROM_PTR(&mp_lv_debug_check_style_list_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_rect), MP_ROM_PTR(&mp_lv_draw_rect_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_px), MP_ROM_PTR(&mp_lv_draw_px_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_label), MP_ROM_PTR(&mp_lv_draw_label_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_line), MP_ROM_PTR(&mp_lv_draw_line_obj) },
    { MP_ROM_QSTR(MP_QSTR_fs_get_drv), MP_ROM_PTR(&mp_lv_fs_get_drv_obj) },
    { MP_ROM_QSTR(MP_QSTR_fs_is_ready), MP_ROM_PTR(&mp_lv_fs_is_ready_obj) },
    { MP_ROM_QSTR(MP_QSTR_fs_remove), MP_ROM_PTR(&mp_lv_fs_remove_obj) },
    { MP_ROM_QSTR(MP_QSTR_fs_rename), MP_ROM_PTR(&mp_lv_fs_rename_obj) },
    { MP_ROM_QSTR(MP_QSTR_fs_free_space), MP_ROM_PTR(&mp_lv_fs_free_space_obj) },
    { MP_ROM_QSTR(MP_QSTR_fs_get_letters), MP_ROM_PTR(&mp_lv_fs_get_letters_obj) },
    { MP_ROM_QSTR(MP_QSTR_fs_get_ext), MP_ROM_PTR(&mp_lv_fs_get_ext_obj) },
    { MP_ROM_QSTR(MP_QSTR_fs_up), MP_ROM_PTR(&mp_lv_fs_up_obj) },
    { MP_ROM_QSTR(MP_QSTR_fs_get_last), MP_ROM_PTR(&mp_lv_fs_get_last_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_img), MP_ROM_PTR(&mp_lv_draw_img_obj) },
    { MP_ROM_QSTR(MP_QSTR_init), MP_ROM_PTR(&mp_lv_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_deinit), MP_ROM_PTR(&mp_lv_deinit_obj) },
    { MP_ROM_QSTR(MP_QSTR_event_send), MP_ROM_PTR(&mp_lv_event_send_obj) },
    { MP_ROM_QSTR(MP_QSTR_event_send_refresh), MP_ROM_PTR(&mp_lv_event_send_refresh_obj) },
    { MP_ROM_QSTR(MP_QSTR_event_send_refresh_recursive), MP_ROM_PTR(&mp_lv_event_send_refresh_recursive_obj) },
    { MP_ROM_QSTR(MP_QSTR_event_send_func), MP_ROM_PTR(&mp_lv_event_send_func_obj) },
    { MP_ROM_QSTR(MP_QSTR_event_get_data), MP_ROM_PTR(&mp_lv_event_get_data_obj) },
    { MP_ROM_QSTR(MP_QSTR_signal_send), MP_ROM_PTR(&mp_lv_signal_send_obj) },
    { MP_ROM_QSTR(MP_QSTR_debug_check_obj_type), MP_ROM_PTR(&mp_lv_debug_check_obj_type_obj) },
    { MP_ROM_QSTR(MP_QSTR_debug_check_obj_valid), MP_ROM_PTR(&mp_lv_debug_check_obj_valid_obj) },
    { MP_ROM_QSTR(MP_QSTR_group_create), MP_ROM_PTR(&mp_lv_group_create_obj) },
    { MP_ROM_QSTR(MP_QSTR_group_remove_obj), MP_ROM_PTR(&mp_lv_group_remove_obj_obj) },
    { MP_ROM_QSTR(MP_QSTR_group_focus_obj), MP_ROM_PTR(&mp_lv_group_focus_obj_obj) },
    { MP_ROM_QSTR(MP_QSTR_indev_get_act), MP_ROM_PTR(&mp_lv_indev_get_act_obj) },
    { MP_ROM_QSTR(MP_QSTR_indev_get_obj_act), MP_ROM_PTR(&mp_lv_indev_get_obj_act_obj) },
    { MP_ROM_QSTR(MP_QSTR_indev_search_obj), MP_ROM_PTR(&mp_lv_indev_search_obj_obj) },
    { MP_ROM_QSTR(MP_QSTR_indev_get_read_task), MP_ROM_PTR(&mp_lv_indev_get_read_task_obj) },
    { MP_ROM_QSTR(MP_QSTR_refr_now), MP_ROM_PTR(&mp_lv_refr_now_obj) },
    { MP_ROM_QSTR(MP_QSTR_disp_load_scr), MP_ROM_PTR(&mp_lv_disp_load_scr_obj) },
    { MP_ROM_QSTR(MP_QSTR_scr_load_anim), MP_ROM_PTR(&mp_lv_scr_load_anim_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_get_act), MP_ROM_PTR(&mp_lv_theme_get_act_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_apply), MP_ROM_PTR(&mp_lv_theme_apply_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_get_font_small), MP_ROM_PTR(&mp_lv_theme_get_font_small_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_get_font_normal), MP_ROM_PTR(&mp_lv_theme_get_font_normal_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_get_font_subtitle), MP_ROM_PTR(&mp_lv_theme_get_font_subtitle_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_get_font_title), MP_ROM_PTR(&mp_lv_theme_get_font_title_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_get_color_primary), MP_ROM_PTR(&mp_lv_theme_get_color_primary_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_get_color_secondary), MP_ROM_PTR(&mp_lv_theme_get_color_secondary_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_get_flags), MP_ROM_PTR(&mp_lv_theme_get_flags_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_empty_init), MP_ROM_PTR(&mp_lv_theme_empty_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_template_init), MP_ROM_PTR(&mp_lv_theme_template_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_material_init), MP_ROM_PTR(&mp_lv_theme_material_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_theme_mono_init), MP_ROM_PTR(&mp_lv_theme_mono_init_obj) },
    { MP_ROM_QSTR(MP_QSTR_font_load), MP_ROM_PTR(&mp_lv_font_load_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_triangle), MP_ROM_PTR(&mp_lv_draw_triangle_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_polygon), MP_ROM_PTR(&mp_lv_draw_polygon_obj) },
    { MP_ROM_QSTR(MP_QSTR_draw_arc), MP_ROM_PTR(&mp_lv_draw_arc_obj) },
    
    { MP_ROM_QSTR(MP_QSTR_LOG_LEVEL), MP_ROM_PTR(&mp_ENUM_LV_LOG_LEVEL_type) },
    { MP_ROM_QSTR(MP_QSTR_RES), MP_ROM_PTR(&mp_LV_RES_type) },
    { MP_ROM_QSTR(MP_QSTR_TASK_PRIO), MP_ROM_PTR(&mp_LV_TASK_PRIO_type) },
    { MP_ROM_QSTR(MP_QSTR_OPA), MP_ROM_PTR(&mp_LV_OPA_type) },
    { MP_ROM_QSTR(MP_QSTR_COORD), MP_ROM_PTR(&mp_ENUM_LV_COORD_type) },
    { MP_ROM_QSTR(MP_QSTR_ALIGN), MP_ROM_PTR(&mp_LV_ALIGN_type) },
    { MP_ROM_QSTR(MP_QSTR_INDEV_TYPE), MP_ROM_PTR(&mp_LV_INDEV_TYPE_type) },
    { MP_ROM_QSTR(MP_QSTR_INDEV_STATE), MP_ROM_PTR(&mp_LV_INDEV_STATE_type) },
    { MP_ROM_QSTR(MP_QSTR_DRAG_DIR), MP_ROM_PTR(&mp_LV_DRAG_DIR_type) },
    { MP_ROM_QSTR(MP_QSTR_GESTURE_DIR), MP_ROM_PTR(&mp_LV_GESTURE_DIR_type) },
    { MP_ROM_QSTR(MP_QSTR_FONT_SUBPX), MP_ROM_PTR(&mp_LV_FONT_SUBPX_type) },
    { MP_ROM_QSTR(MP_QSTR_ANIM), MP_ROM_PTR(&mp_LV_ANIM_type) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_MASK_RES), MP_ROM_PTR(&mp_LV_DRAW_MASK_RES_type) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_MASK_TYPE), MP_ROM_PTR(&mp_LV_DRAW_MASK_TYPE_type) },
    { MP_ROM_QSTR(MP_QSTR_DRAW_MASK_LINE_SIDE), MP_ROM_PTR(&mp_LV_DRAW_MASK_LINE_SIDE_type) },
    { MP_ROM_QSTR(MP_QSTR_BLEND_MODE), MP_ROM_PTR(&mp_LV_BLEND_MODE_type) },
    { MP_ROM_QSTR(MP_QSTR_RADIUS), MP_ROM_PTR(&mp_ENUM_LV_RADIUS_type) },
    { MP_ROM_QSTR(MP_QSTR_BORDER_SIDE), MP_ROM_PTR(&mp_LV_BORDER_SIDE_type) },
    { MP_ROM_QSTR(MP_QSTR_GRAD_DIR), MP_ROM_PTR(&mp_LV_GRAD_DIR_type) },
    { MP_ROM_QSTR(MP_QSTR_TEXT_DECOR), MP_ROM_PTR(&mp_LV_TEXT_DECOR_type) },
    { MP_ROM_QSTR(MP_QSTR_STYLE), MP_ROM_PTR(&mp_LV_STYLE_type) },
    { MP_ROM_QSTR(MP_QSTR_BIDI_DIR), MP_ROM_PTR(&mp_LV_BIDI_DIR_type) },
    { MP_ROM_QSTR(MP_QSTR_TXT_FLAG), MP_ROM_PTR(&mp_LV_TXT_FLAG_type) },
    { MP_ROM_QSTR(MP_QSTR_TXT_CMD_STATE), MP_ROM_PTR(&mp_LV_TXT_CMD_STATE_type) },
    { MP_ROM_QSTR(MP_QSTR_FS_RES), MP_ROM_PTR(&mp_LV_FS_RES_type) },
    { MP_ROM_QSTR(MP_QSTR_FS_MODE), MP_ROM_PTR(&mp_LV_FS_MODE_type) },
    { MP_ROM_QSTR(MP_QSTR_DESIGN), MP_ROM_PTR(&mp_LV_DESIGN_type) },
    { MP_ROM_QSTR(MP_QSTR_DESIGN_RES), MP_ROM_PTR(&mp_LV_DESIGN_RES_type) },
    { MP_ROM_QSTR(MP_QSTR_EVENT), MP_ROM_PTR(&mp_LV_EVENT_type) },
    { MP_ROM_QSTR(MP_QSTR_SIGNAL), MP_ROM_PTR(&mp_LV_SIGNAL_type) },
    { MP_ROM_QSTR(MP_QSTR_PROTECT), MP_ROM_PTR(&mp_LV_PROTECT_type) },
    { MP_ROM_QSTR(MP_QSTR_STATE), MP_ROM_PTR(&mp_LV_STATE_type) },
    { MP_ROM_QSTR(MP_QSTR_KEY), MP_ROM_PTR(&mp_LV_KEY_type) },
    { MP_ROM_QSTR(MP_QSTR_GROUP_REFOCUS_POLICY), MP_ROM_PTR(&mp_LV_GROUP_REFOCUS_POLICY_type) },
    { MP_ROM_QSTR(MP_QSTR_FONT_FMT_TXT_CMAP), MP_ROM_PTR(&mp_LV_FONT_FMT_TXT_CMAP_type) },
    { MP_ROM_QSTR(MP_QSTR_LAYOUT), MP_ROM_PTR(&mp_LV_LAYOUT_type) },
    { MP_ROM_QSTR(MP_QSTR_FIT), MP_ROM_PTR(&mp_LV_FIT_type) },
    { MP_ROM_QSTR(MP_QSTR_LABEL_DOT), MP_ROM_PTR(&mp_ENUM_LV_LABEL_DOT_type) },
    { MP_ROM_QSTR(MP_QSTR_LABEL_POS), MP_ROM_PTR(&mp_ENUM_LV_LABEL_POS_type) },
    { MP_ROM_QSTR(MP_QSTR_LABEL_TEXT_SEL), MP_ROM_PTR(&mp_ENUM_LV_LABEL_TEXT_SEL_type) },
    { MP_ROM_QSTR(MP_QSTR_SCROLLBAR_MODE), MP_ROM_PTR(&mp_LV_SCROLLBAR_MODE_type) },
    { MP_ROM_QSTR(MP_QSTR_CHART_POINT), MP_ROM_PTR(&mp_ENUM_LV_CHART_POINT_type) },
    { MP_ROM_QSTR(MP_QSTR_CHART_TICK_LENGTH), MP_ROM_PTR(&mp_ENUM_LV_CHART_TICK_LENGTH_type) },
    { MP_ROM_QSTR(MP_QSTR_BTNMATRIX_BTN), MP_ROM_PTR(&mp_ENUM_LV_BTNMATRIX_BTN_type) },
    { MP_ROM_QSTR(MP_QSTR_TEXTAREA_CURSOR), MP_ROM_PTR(&mp_ENUM_LV_TEXTAREA_CURSOR_type) },
    { MP_ROM_QSTR(MP_QSTR_DISP_SIZE), MP_ROM_PTR(&mp_LV_DISP_SIZE_type) },
    { MP_ROM_QSTR(MP_QSTR_SCR_LOAD_ANIM), MP_ROM_PTR(&mp_LV_SCR_LOAD_ANIM_type) },
    { MP_ROM_QSTR(MP_QSTR_THEME), MP_ROM_PTR(&mp_LV_THEME_type) },
    { MP_ROM_QSTR(MP_QSTR_THEME_MATERIAL_FLAG), MP_ROM_PTR(&mp_LV_THEME_MATERIAL_FLAG_type) },
    { MP_ROM_QSTR(MP_QSTR_FONT_FMT_TXT), MP_ROM_PTR(&mp_LV_FONT_FMT_TXT_type) },
    { MP_ROM_QSTR(MP_QSTR_SYMBOL), MP_ROM_PTR(&mp_LV_SYMBOL_type) },
    
    { MP_ROM_QSTR(MP_QSTR_C_Pointer), MP_ROM_PTR(&mp_C_Pointer_type) },
    { MP_ROM_QSTR(MP_QSTR_color32_t), MP_ROM_PTR(&mp_lv_color32_t_type) },
    { MP_ROM_QSTR(MP_QSTR_color32_ch_t), MP_ROM_PTR(&mp_lv_color32_ch_t_type) },
    { MP_ROM_QSTR(MP_QSTR_font_t), MP_ROM_PTR(&mp_lv_font_t_type) },
    { MP_ROM_QSTR(MP_QSTR_font_glyph_dsc_t), MP_ROM_PTR(&mp_lv_font_glyph_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_anim_path_t), MP_ROM_PTR(&mp_lv_anim_path_t_type) },
    { MP_ROM_QSTR(MP_QSTR_anim_t), MP_ROM_PTR(&mp_lv_anim_t_type) },
    { MP_ROM_QSTR(MP_QSTR_area_t), MP_ROM_PTR(&mp_lv_area_t_type) },
    { MP_ROM_QSTR(MP_QSTR_style_t), MP_ROM_PTR(&mp_lv_style_t_type) },
    { MP_ROM_QSTR(MP_QSTR_disp_t), MP_ROM_PTR(&mp_lv_disp_t_type) },
    { MP_ROM_QSTR(MP_QSTR_disp_drv_t), MP_ROM_PTR(&mp_lv_disp_drv_t_type) },
    { MP_ROM_QSTR(MP_QSTR_disp_buf_t), MP_ROM_PTR(&mp_lv_disp_buf_t_type) },
    { MP_ROM_QSTR(MP_QSTR_task_t), MP_ROM_PTR(&mp_lv_task_t_type) },
    { MP_ROM_QSTR(MP_QSTR_ll_t), MP_ROM_PTR(&mp_lv_ll_t_type) },
    { MP_ROM_QSTR(MP_QSTR_style_list_t), MP_ROM_PTR(&mp_lv_style_list_t_type) },
    { MP_ROM_QSTR(MP_QSTR_point_t), MP_ROM_PTR(&mp_lv_point_t_type) },
    { MP_ROM_QSTR(MP_QSTR_obj_type_t), MP_ROM_PTR(&mp_lv_obj_type_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_rect_dsc_t), MP_ROM_PTR(&mp_lv_draw_rect_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_label_dsc_t), MP_ROM_PTR(&mp_lv_draw_label_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_img_dsc_t), MP_ROM_PTR(&mp_lv_draw_img_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_line_dsc_t), MP_ROM_PTR(&mp_lv_draw_line_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_img_dsc_t), MP_ROM_PTR(&mp_lv_img_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_img_header_t), MP_ROM_PTR(&mp_lv_img_header_t_type) },
    { MP_ROM_QSTR(MP_QSTR_img_decoder_dsc_t), MP_ROM_PTR(&mp_lv_img_decoder_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_img_decoder_t), MP_ROM_PTR(&mp_lv_img_decoder_t_type) },
    { MP_ROM_QSTR(MP_QSTR_chart_series_t), MP_ROM_PTR(&mp_lv_chart_series_t_type) },
    { MP_ROM_QSTR(MP_QSTR_chart_cursor_t), MP_ROM_PTR(&mp_lv_chart_cursor_t_type) },
    { MP_ROM_QSTR(MP_QSTR_color_hsv_t), MP_ROM_PTR(&mp_lv_color_hsv_t_type) },
    { MP_ROM_QSTR(MP_QSTR_objmask_mask_t), MP_ROM_PTR(&mp_lv_objmask_mask_t_type) },
    { MP_ROM_QSTR(MP_QSTR_calendar_date_t), MP_ROM_PTR(&mp_lv_calendar_date_t_type) },
    { MP_ROM_QSTR(MP_QSTR_mem_monitor_t), MP_ROM_PTR(&mp_lv_mem_monitor_t_type) },
    { MP_ROM_QSTR(MP_QSTR_indev_drv_t), MP_ROM_PTR(&mp_lv_indev_drv_t_type) },
    { MP_ROM_QSTR(MP_QSTR_indev_data_t), MP_ROM_PTR(&mp_lv_indev_data_t_type) },
    { MP_ROM_QSTR(MP_QSTR_indev_t), MP_ROM_PTR(&mp_lv_indev_t_type) },
    { MP_ROM_QSTR(MP_QSTR_indev_proc_t), MP_ROM_PTR(&mp_lv_indev_proc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_indev_proc_types_t), MP_ROM_PTR(&mp_lv_indev_proc_types_t_type) },
    { MP_ROM_QSTR(MP_QSTR_indev_proc_types_pointer_t), MP_ROM_PTR(&mp_lv_indev_proc_types_pointer_t_type) },
    { MP_ROM_QSTR(MP_QSTR_indev_proc_types_keypad_t), MP_ROM_PTR(&mp_lv_indev_proc_types_keypad_t_type) },
    { MP_ROM_QSTR(MP_QSTR_group_t), MP_ROM_PTR(&mp_lv_group_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_line_param_t), MP_ROM_PTR(&mp_lv_draw_mask_line_param_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_common_dsc_t), MP_ROM_PTR(&mp_lv_draw_mask_common_dsc_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_line_param_cfg_t), MP_ROM_PTR(&mp_lv_draw_mask_line_param_cfg_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_angle_param_t), MP_ROM_PTR(&mp_lv_draw_mask_angle_param_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_angle_param_cfg_t), MP_ROM_PTR(&mp_lv_draw_mask_angle_param_cfg_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_radius_param_t), MP_ROM_PTR(&mp_lv_draw_mask_radius_param_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_radius_param_cfg_t), MP_ROM_PTR(&mp_lv_draw_mask_radius_param_cfg_t_type) },
    { MP_ROM_QSTR(MP_QSTR_sqrt_res_t), MP_ROM_PTR(&mp_lv_sqrt_res_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_fade_param_t), MP_ROM_PTR(&mp_lv_draw_mask_fade_param_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_fade_param_cfg_t), MP_ROM_PTR(&mp_lv_draw_mask_fade_param_cfg_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_map_param_t), MP_ROM_PTR(&mp_lv_draw_mask_map_param_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_mask_map_param_cfg_t), MP_ROM_PTR(&mp_lv_draw_mask_map_param_cfg_t_type) },
    { MP_ROM_QSTR(MP_QSTR_fs_drv_t), MP_ROM_PTR(&mp_lv_fs_drv_t_type) },
    { MP_ROM_QSTR(MP_QSTR_fs_file_t), MP_ROM_PTR(&mp_lv_fs_file_t_type) },
    { MP_ROM_QSTR(MP_QSTR_fs_dir_t), MP_ROM_PTR(&mp_lv_fs_dir_t_type) },
    { MP_ROM_QSTR(MP_QSTR_theme_t), MP_ROM_PTR(&mp_lv_theme_t_type) },
    { MP_ROM_QSTR(MP_QSTR_draw_label_hint_t), MP_ROM_PTR(&mp_lv_draw_label_hint_t_type) },
    
    { MP_ROM_QSTR(MP_QSTR_color_t), MP_ROM_PTR(&mp_lv_color32_t_type) },
    
    { MP_ROM_QSTR(MP_QSTR_font_montserrat_14), MP_ROM_PTR(&mp_lv_font_montserrat_14) },
    { MP_ROM_QSTR(MP_QSTR_font_montserrat_16), MP_ROM_PTR(&mp_lv_font_montserrat_16) },
    { MP_ROM_QSTR(MP_QSTR_font_dejavu_16_persian_hebrew), MP_ROM_PTR(&mp_lv_font_dejavu_16_persian_hebrew) },
    { MP_ROM_QSTR(MP_QSTR_anim_path_def), MP_ROM_PTR(&mp_lv_anim_path_def) },
    
    
};


STATIC MP_DEFINE_CONST_DICT (
    mp_module_lvgl_globals,
    lvgl_globals_table
);

const mp_obj_module_t mp_module_lvgl = {
    .base = { &mp_type_module },
    .globals = (mp_obj_dict_t*)&mp_module_lvgl_globals
};

